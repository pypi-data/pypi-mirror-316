#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""" Model for Vulnerability in the application """
from enum import Enum
from typing import List, Optional, Union
from urllib.parse import urljoin
from warnings import warn

from pydantic import ConfigDict, Field
from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.models import regscale_models
from regscale.models.regscale_models.regscale_model import RegScaleModel


def deprecated(message):
    def decorator(func):
        def wrapper(*args, **kwargs):
            warn(f"{func.__name__} is deprecated. {message}", DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)

        return wrapper

    return decorator


class VulnerabilitySeverity(str, Enum):
    """Vulnerability Severity"""

    Low = "LOW"
    Medium = "MEDIUM"
    High = "HIGH"


class VulnerabilityStatus(str, Enum):
    """Vulnerability Status"""

    Open = "OPEN"
    Closed = "CLOSED"


class Vulnerability(RegScaleModel):
    """Vulnerability Model"""

    _module_slug = "vulnerability"
    _unique_fields = [
        ["plugInName", "parentId", "parentModule"],
    ]

    id: int = 0
    createdById: str = Field(default_factory=RegScaleModel._api_handler.get_user_id)
    dateCreated: str = Field(default_factory=get_current_datetime)
    lastUpdatedById: str = Field(default_factory=RegScaleModel._api_handler.get_user_id)
    dateLastUpdated: str = Field(default_factory=get_current_datetime)
    uuid: Optional[str] = None
    scanId: Optional[int] = Field(None, alias="scan_id")
    parentId: Optional[int] = Field(None, alias="parent_id")
    parentModule: Optional[str] = Field(None, alias="parent_module")
    lastSeen: Optional[str] = Field(None, alias="last_seen")
    firstSeen: Optional[str] = Field(None, alias="first_seen")
    daysOpen: Optional[int] = Field(None, alias="days_open")
    dns: Optional[str] = None
    ipAddress: Optional[str] = Field("", alias="ip_address")
    mitigated: Optional[bool] = None
    operatingSystem: Optional[str] = Field(None, alias="operating_system")
    port: Optional[Union[str, int]] = None
    protocol: Optional[str] = None
    severity: Optional[Union[str, VulnerabilitySeverity]] = None
    plugInName: Optional[str] = Field(None, alias="plugin_name")
    plugInId: Optional[int] = Field(None, alias="plugin_id")
    cve: Optional[str] = None
    vprScore: Optional[Union[int, float]] = Field(None, alias="vpr_score")
    exploitAvailable: Optional[bool] = Field(None, alias="exploit_available")
    title: Optional[str] = None
    cvsSv3BaseScore: Optional[Union[float, int]] = Field(0, alias="cvss_v3_base_score")
    description: Optional[str] = None
    plugInText: Optional[str] = Field(None, alias="plugin_text")
    tenantsId: int = Field(0, alias="tenants_id")
    isPublic: bool = Field(False, alias="is_public")
    dateClosed: Optional[str] = Field(None, alias="date_closed")
    status: Optional[VulnerabilityStatus] = VulnerabilityStatus.Open

    @staticmethod
    def _get_additional_endpoints() -> ConfigDict:
        """
        Get additional endpoints for the Vulnerability model, using {model_slug} as a placeholder for the model slug.

        :return: A dictionary of additional endpoints
        :rtype: ConfigDict
        """
        return ConfigDict(  # type: ignore
            get_count="/api/{model_slug}/getCount",  # type: ignore
            batch_create="/api/{model_slug}/batchCreate",  # type: ignore
            find_by_guid="/api/{model_slug}/findByGUID/{strGUID}",  # type: ignore
            drilldown="/api/{model_slug}/drilldown/{parentId}/{scanId}/{strSeverity}/{intPage}/"  # type: ignore
            "{intPageSize}",
            lookup_cve="/api/{model_slug}/lookupCVE/{strCVE}",  # type: ignore
            get="/api/{model_slug}/find/{id}",  # type: ignore
        )

    @staticmethod
    def determine_cvss3_severity_text(cvs_sv3_base_score: float) -> str:
        """
        Determine CVSS3 Severity Text from CVSS3 Base Score

        :param float cvs_sv3_base_score: CVSS3 Base Score
        :return: CVSS3 Severity Text
        :rtype: str
        """
        results = "low"
        if 4.0 <= cvs_sv3_base_score <= 6.9:
            results = "medium"
        elif 7.0 <= cvs_sv3_base_score <= 8.9:
            results = "high"
        elif cvs_sv3_base_score > 8.9:
            results = "critical"
        return results

    @staticmethod
    @deprecated("Use Vulnerability.get_all_by_parent() instead")
    def find_vulns_by_scan(app: Application, scan_id: int) -> List["Vulnerability"]:  # noqa: F841
        """
        Find Vulnerabilities by Scan ID

        :param Application app: Application instance
        :param int scan_id: Scan ID
        :return: List of Vulnerabilities
        :rtype: List[Vulnerability]
        """
        return Vulnerability.get_all_by_parent(parent_id=scan_id, parent_module=regscale_models.Scan.get_module_slug())

    @classmethod
    @deprecated("Use Vulnerability.create() instead")
    def post_vulnerability(cls, vulnerability: "Vulnerability") -> Optional["Vulnerability"]:
        """
        Post a vulnerability to the API

        :param Vulnerability vulnerability: The vulnerability to be posted
        :return: The response from the API as a dictionary
        :rtype: Optional["Vulnerability"]
        """
        return vulnerability.create()

    @classmethod
    @deprecated(
        "Use Vulnerability.create() for individual vulnerabilities or Vulnerability.batch_create() for "
        "multiple vulnerabilities"
    )
    def post_vulnerabilities(
        cls,
        app: Application,  # noqa: F841
        vulnerabilities: List["Vulnerability"],
        output_to_console: Optional[bool] = True,
    ) -> List[Response]:
        """
        Insert new vulnerabilities into RegScale

        :param Application app: Application object
        :param List[Vulnerability] vulnerabilities: List of Vulnerability objects
        :param Optional[bool] output_to_console: Whether to output to console, defaults to True
        :return: A list of Responses
        :rtype List[Response]
        """
        responses = []

        def batch_post(url: str, dat: list[dict]) -> Response:
            """
            Simple wrapper to post a list of JSON data to a URL

            :param str url: URL to post to
            :param list[dict] dat: A list of JSON data to post
            :return: Response object
            :rtype: Response
            """
            return api.post(url=url, json=dat)

        api = Api()
        if output_to_console and vulnerabilities:
            api.logger.info("Creating %i new vulnerabilities in RegScale...", len(vulnerabilities))
        # Create batches of vulnerabilities to post
        batch_size = 500
        batches = [vulnerabilities[i : i + batch_size] for i in range(0, len(vulnerabilities), batch_size)]
        for batch in batches:
            res = batch_post(
                url=urljoin(api.config["domain"], cls.get_endpoint("batch_create")),
                dat=[vuln.model_dump() for vuln in batch],
            )
            if res.ok:
                responses.extend(res.json())
        if len(responses):
            api.logger.info("Successfully created %i new vulnerabilities in RegScale", len(responses))
        return responses
