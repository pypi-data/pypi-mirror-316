from .dialogue import *
from _typeshed import Incomplete
from collections import deque
from typing import Any

class TileMapImagesModule:
    DARKNESS: int
    DEFAULT_TILE_MAP_IMAGE_SPRITE_SHEET: SpriteImage
    __DEFAULT_TILE_MAP_IMAGE_SPRITE_SHEET_INITIALIZED: bool
    __ENV_IMAGE_DICT: Final[dict[str, StaticImage | tuple[StaticImage, ...]]]
    __ENV_IMAGE_DICT_DARK: Final[dict[str, StaticImage | tuple[StaticImage, ...]]]
    TILE_SIZE: int
    TILE_TEMPLE_WIDTH: int
    TILE_TEMPLE_HEIGHT: int
    @classmethod
    def init(cls) -> None: ...
    @classmethod
    def update_size(cls, _size: int) -> None: ...
    @classmethod
    def add_image(cls, _id: str) -> None: ...
    @classmethod
    def get_image(cls, _id: str, darkMode: bool = False) -> StaticImage: ...

class DecorationImagesModule:
    DEFAULT_DECORATION_IMAGE_SPRITE_SHEET: SpriteImage
    __IS_DEFAULT_DECORATION_IMAGE_SPRITE_SHEET_INITIALIZED: bool
    CUSTOM_DECORATION_IMAGE_SPRITE_SHEET: SpriteImage
    __IS_CUSTOM_DECORATION_IMAGE_SPRITE_SHEET_INITIALIZED: bool
    __DECORATION_IMAGE_DICT: Final[dict[str, StaticImage | tuple[StaticImage, ...]]]
    __DECORATION_IMAGE_DICT_DARK: Final[dict[str, StaticImage | tuple[StaticImage, ...]]]
    @classmethod
    def init(cls) -> None: ...
    @classmethod
    def count_variations(cls, _type: str) -> int: ...
    @classmethod
    def add_image(cls, _type: str) -> None: ...
    @classmethod
    def get_image(cls, _id: str, darkMode: bool = False) -> StaticImage: ...

class _EntityImagesCollection:
    __images: Incomplete
    __current_image_pointer: Incomplete
    __width: int
    __height: int
    __cropped_image_width: Incomplete
    __cropped_image_height: Incomplete
    __left_offset_x: Incomplete
    __offset_y: Incomplete
    __real_width: Incomplete
    __real_height: Incomplete
    __right_offset_x: Incomplete
    def __init__(self, imagesList: tuple[StaticImage, ...], crop_size: list[int], offset: list[int], original_img_size: list[int]) -> None: ...
    def __len__(self) -> int: ...
    def get_image(self, index: int) -> StaticImage: ...
    def set_size(self, width: int_f, height: int_f) -> None: ...
    def set_index(self, index: int) -> None: ...
    def flip_all(self) -> None: ...
    def get_rectangle(self) -> Rectangle: ...
    def render(self, _surface: ImageSurface, pos: tuple[int, int], alpha: int, ifFlip: bool, draw_outline: bool) -> None: ...

class EntitySpriteImageManager:
    __CHARACTERS_IMAGES: Final[dict[str, dict[str, _EntityImagesCollection]]]
    SPRITES_PATH: Final[str]
    @classmethod
    def get_images(cls, characterType: str, action: str) -> _EntityImagesCollection: ...
    @classmethod
    def try_get_image_references(cls, faction: str, characterType: str, action: str) -> _EntityImagesCollection: ...
    @classmethod
    def does_action_exist(cls, characterType: str, action: str) -> bool: ...
    @classmethod
    def generate(cls, entityFaction: str, entityType: str) -> None: ...
    @classmethod
    def generate_all(cls) -> None: ...
    @classmethod
    def load(cls, faction: str, characterType: str, mode: str) -> dict: ...
    @classmethod
    def __load_action(cls, faction: str, characterType: str, action: str, action_meta_data: dict) -> dict: ...

class DecorationObject(GameObject2d):
    __type: Incomplete
    _variation: Incomplete
    __status: Incomplete
    __alpha: int
    __is_dark_mode: bool
    def __init__(self, x: int, y: int, _type: str, _variation: int, status: dict = {}) -> None: ...
    def ensure_image_cached(self) -> None: ...
    @property
    def id(self) -> str: ...
    @property
    def type(self) -> str: ...
    @property
    def variation(self) -> int: ...
    def get_alpha(self) -> int: ...
    def set_alpha(self, value: int) -> None: ...
    def set_dark_mode(self, value: bool) -> None: ...
    def to_dict(self) -> dict: ...
    @staticmethod
    def from_dict(_data: dict) -> DecorationObject: ...
    def is_on_pos(self, pos: object) -> bool: ...
    def _has_status(self, key: str) -> bool: ...
    def get_status(self, key: str) -> object: ...
    def set_status(self, key: str, value: object) -> None: ...
    def remove_status(self, key: str) -> None: ...
    def display(self, _surface: ImageSurface, offSet: tuple[int, int] = ...) -> None: ...
    def get_width(self) -> int: ...
    def get_height(self) -> int: ...

class Entity(Position):
    __SOUNDS: Final[dict[str, dict[str, tuple]]]
    __DATABASE: Final[dict[str, dict]]
    __IDLE_ACTION: Final[str]
    __attack_coverage: Incomplete
    __max_hp: Incomplete
    __current_hp: Incomplete
    __irrecoverable_armor: Incomplete
    __max_recoverable_armor: Incomplete
    __current_recoverable_armor: Incomplete
    __effective_range: Incomplete
    __max_damage: Incomplete
    __min_damage: Incomplete
    __kind: Incomplete
    __faction: Incomplete
    __attitude: int
    __type: Incomplete
    _if_flip: Incomplete
    __current_action: Incomplete
    __if_action_loop: Incomplete
    __if_switch_to_idle_afterwards: Incomplete
    _if_play_action_in_reversing: Incomplete
    __moving_path: Incomplete
    __moving_complete: Incomplete
    __if_invincible: Incomplete
    __imgId_dict: Incomplete
    __just_entered_a_new_tile: bool
    __current_image_rect: Incomplete
    __is_selected: bool
    _move_speed_scale: float
    def __init__(self, DATA: dict, mode: str) -> None: ...
    def to_dict(self) -> dict: ...
    def just_entered_a_new_tile(self) -> bool: ...
    def get_coordinate(self) -> tuple[int, int]: ...
    @classmethod
    def get_entity_data(cls, _type: str) -> dict: ...
    @property
    def faction(self) -> str: ...
    @property
    def attitude(self) -> int: ...
    def set_attitude(self, value: int) -> None: ...
    @property
    def kind(self) -> str: ...
    @property
    def type(self) -> str: ...
    @property
    def attack_coverage(self) -> int: ...
    @property
    def effective_range(self) -> tuple[int, ...]: ...
    @property
    def max_damage(self) -> int: ...
    @property
    def min_damage(self) -> int: ...
    def attack(self, another_entity: Entity) -> int: ...
    def get_selected(self) -> bool: ...
    def set_selected(self, value: bool) -> None: ...
    def is_hovered(self) -> bool: ...
    def is_overlapped_with(self, _rect: Rectangle) -> bool: ...
    @property
    def action(self) -> str: ...
    def set_action(self, action: str = 'wait', ifLoop: bool = True, switchToIdleAfterwards: bool = True) -> None: ...
    def is_idle(self) -> bool: ...
    def get_imgId(self, action: str) -> int: ...
    def get_imgNum(self, action: str) -> int: ...
    def set_imgId(self, action: str, imgId: float) -> None: ...
    def reset_imgId(self, action: str) -> None: ...
    def add_imgId(self, action: str, amount: float = 1.0) -> None: ...
    def get_imgAlpha(self, action: str) -> int: ...
    def set_imgAlpha(self, action: str, alpha: int) -> None: ...
    def is_alive(self) -> bool: ...
    @property
    def current_hp(self) -> int: ...
    @property
    def max_hp(self) -> int: ...
    @property
    def hp_percentage(self) -> float: ...
    def heal(self, hpHealed: int) -> None: ...
    def injury(self, damage: int) -> None: ...
    def recover_armor(self, value: int) -> None: ...
    def set_flip(self, theBool: bool) -> None: ...
    def play_sound(self, kind_of_sound: str) -> None: ...
    def move_follow(self, path: Sequence[tuple[int, int]]) -> None: ...
    def near(self, otherEntity: Position | Coordinate) -> bool: ...
    @staticmethod
    def _identify_range(_ranges: tuple[int, ...], distanceBetween: int) -> int: ...
    def range_target_in(self, otherEntity: Entity) -> int: ...
    def set_flip_based_on_pos(self, _pos: tuple[number, number]) -> None: ...
    def __render(self, _surface: ImageSurface, pos: tuple[int, int], size: tuple[int, int], action: str, alpha: int) -> None: ...
    def _get_current_speed_x(self) -> float: ...
    def _get_current_speed_y(self) -> float: ...
    def render(self, _surface: ImageSurface, pos: tuple[int, int], size: tuple[int, int], action: str | None = None, alpha: int | None = None) -> None: ...

class _AStarPoint(Coordinate):
    def __eq__(self, other: _AStarPoint) -> bool: ...

class _AStarNode:
    point: Incomplete
    father: Incomplete
    g: Incomplete
    h: Incomplete
    def __init__(self, point: _AStarPoint, endPoint: _AStarPoint, g: number = 0) -> None: ...

class AStar:
    __map2d: numpy.ndarray
    __row: int
    __column: int
    __end_point: _AStarPoint
    __open_list: deque[_AStarNode]
    __close_list: set[_AStarNode]
    @classmethod
    def __update(cls, new_map2d: numpy.ndarray) -> None: ...
    @classmethod
    def __is_out_of_bound(cls, _point: _AStarPoint) -> bool: ...
    @classmethod
    def __getMinNode(cls) -> _AStarNode: ...
    @classmethod
    def __pointInCloseList(cls, point: _AStarPoint) -> bool: ...
    @classmethod
    def __pointInOpenList(cls, point: _AStarPoint) -> _AStarNode | None: ...
    @classmethod
    def __end_pointInCloseList(cls) -> _AStarNode | None: ...
    @classmethod
    def __searchNear(cls, minF: _AStarNode, offSetX: int, offSetY: int) -> None: ...
    @classmethod
    def search(cls, map2d: numpy.ndarray, start_pos: tuple[int, int], end_pos: tuple[int, int]) -> list[tuple[int, int]]: ...

class AbstractTileMap(Rectangle, SurfaceWithLocalPos):
    __TILES_DATABASE: Final[dict]
    _DECORATION_DATABASE: Final[dict]
    __MAP: Incomplete
    __BARRIER_MASK: Incomplete
    __tile_lookup_table: Incomplete
    __row: int
    __column: int
    __map_surface: Incomplete
    __map_surface_old: Incomplete
    __don_save_old_map_surface_for_next_update: bool
    __background_image: Incomplete
    __decorations: Incomplete
    __need_update_surface: bool
    __tile_on_surface: Incomplete
    __need_to_recheck_tile_on_surface: bool
    def __init__(self) -> None: ...
    @staticmethod
    def __get_coordinate_format_key(_coordinate: tuple[int, int]) -> str: ...
    def __init_map(self, map_data: numpy.ndarray, barrier_data: numpy.ndarray | None, tile_size: int_f) -> None: ...
    def _refresh(self) -> None: ...
    def update(self, _data: dict, _block_size: int_f) -> None: ...
    @property
    def decorations(self) -> tuple[DecorationObject, ...]: ...
    @property
    def row(self) -> int: ...
    @property
    def column(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def set_barrier_mask(self, x: int, y: int, value: int) -> None: ...
    def add_on_axis(self, index: int, axis: int = 0) -> None: ...
    def remove_on_axis(self, index: int, axis: int = 0) -> None: ...
    @property
    def tile_width(self) -> int: ...
    @property
    def tile_height(self) -> int: ...
    @property
    def tile_size(self) -> int: ...
    def to_dict(self) -> dict[str, Any]: ...
    def is_passable(self, _x: int, _y: int, supposed: bool = False) -> bool: ...
    def get_local_pos_in_percentage(self) -> dict[str, str]: ...
    def get_decoration(self, pos: object) -> DecorationObject | None: ...
    def add_decoration(self, _item: dict | DecorationObject) -> None: ...
    def remove_decoration(self, decoration: DecorationObject) -> None: ...
    def count_decorations(self) -> int: ...
    def set_tile_size(self, newPerBlockWidth: int_f) -> None: ...
    def set_local_x(self, value: int_f) -> None: ...
    def set_local_y(self, value: int_f) -> None: ...
    def _get_tile_image(self, x: int, y: int) -> StaticImage: ...
    def render(self, _surface: ImageSurface, screen_to_move_x: int = 0, screen_to_move_y: int = 0) -> tuple[int, int]: ...
    def get_tile(self, _x: int, _y: int) -> str: ...
    def set_tile(self, _x: int, _y: int, name: str) -> None: ...
    def replace_tiles(self, from_tile: str, to_tile: str) -> None: ...
    def calculate_coordinate(self, on_screen_pos: tuple[int, int] | None = None) -> tuple[int, int] | None: ...
    def calculate_position(self, x: int_f, y: int_f) -> tuple[int, int]: ...
    def find_path(self, start: tuple[int, int], goal: tuple[int, int], lenMax: int | None = None, map2d: numpy.ndarray | None = None) -> list[tuple[int, int]]: ...

class AbstractBattleSystem(AbstractGameSystem, metaclass=ABCMeta):
    __mouse_move_temp_x: int
    __mouse_move_temp_y: int
    _screen_to_move_speed_x: Incomplete
    _screen_to_move_speed_y: Incomplete
    __moving_screen_in_direction_up: bool
    __moving_screen_in_direction_down: bool
    __moving_screen_in_direction_left: bool
    __moving_screen_in_direction_right: bool
    _entities_data: Incomplete
    __map: Incomplete
    _standard_tile_size: Incomplete
    _tile_is_hovering: Incomplete
    def __init__(self) -> None: ...
    def _display_entities(self, _surface: ImageSurface) -> None: ...
    def _load_entities(self, _entities: dict, _mode: str) -> None: ...
    def new(self, chapterType: str, chapterId: int, projectName: str | None = None) -> None: ...
    def get_map(self) -> AbstractTileMap: ...
    def set_map(self, _map: AbstractTileMap) -> None: ...
    def _load_map(self, _data: dict) -> None: ...
    def _process_data(self, _data: dict) -> None: ...
    def get_data_file_path(self) -> str: ...
    def _get_data_need_to_save(self) -> dict: ...
    def _check_key_down(self, event: PG_Event) -> None: ...
    def _check_key_up(self, event: PG_Event) -> None: ...
    def _check_joystick_events(self) -> None: ...
    def _display_map(self, _surface: ImageSurface) -> None: ...

class AbstractMapEditor(AbstractBattleSystem, metaclass=ABCMeta):
    class _MODIFY(enum.IntEnum):
        DISABLE: Incomplete
        DELETE_ENTITY: Incomplete
        DELETE_ROW: Incomplete
        DELETE_COLUMN: Incomplete
        ADD_ROW_ABOVE: Incomplete
        ADD_ROW_BELOW: Incomplete
        ADD_COLUMN_BEFORE: Incomplete
        ADD_COLUMN_AFTER: Incomplete
    __buttons_container: Incomplete
    __right_container_buttons: Incomplete
    __UIContainerRight: Incomplete
    __UIContainerBottom: Incomplete
    __bottom_container_buttons: Incomplete
    __entitiesImagesContainers: Incomplete
    __entitiesImagesContainerUsingIndex: int
    __envImgContainer: Incomplete
    __decorationsImgContainer: Incomplete
    __object_to_put_down: Incomplete
    __no_save_warning: Incomplete
    _select_rect: Incomplete
    _select_pos: Incomplete
    _modify_mode: Incomplete
    _no_container_is_hovered: bool
    _show_barrier_mask: bool
    __level_data_history: Incomplete
    __current_level_data_index: int
    def __init__(self) -> None: ...
    def update_entity(self, faction: str, key: str, data: dict) -> None: ...
    def _get_data_need_to_save(self) -> dict: ...
    def is_any_object_selected(self) -> bool: ...
    def _process_data(self, _data: dict) -> None: ...
    def __load_level(self, data: dict) -> None: ...
    def __reset_level_history(self) -> None: ...
    def __append_level_history(self) -> None: ...
    __UIContainerButtonRight: Incomplete
    __UIContainerButtonBottom: Incomplete
    def _init_ui(self) -> None:
        """加载右侧的界面"""
    def new(self, chapterType: str, chapterId: int, projectName: str | None = None) -> None: ...
    def load_progress(self, _data: dict) -> None: ...
    def set_decoration(self, _item: str | None, _pos: tuple[int, int]) -> None: ...
    def delete_entity(self, _filter: Callable[[Entity], bool]) -> bool: ...
    def move_entity(self, _filter: Callable[[Entity], bool], x: int, y: int) -> None: ...
    def set_entity(self, _item: str | None, _pos: tuple[int, int]) -> None: ...
    def set_tile(self, _item: str, _pos: tuple[int, int]) -> None: ...
    def delete_entity_on_tile(self, _pos: tuple[int, int]) -> None: ...
    def draw(self, _surface: ImageSurface) -> None: ...
