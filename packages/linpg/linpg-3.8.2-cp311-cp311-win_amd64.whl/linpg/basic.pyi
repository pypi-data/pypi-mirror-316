from .language import *
import enum
import io
import numpy
import pygame
from _typeshed import Incomplete
from dataclasses import dataclass
from tkinter import Tk
from typing import Any

ORIGIN: Final[tuple[int, int]]
int_f = int | float
number = int | float

class Positions:
    @staticmethod
    def convert(pos: Any) -> tuple[number, number]: ...
    @staticmethod
    def is_same(pos1: object, pos2: object) -> bool: ...
    @staticmethod
    def add(*positions: tuple[number, number]) -> tuple[number, number]: ...
    @staticmethod
    def subtract(position: tuple[number, number], *positions: tuple[number, number]) -> tuple[number, number]: ...

class Coordinates:
    @staticmethod
    def convert(pos: Any) -> tuple[int, int]: ...
    @staticmethod
    def is_same(pos1: object, pos2: object) -> bool: ...
    @staticmethod
    def add(*positions: tuple[number, number]) -> tuple[int, int]: ...
    @staticmethod
    def subtract(position: tuple[number, number], *positions: tuple[number, number]) -> tuple[int, int]: ...
    @staticmethod
    def get_in_diamond_shaped(_x: int, _y: int, _radius: int) -> list[tuple[int, int]]: ...
color_liked = Sequence[int] | str
ImageSurface: Incomplete
PoI: Incomplete
PG_Event: Incomplete

class UniversalImageSurface:
    _wrapped_obj: Incomplete
    __path: Incomplete
    def __init__(self, obj: pygame.Surface, file_path: str = '') -> None: ...
    def __getattr__(self, attr: str) -> Any: ...
    @property
    def path(self) -> str: ...

class GraphicLibrary:
    PYGAME: Final[int]
    PYGAME_CE: Final[int]
    __IS_CE: Final[bool]
    @classmethod
    def is_using_pygame(cls) -> bool: ...
    @classmethod
    def is_using_pygame_ce(cls) -> bool: ...
    @classmethod
    def get_name(cls) -> str: ...

class Events(enum.IntEnum):
    MOUSE_BUTTON_DOWN = ...
    MOUSE_BUTTON_UP = ...
    JOYSTICK_BUTTON_DOWN = ...
    JOYSTICK_BUTTON_UP = ...
    KEY_DOWN = ...
    KEY_UP = ...

class Axis(enum.IntEnum):
    VERTICAL = ...
    HORIZONTAL = ...

class Locations(enum.IntEnum):
    BEGINNING = ...
    END = ...
    MIDDLE = ...
    EVERYWHERE = ...

class Numbers:
    @staticmethod
    def get_random_int(start: int, end: int) -> int: ...
    @staticmethod
    def keep_int_in_range(_number: int, min_value: int, max_value: int) -> int: ...
    @staticmethod
    def keep_number_in_range(_number: number, min_value: number, max_value: number) -> number: ...
    @staticmethod
    def convert_percentage(percentage: str | float | int) -> float: ...

class Colors:
    """常用颜色"""
    WHITE: Final[tuple[int, int, int, int]]
    GRAY: Final[tuple[int, int, int, int]]
    LIGHT_GRAY: Final[tuple[int, int, int, int]]
    BLACK: Final[tuple[int, int, int, int]]
    RED: Final[tuple[int, int, int, int]]
    ORANGE: Final[tuple[int, int, int, int]]
    YELLOW: Final[tuple[int, int, int, int]]
    GREEN: Final[tuple[int, int, int, int]]
    BLUE: Final[tuple[int, int, int, int]]
    INDIGO: Final[tuple[int, int, int, int]]
    VIOLET: Final[tuple[int, int, int, int]]
    TRANSPARENT: Final[tuple[int, int, int, int]]
    LIGHT_SKY_BLUE: Final[tuple[int, int, int, int]]
    DODGER_BLUE: Final[tuple[int, int, int, int]]
    @staticmethod
    def __to_rgba_color(color: Sequence) -> tuple[int, int, int, int]: ...
    @classmethod
    def get(cls, color: color_liked) -> tuple[int, int, int, int]: ...

class Keys:
    ESCAPE: Final[int]
    SPACE: Final[int]
    BACKSPACE: Final[int]
    DELETE: Final[int]
    LEFT_CTRL: Final[int]
    ARROW_UP: Final[int]
    ARROW_DOWN: Final[int]
    ARROW_LEFT: Final[int]
    ARROW_RIGHT: Final[int]
    RETURN: Final[int]
    BACKQUOTE: Final[int]
    F3: Final[int]
    __root: Final[Tk]
    @classmethod
    def get_pressed(cls, key_name: str | int) -> bool: ...
    @staticmethod
    def get_key_code(key_name: str) -> int: ...
    @classmethod
    def get_clipboard(cls) -> str: ...

class Draw:
    @staticmethod
    def rect(_surface: ImageSurface, color: tuple[int, int, int, int], rect: tuple[int, int, int, int] | tuple[tuple[int, int], tuple[int, int]], thickness: int = 0, radius: int = -1) -> None: ...
    @staticmethod
    def circle(_surface: ImageSurface, color: tuple[int, int, int, int], center_pos: tuple[int, int], radius: int, thickness: int = 0) -> None: ...
    @staticmethod
    def ellipse(_surface: ImageSurface, color: tuple[int, int, int, int], center_pos: tuple[int, int], radius: tuple[int, int], thickness: int = 0) -> None: ...
    @staticmethod
    def aaline(_surface: ImageSurface, color: tuple[int, int, int, int], start_pos: tuple[int, int], end_pos: tuple[int, int]) -> None: ...
    @staticmethod
    def line(_surface: ImageSurface, color: tuple[int, int, int, int], start_pos: tuple[int, int], end_pos: tuple[int, int], width: int = 1) -> None: ...
    @staticmethod
    def polygon(_surface: ImageSurface, _color: tuple[int, int, int, int], _points: tuple[tuple[int, int], ...], thickness: int = 0) -> None: ...

class Surfaces:
    NULL: Final[ImageSurface]
    @staticmethod
    def new(size: tuple[int, int], surface_flags: int = -1) -> ImageSurface: ...
    @staticmethod
    def transparent(size: tuple[int, int]) -> ImageSurface: ...
    @staticmethod
    def colored(size: tuple[int, int], color: color_liked) -> ImageSurface: ...
    @classmethod
    def from_array(cls, surface_array: numpy.ndarray, swap_axes: bool = True) -> ImageSurface: ...
    @staticmethod
    def to_array(_surface: ImageSurface, with_alpha: bool = True, swap_axes: bool = True) -> numpy.ndarray: ...
    @classmethod
    def texture_is_missing(cls, size: tuple[int, int]) -> ImageSurface: ...
    @classmethod
    def is_not_null(cls, _surface: ImageSurface | None) -> bool: ...

class Filters:
    @staticmethod
    def gaussian_blur(_surface: ImageSurface, radius: int = 10, repeat_edge_pixels: bool = True, dest_surface: ImageSurface | None = None) -> ImageSurface: ...
    @classmethod
    def box_blur(cls, _surface: ImageSurface, radius: int = 10, repeat_edge_pixels: bool = True, dest_surface: ImageSurface | None = None) -> ImageSurface: ...
    @staticmethod
    def add_darkness(img: ImageSurface, value: int) -> ImageSurface: ...
    @staticmethod
    def subtract_darkness(img: ImageSurface, value: int) -> ImageSurface: ...

_LINPGASSETS_INITIALIZED: bool
_KEY: Final[bytes]

class Images:
    __FLAG_LOOKUP_TABLE: Final[dict[str, str]]
    @staticmethod
    def __load(_file: str | io.BytesIO) -> ImageSurface: ...
    @classmethod
    def generate_path_according_to_prefix(cls, path: str) -> str: ...
    @classmethod
    def quickly_load(cls, path: PoI, convert_alpha: bool = True) -> ImageSurface: ...
    @classmethod
    def load(cls, path: PoI, size: tuple = ..., alpha: int = 255, convert_alpha: bool = True) -> ImageSurface: ...
    @staticmethod
    def resize(img: ImageSurface, size: tuple) -> ImageSurface: ...
    @staticmethod
    def smoothly_resize(img: ImageSurface, size: tuple) -> ImageSurface: ...
    @classmethod
    def smoothly_resize_and_crop_to_fit(cls, img: ImageSurface, size: tuple[int, int]) -> ImageSurface: ...
    @staticmethod
    def flip(img: ImageSurface, horizontal: bool, vertical: bool) -> ImageSurface: ...
    @staticmethod
    def rotate(img: ImageSurface, angle: int) -> ImageSurface: ...
    @classmethod
    def crop_bounding(cls, img: ImageSurface) -> ImageSurface: ...
    @staticmethod
    def save(_surface: ImageSurface, path: str) -> None: ...
    @classmethod
    def fromBytesIO(cls, _bytes: io.BytesIO) -> ImageSurface: ...

class Controller:
    class __JoystickController:
        __input: pygame.joystick.JoystickType | None
        @classmethod
        def get_init(cls) -> bool: ...
        @classmethod
        def get_button(cls, buttonId: int) -> bool: ...
        @classmethod
        def get_axis(cls, buttonId: int) -> float: ...
        @classmethod
        def is_active(cls) -> bool: ...
        @classmethod
        def update(cls) -> None: ...
    class __MouseController:
        x: int
        y: int
        __last_x: int
        __last_y: int
        __moving_speed: int
        __mouse_get_pressed_previously: tuple[bool, ...]
        __icon_img: ImageSurface | None
        @classmethod
        def set_custom_icon(cls, path: str) -> None: ...
        @classmethod
        def get_moving_speed(cls) -> int: ...
        @classmethod
        def get_x_moved(cls) -> int: ...
        @classmethod
        def get_y_moved(cls) -> int: ...
        @classmethod
        def get_pos(cls) -> tuple[int, int]: ...
        @classmethod
        def set_pos(cls, pos: tuple) -> None: ...
        @staticmethod
        def get_pressed(button_id: int) -> bool: ...
        @classmethod
        def get_pressed_previously(cls, button_id: int) -> bool: ...
        @classmethod
        def get_pressed_since(cls, button_id: int) -> bool: ...
        @classmethod
        def is_in_rect(cls, _x: int, _y: int, _width: int, _height: int) -> bool: ...
        @classmethod
        def update(cls) -> None: ...
        @classmethod
        def finish_up(cls) -> None: ...
        @classmethod
        def draw_custom_icon(cls, _surface: ImageSurface) -> None: ...
    joystick = __JoystickController
    mouse = __MouseController
    __INPUT_EVENTS: tuple
    __SPECIFIC_EVENTS: Final[dict[str, bool]]
    NEED_TO_TAKE_SCREENSHOT: bool
    @classmethod
    def get_events(cls) -> tuple: ...
    @classmethod
    def get_event(cls, event_type: str) -> bool: ...
    @classmethod
    def set_event(cls, event_type: str, value: bool) -> None: ...
    @classmethod
    def finish_up(cls) -> None: ...
    @classmethod
    def update(cls) -> None: ...

class Display:
    __CLOCK: Final[pygame.time.Clock]
    __MAX_FPS: int
    __SCALE: int
    __SCREEN_WINDOW: ImageSurface
    __STANDARD_WIDTH: int
    __STANDARD_HEIGHT: int
    __FONT: Final[pygame.font.Font]
    __TICKS: int
    __DELTA_TIME: int
    @classmethod
    def get_current_fps(cls) -> float: ...
    @classmethod
    def get_max_fps(cls) -> int: ...
    @classmethod
    def get_delta_time(cls) -> int: ...
    @classmethod
    def __save_screenshot(cls) -> None: ...
    @classmethod
    def flip(cls) -> None: ...
    @staticmethod
    def set_caption(title: str) -> None: ...
    @staticmethod
    def set_icon(path: str) -> None: ...
    @classmethod
    def get_width(cls) -> int: ...
    @classmethod
    def get_height(cls) -> int: ...
    @classmethod
    def get_size(cls) -> tuple[int, int]: ...
    @classmethod
    def init(cls, flags: int = 0) -> ImageSurface: ...
    @classmethod
    def get_window(cls) -> ImageSurface: ...
    @classmethod
    def blit(cls, surface_to_draw: ImageSurface, pos: Sequence) -> None: ...

class BoolTickTimer:
    __time_to_wait: Incomplete
    __current_time: int
    __status: Incomplete
    __prev_status: Incomplete
    def __init__(self, time_ms: int, default_status: bool = True) -> None: ...
    def tick(self) -> None: ...
    def is_status_changed(self) -> bool: ...
    def get_status(self) -> bool: ...

_OPENCV_INITIALIZED: bool

class Videos:
    @staticmethod
    def validation(_path: str) -> None: ...
    @classmethod
    def get_thumbnail(cls, path: str, size: tuple[int, int] | None = None) -> ImageSurface: ...
    @classmethod
    def split_audio(cls, path: str, audio_format: str = 'ogg', codecs: str = 'libvorbis') -> str: ...

SoundChannel: Incomplete

class Sound(pygame.mixer.Sound):
    __input: Incomplete
    __init: bool
    __volume: float
    def __init__(self, _input: Any) -> None: ...
    def __try_init(self) -> None: ...
    def play(self, loops: int = 0, max_time: int = 0, fade_ms: int = 0) -> SoundChannel | None: ...
    def set_volume(self, value: float) -> None: ...
    def get_volume(self) -> float: ...
    def stop(self) -> None: ...
    def fadeout(self, time: int) -> None: ...

class SoundsManager:
    __channel_id: Incomplete
    __index: int
    __sounds: Incomplete
    def __init__(self, channel_id: int) -> None: ...
    @property
    def channel_id(self) -> int: ...
    def get_channel_id(self) -> int: ...
    def add(self, path: str) -> None: ...
    def clear(self) -> None: ...
    def play(self, sound_id: int = -1) -> None: ...
    def stop(self) -> None: ...
    @property
    def volume(self) -> float: ...
    def get_volume(self) -> float: ...
    def set_volume(self, volume: number) -> None: ...

class Sounds:
    @staticmethod
    def get_init() -> bool: ...
    @staticmethod
    def load(path: str, volume: float | None = None) -> Sound: ...
    @classmethod
    def load_from_video(cls, path: str, volume: float | None = None, cache_key: str | None = None) -> Sound: ...
    @classmethod
    def load_from_directory(cls, folder_path: str) -> tuple[Sound, ...]: ...
    @classmethod
    def play(cls, sound: Sound, channel_id: int) -> None: ...
    @classmethod
    def stop(cls) -> None: ...
    @classmethod
    def get_busy(cls) -> bool: ...
    @classmethod
    def pause(cls) -> None: ...
    @classmethod
    def unpause(cls) -> None: ...
    @classmethod
    def fade_out(cls, time: int) -> None: ...
    @classmethod
    def find_channel(cls, force: bool = False) -> SoundChannel | None: ...
    @staticmethod
    def get_num_channels() -> int: ...
    @classmethod
    def get_channel(cls, channel_id: int) -> SoundChannel: ...

class Music:
    @staticmethod
    def get_init() -> bool: ...
    @staticmethod
    def load(path: str) -> None: ...
    @staticmethod
    def load_from_video(path: str) -> str: ...
    @classmethod
    def unload(cls) -> None: ...
    @classmethod
    def restart(cls) -> None: ...
    @classmethod
    def play(cls, loops: int = 0, start: float = 0.0, fade_ms: int = 0) -> None: ...
    @classmethod
    def pause(cls) -> None: ...
    @classmethod
    def unpause(cls) -> None: ...
    @classmethod
    def stop(cls) -> None: ...
    @classmethod
    def fade_out(cls, time: int) -> None: ...
    @classmethod
    def get_pos(cls) -> int: ...
    @classmethod
    def set_pos(cls, time: float) -> None: ...
    @classmethod
    def get_volume(cls) -> float: ...
    @classmethod
    def set_volume(cls, volume: float) -> None: ...
    @classmethod
    def get_busy(cls) -> bool: ...

class Volume:
    __sound_unit: Final[int]
    @classmethod
    def get_global_value(cls) -> int: ...
    @classmethod
    def get_background_music(cls) -> int: ...
    @classmethod
    def get_effects(cls) -> int: ...
    @classmethod
    def get_environment(cls) -> int: ...

class Media:
    @staticmethod
    def get_busy() -> bool: ...
    @staticmethod
    def pause() -> None: ...
    @staticmethod
    def unpause() -> None: ...
    @staticmethod
    def unload() -> None: ...
    @staticmethod
    def fade_out(time: int) -> None: ...

class LINPG_RESERVED_CHANNELS:
    __MIXER_CHANNEL_NUM: Final[int]
    __BACKGROUND_MUSIC_CHANNEL_ID: Final[int]
    BACKGROUND_MUSIC_CHANNEL: SoundChannel | None
    __SOUND_EFFECTS_CHANNEL_ID: Final[int]
    SOUND_EFFECTS_CHANNEL: SoundChannel | None
    __ENVIRONMENTAL_SOUND_CHANNEL_ID: Final[int]
    ENVIRONMENTAL_SOUND_CHANNEL: SoundChannel | None
    @classmethod
    def init(cls) -> None: ...

class FontGenerator:
    __FONT_IS_NOT_INITIALIZED_MSG: Final[str]
    __FONT: Incomplete
    __size: int
    def __init__(self) -> None: ...
    @property
    def bold(self) -> bool: ...
    @property
    def italic(self) -> bool: ...
    @property
    def size(self) -> int: ...
    def update(self, size: int_f, ifBold: bool = False, ifItalic: bool = False) -> None: ...
    def estimate_text_width(self, text: str | int) -> int: ...
    def estimate_text_height(self, text: str | int) -> int: ...
    def check_for_update(self, _size: int, ifBold: bool = False, ifItalic: bool = False) -> None: ...
    def render(self, txt: str | int, color: color_liked, background_color: color_liked | None = None) -> ImageSurface: ...

class Font:
    __LINPG_GLOBAL_FONTS: Final[dict[str, FontGenerator]]
    __LINPG_LAST_FONT: Final[FontGenerator]
    @classmethod
    def set_global_font(cls, key: str, size: int, ifBold: bool = False, ifItalic: bool = False) -> None: ...
    @classmethod
    def get_global_font(cls, key: str) -> FontGenerator: ...
    @classmethod
    def get_global_font_size(cls, key: str) -> int: ...
    @classmethod
    def render_global_font(cls, key: str, txt: str, color: color_liked, background_color: color_liked | None = None) -> ImageSurface: ...
    @classmethod
    def remove_global_font(cls, key: str) -> None: ...
    @staticmethod
    def create(size: int_f, ifBold: bool = False, ifItalic: bool = False) -> FontGenerator: ...
    @classmethod
    def render(cls, txt: str | int, color: color_liked, size: int_f, ifBold: bool = False, ifItalic: bool = False, background_color: color_liked | None = None) -> ImageSurface: ...

class ArtisticFont:
    @staticmethod
    def render_description_box(txt: str | int, color: color_liked, size: int, padding: int, background_color: color_liked, ifBold: bool = False, ifItalic: bool = False, outline_color: color_liked | None = None, thickness: int = 2) -> ImageSurface: ...
    @staticmethod
    def render_with_outline(_text: str | int, color: color_liked, size: int, outline_thickness: int = 1, outline_color: color_liked = ..., ifBold: bool = False, ifItalic: bool = False) -> ImageSurface: ...

class PersistentVariables(TypeSafeGetter, TypeSafeSetter):
    __DATA: Final[dict[str, Any]]
    __PATH: Final[str]
    @classmethod
    def _get_data(cls) -> dict: ...
    @classmethod
    def set(cls, *_key: str, value: Any, assumeKeyExists: bool = False) -> None: ...
    @classmethod
    def reload(cls) -> None: ...
    @classmethod
    def save(cls) -> None: ...

class Saves:
    @dataclass
    class Progress:
        data: dict
        screenshot: ImageSurface
        createdAt: str
        slotId: int
        def __init__(self, data, screenshot, createdAt, slotId) -> None: ...
    @staticmethod
    def any_progress_exists() -> bool: ...
    @classmethod
    def get_progresses(cls) -> dict[int, Progress]: ...
    @classmethod
    def get_latest_progresses(cls) -> Progress: ...
    @classmethod
    def __save(cls, _path: str, _data: dict, _screenshot: ImageSurface, slotId: int) -> None: ...
    @classmethod
    def save(cls, _data: dict, _screenshot: ImageSurface, slotId: int) -> None: ...
    @classmethod
    def load(cls, _path: str) -> Progress: ...

class Achievements:
    __NAME: Final[str]
    __DATABASE: Final[dict[str, dict[str, bool | int]]]
    @classmethod
    def lock(cls, achievement: str) -> None: ...
    @classmethod
    def unlock(cls, achievement: str) -> None: ...
    @classmethod
    def is_hidden(cls, achievement: str) -> bool: ...
    @classmethod
    def has_achieved(cls, achievement: str) -> bool: ...
    @classmethod
    def get_list(cls) -> list[str]: ...
