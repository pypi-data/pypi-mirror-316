"""
Dynamics module for rby1
"""
from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['Collision', 'CollisionResult', 'Geom', 'GeomCapsule', 'GeomType', 'Joint', 'Link', 'MobileBase', 'MobileBaseDifferential', 'MobileBaseType', 'RobotConfiguration', 'Robot_24', 'State_24', 'load_robot_from_urdf', 'load_robot_from_urdf_data']
M = typing.TypeVar("M", bound=int)
class Collision:
    def __init__(self, arg0: str) -> None:
        ...
    def add_geom(self, geom: Geom) -> None:
        ...
    @typing.overload
    def get_geoms(self) -> list[Geom]:
        ...
    @typing.overload
    def get_geoms(self) -> list[Geom]:
        ...
    def get_origin(self) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]:
        ...
    def set_origin(self, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]) -> None:
        ...
class CollisionResult:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def distance(self) -> float:
        ...
    @property
    def link1(self) -> str:
        ...
    @property
    def link2(self) -> str:
        ...
    @property
    def position1(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def position2(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Geom:
    def __init__(self, arg0: int, arg1: int) -> None:
        ...
    def compute_minimum_distance(self, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]], other_geom: Geom, other_T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]) -> CollisionResult | None:
        ...
    def filter(self, other_geom: Geom) -> bool:
        ...
    def get_colaffinity(self) -> int:
        ...
    def get_coltype(self) -> int:
        ...
    def get_type(self) -> GeomType:
        ...
class GeomCapsule:
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: int, arg3: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], arg1: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], arg2: float, arg3: int, arg4: int) -> None:
        ...
    def get_end_point(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_radius(self) -> float:
        ...
    def get_start_point(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class GeomType:
    """
    Members:
    
      Capsule
    """
    Capsule: typing.ClassVar[GeomType]  # value = <GeomType.Capsule: 0>
    __members__: typing.ClassVar[dict[str, GeomType]]  # value = {'Capsule': <GeomType.Capsule: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Joint:
    @typing.overload
    def __init__(self, name: str, S: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]] = ..., axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]] = ...) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]] = ..., axis: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]] = ...) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
    def connect_links(self, parent_link: Link, child_link: Link, T_pj: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]] = ..., T_jc: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]] = ...) -> None:
        ...
    def disconnect(self) -> None:
        ...
    @typing.overload
    def get_child_link(self) -> Link:
        ...
    @typing.overload
    def get_child_link(self) -> Link:
        ...
    def get_limit_q_lower(self) -> float:
        ...
    def get_limit_q_upper(self) -> float:
        ...
    def get_limit_qddot_lower(self) -> float:
        ...
    def get_limit_qddot_upper(self) -> float:
        ...
    def get_limit_qdot_lower(self) -> float:
        ...
    def get_limit_qdot_upper(self) -> float:
        ...
    def get_name(self) -> str:
        ...
    def get_parent_link(self) -> Link:
        ...
    def is_fixed(self) -> bool:
        ...
    def set_limit_q(self, lower: float, upper: float) -> None:
        ...
    def set_limit_q_lower(self, val: float) -> None:
        ...
    def set_limit_q_upper(self, val: float) -> None:
        ...
    def set_limit_qddot(self, lower: float, upper: float) -> None:
        ...
    def set_limit_qddot_lower(self, val: float) -> None:
        ...
    def set_limit_qddot_upper(self, val: float) -> None:
        ...
    def set_limit_qdot(self, lower: float, upper: float) -> None:
        ...
    def set_limit_qdot_lower(self, val: float) -> None:
        ...
    def set_limit_qdot_upper(self, val: float) -> None:
        ...
class Link:
    def __init__(self, name: str, I: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]] = ...) -> None:
        ...
    def add_collision(self, arg0: Collision) -> None:
        ...
    @typing.overload
    def get_child_joint_list(self) -> list[Joint]:
        ...
    @typing.overload
    def get_child_joint_list(self) -> list[Joint]:
        ...
    @typing.overload
    def get_collisions(self) -> list[Collision]:
        ...
    @typing.overload
    def get_collisions(self) -> list[Collision]:
        ...
    def get_name(self) -> str:
        ...
    def get_parent_joint(self) -> Joint:
        ...
class MobileBase:
    @property
    def T(self) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def joints(self) -> list[str]:
        ...
    @property
    def params(self) -> list[float]:
        ...
    @property
    def type(self) -> MobileBaseType:
        ...
class MobileBaseDifferential(MobileBase):
    @property
    def left_wheel_idx(self) -> int:
        ...
    @property
    def right_wheel_idx(self) -> int:
        ...
    @property
    def wheel_base(self) -> float:
        ...
    @property
    def wheel_radius(self) -> float:
        ...
class MobileBaseType:
    """
    Members:
    
      None
    
      Differential
    
      Omni
    """
    Differential: typing.ClassVar[MobileBaseType]  # value = <MobileBaseType.Differential: 1>
    None: typing.ClassVar[MobileBaseType]  # value = <MobileBaseType.None: 0>
    Omni: typing.ClassVar[MobileBaseType]  # value = <MobileBaseType.Omni: 2>
    __members__: typing.ClassVar[dict[str, MobileBaseType]]  # value = {'None': <MobileBaseType.None: 0>, 'Differential': <MobileBaseType.Differential: 1>, 'Omni': <MobileBaseType.Omni: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RobotConfiguration:
    @property
    def base_link(self) -> Link:
        ...
    @property
    def mobile_base(self) -> MobileBase:
        ...
    @property
    def name(self) -> str:
        ...
class Robot_24:
    @staticmethod
    def count_joints(base_link: Link, include_fixed: bool = False) -> int:
        ...
    def __init__(self, robot_configuration: RobotConfiguration) -> None:
        ...
    def compute_2nd_diff_forward_kinematics(self, state: State_24) -> None:
        ...
    def compute_body_jacobian(self, state: State_24, from: int, to: int) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[24]], numpy.dtype[numpy.float64]]:
        ...
    def compute_body_velocity(self, state: State_24, from: int, to: int) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_center_of_mass(self, state: State_24, ref_link: int, target_link: int) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_center_of_mass(self, state: State_24, ref_link: int, target_links: list[int]) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_center_of_mass(self, state: State_24, ref_link: int) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_center_of_mass_jacobian(self, state: State_24, ref_link: int, target_link: int) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[24]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_center_of_mass_jacobian(self, state: State_24, ref_link: int) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[24]], numpy.dtype[numpy.float64]]:
        ...
    def compute_diff_forward_kinematics(self, state: State_24) -> None:
        ...
    def compute_forward_kinematics(self, state: State_24) -> None:
        ...
    def compute_gravity_term(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def compute_inverse_dynamics(self, state: State_24) -> None:
        ...
    def compute_mass(self, state: State_24, target_link: int) -> float:
        ...
    def compute_mass_matrix(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[24]], numpy.dtype[numpy.float64]]:
        ...
    def compute_mobility_diff_kinematics(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def compute_mobility_inverse_diff_kinematics(self, state: State_24, linear_velocity: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], angular_velocity: float) -> None:
        ...
    @typing.overload
    def compute_mobility_inverse_diff_kinematics(self, state: State_24, body_velocity: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def compute_reflective_inertia(self, state: State_24, from: int, to: int) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]:
        ...
    def compute_space_jacobian(self, state: State_24, from: int, to: int) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[24]], numpy.dtype[numpy.float64]]:
        ...
    def compute_total_inertial(self, state: State_24, ref_link: int) -> numpy.ndarray[tuple[typing.Literal[6], typing.Literal[6]], numpy.dtype[numpy.float64]]:
        ...
    def compute_transformation(self, state: State_24, from: int, to: int) -> numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]:
        ...
    def detect_collisions_or_nearest_links(self, state: State_24, collision_threshold: int = 0) -> list[CollisionResult]:
        ...
    def get_base(self) -> Link:
        ...
    def get_dof(self) -> int:
        ...
    def get_joint_names(self) -> list[str]:
        ...
    def get_joint_property(self, state: State_24, getter: typing.Callable[[Joint], float]) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_q_lower(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_q_upper(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_qddot_lower(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_qddot_upper(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_qdot_lower(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_limit_qdot_upper(self, state: State_24) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @typing.overload
    def get_link(self, name: str) -> Link:
        ...
    @typing.overload
    def get_link(self, state: State_24, index: int) -> Link:
        ...
    def get_link_names(self) -> list[str]:
        ...
    def get_number_of_joints(self) -> int:
        ...
    def make_state(self, link_names: list[str], joint_names: list[str]) -> State_24:
        ...
class State_24:
    def get_base_link_idx(self) -> int:
        ...
    def get_joint_names(self) -> typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(24)]:
        ...
    def get_link_names(self) -> list[str]:
        ...
    def get_q(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_qddot(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_qdot(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def get_tau(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    def set_V0(self, V0: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_Vdot0(self, Vdot0: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_gravity(self, gravity: numpy.ndarray[tuple[typing.Literal[6], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_q(self, q: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_qddot(self, qddot: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_qdot(self, qdot: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
    def set_tau(self, tau: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> None:
        ...
def load_robot_from_urdf(path: str, base_link_name: str) -> RobotConfiguration:
    ...
def load_robot_from_urdf_data(model: str, base_link_name: str) -> RobotConfiguration:
    ...
