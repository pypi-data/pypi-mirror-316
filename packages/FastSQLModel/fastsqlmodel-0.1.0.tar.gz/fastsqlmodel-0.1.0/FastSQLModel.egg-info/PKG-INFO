Metadata-Version: 2.1
Name: FastSQLModel
Version: 0.1.0
Summary: Simplie and Fast utility for SQLModel/SQLAlchemy and Alembic
Home-page: https://github.com/ndendic/FastSQLModel
Author: Nikola Dendic
Author-email: Nikola Dendic <ndendic@gmail.com>
License: Apache Software License 2.0
Keywords: SQLModel SQLAlchemy Alembic nbdev jupyter notebook python
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: License :: OSI Approved :: Apache Software License
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: alembic>=1.14.0
Requires-Dist: setuptools>=75.6.0
Requires-Dist: sqlmodel>=0.0.22
Requires-Dist: typer[all]>=0.15.1
Provides-Extra: dev

# FastSQLModel


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Overview

FastSQLModel is a utility for simplifying the process of using
SQLModel/SQLAlchemy and Alembic. It provides a CLI for initializing and
managing Alembic migrations, and a set of tools for working with
SQLModel and SQLAlchemy models.

## Features

- **CLI for Alembic**: FastSQLModel provides a CLI for initializing and
  managing Alembic migrations.
- **SQLModel and SQLAlchemy Models**: FastSQLModel provides a set of
  tools for working with SQLModel and SQLAlchemy models.
- **Database Management**: FastSQLModel provides a set of tools for
  managing the database, including creating, dropping, and querying the
  database.

## Developer Guide

### Install FastSQLModel in Development

If you want to make changes to the package, you can install it in
development mode. This project uses nbdev for development, so you can
make changes to the code and documentation in the notebooks under the
nbs/ directory. To find out more about amazing nbdev, visit the [nbdev
documentation](https://nbdev.fast.ai/index.html).

To make changes to the package, you can install it in development mode.

``` sh
# make sure FastSQLModel package is installed in development mode
$ pip install -e .

# make changes under nbs/ directory
# ...

# compile to have changes apply to FastSQLModel
$ nbdev_prepare
```

## Usage

### Installation

Install latest from the GitHub
[repository](https://github.com/ndendic/FastSQLModel):

``` sh
$ pip install git+https://github.com/ndendic/FastSQLModel.git
```

or from [conda](https://anaconda.org/ndendic/FastSQLModel)

``` sh
$ conda install -c ndendic FastSQLModel
```

or from [pypi](https://pypi.org/project/FastSQLModel/)

``` sh
$ pip install FastSQLModel
```

To establish a connection to the database, please specify the
`DATABASE_URL` in the `.env` file.

### Documentation

Documentation can be found hosted on this GitHub
[repository](https://github.com/ndendic/FastSQLModel)’s
[pages](https://ndendic.github.io/FastSQLModel/). Additionally you can
find package manager specific guidelines on
[conda](https://anaconda.org/ndendic/FastSQLModel) and
[pypi](https://pypi.org/project/FastSQLModel/) respectively.

## How to use

### Create your first model

To create your first model, you can can import the BaseTable class from
the FastSQLModel.db module and create a new model by subclassing it.
BaseTable is a subclass of SQLModel, so it has all the same features,
but it also has a few extra features to help with some standard db
operations and 3 extra fields: - id: primary key, default to a uuid4 -
created_at: datetime, default to now - updated_at: datetime, default to
now, and updated on every save

``` python
class BaseTable(SQLModel):
    model_config = ConfigDict(json_encoders={datetime: lambda dt: dt.isoformat()})
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    created_at: datetime = Field(
        default_factory=utc_now,
        sa_type= sa.DateTime(timezone=True),
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
        title="Created At",
        schema_extra={"icon": "clock", "input_type": "datetime"},
    )
    updated_at: datetime = Field(
        default_factory=utc_now,
        sa_type=sa.DateTime(timezone=True),
        sa_column_kwargs={
            "server_default": sa.func.now(),
            "server_onupdate": sa.func.now(),
        },
        # onupdate=utc_now,
        nullable=False,
        title="Updated At",
        schema_extra={"icon": "clock", "input_type": "datetime"},
    )
```

Here is an example of how to create a new model using BaseTable

``` python
# users.py
from typing import Optional
from sqlmodel import Field
from datetime import datetime
from FastSQLModel.db import BaseTable

class User(BaseTable, table=True):
    name: Optional[str] = Field(nullable=True)
    email: str = Field(nullable=False)
    password: str = Field(nullable=False)
    joined_at: datetime = Field(nullable=False)
```

Now that you have created your first model, you can use the CLI to
initialize and manage Alembic project.

``` sh
$ fastmodel init
```

This will create a new Alembic project in the current directory, and
create a new .alembic.ini file.

2.  Then make sure to add your models to the migrations/env.py file
    before running migrations.

``` python
# migrations/env.py
from users import User
# ...
```

3.  Now you can run migrations to prepare the database for your models.

``` sh
$ fastmodel migrations
```

4.  And now you can migrate your models to the database.

``` sh
$ fastmodel migrate
```

Let’s see how this works

Initialization:

``` python
!fastmodel init
```

    Successfully initialized Alembic in migrations directory!
    Please make sure to add your models to migrations/env.py file before running 
    migrations!

Making migrations

``` python
!fastmodel migrations
```

    Generating Alembic migration with message: Pushing changes
    DATABASE_URL sqlite:///test.db
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    ERROR [alembic.util.messaging] Can't locate revision identified by '5289002d24df'
      FAILED: Can't locate revision identified by '5289002d24df'
    Error running Alembic: Command '['alembic', 'revision', '--autogenerate', '-m', 
    'Pushing changes']' returned non-zero exit status 255.

Migrating changes

``` python
!fastmodel migrate
```

    Applying database migrations...
    DATABASE_URL sqlite:///test.db
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    ERROR [alembic.util.messaging] Can't locate revision identified by '5289002d24df'
      FAILED: Can't locate revision identified by '5289002d24df'
    Error applying migrations: Command '['alembic', 'upgrade', 'head']' returned 
    non-zero exit status 255.

Once our table is migrated, we can start adding some data like this.

``` python
user = User(name="Homer Simpson", email="homer@simpson.com", password="password", joined_at=datetime.now())
user.save()
user.model_dump()
```

    {'name': 'Homer Simpson',
     'email': 'homer@simpson.com',
     'password': 'password',
     'joined_at': datetime.datetime(2024, 12, 19, 13, 37, 22, 340771),
     'id': UUID('8ae7ed20-8579-47ee-830f-121a0dac4762'),
     'created_at': datetime.datetime(2024, 12, 19, 12, 37, 22, 343167, tzinfo=datetime.timezone.utc),
     'updated_at': datetime.datetime(2024, 12, 19, 12, 37, 22, 343208, tzinfo=datetime.timezone.utc)}

Let’s get our user by id

``` python
homer = User.get(user.id)
if homer:
    print(f"Name: {homer.name}, Email: {homer.email}")
else:
    print("User not found")
```

    Name: Homer Simpson, Email: homer@simpson.com

Or by alternative key value

``` python
homer = User.get("homer@simpson.com",alt_key="email")
if homer:
    print(f"Name: {homer.name}, Email: {homer.email}")
else:
    print("User not found")
```

    Name: Homer Simpson, Email: homer@simpson.com

Now let’s modify our record and save it back to our database and
retreive back

``` python
homer.email = "homer.simpson@simpson.com"
homer.save()
homer = User.get("homer.simpson@simpson.com",alt_key="email")
homer.email
```

    'homer.simpson@simpson.com'

Let’s define a bit more Simprons, this time like this

``` python
bart = User()
bart.name = "Bart Simpson"
bart.email = "bart@simpson.com"
bart.password = "password"
bart.joined_at = datetime.now()
bart.save()

bart.name, bart.email
```

    ('Bart Simpson', 'bart@simpson.com')

Let’s retrive records in our table. We can simply do that by calling
`all` function

``` python
User.all()
```

    [User(created_at=datetime.datetime(2024, 12, 18, 13, 46, 56, 424225), updated_at=datetime.datetime(2024, 12, 18, 13, 46, 56, 424237), id=UUID('420cc98d-9932-459d-b0e6-4a2f78ae8446'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 18, 14, 46, 56, 412409)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 34, 34, 910466), updated_at=datetime.datetime(2024, 12, 19, 12, 34, 34, 910474), id=UUID('a1537834-22b9-4c1b-94a0-4d68f82ae3ed'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 34, 34, 909023)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 35, 10, 261956), updated_at=datetime.datetime(2024, 12, 19, 12, 35, 10, 261966), id=UUID('8699c000-4bc7-47a8-b68a-982aaad8e380'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 35, 10, 260092)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 35, 42, 792670), updated_at=datetime.datetime(2024, 12, 19, 12, 35, 42, 792700), id=UUID('3f686d36-65d5-48fa-b4ef-efa20c552d99'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 35, 42, 790064)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 36, 2, 538502), updated_at=datetime.datetime(2024, 12, 19, 12, 36, 2, 538548), id=UUID('a4ac7f2e-8f9e-4882-b0fd-796419f9862a'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 36, 2, 535652)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 346125), updated_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 417729), id=UUID('8ae7ed20-8579-47ee-830f-121a0dac4762'), name='Homer Simpson', password='password', email='homer.simpson@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 37, 22, 340771)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 453142), updated_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 453152), id=UUID('2f30794b-12bf-4c15-acb8-f673c329db40'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 37, 22, 450919))]

Here we can see that we have forgot to set some `unique` values to our
fields and prevent duplicates. So let’s remove our duplicates manualy
now

First, we can use search to get all the records that contain some
character in some of their string fields. This is usefull for filtering
records where you’re not sure where the value shuld match.

``` python
users = User.search(search_value="Homer")
for user in users:
    print(f"Name: {user.name} , Email: {user.email}, ID: {user.id}")
```

    Name: Homer Simpson , Email: homer.simpson@simpson.com, ID: 8ae7ed20-8579-47ee-830f-121a0dac4762

You can also set the fields you want to retreive from specific fields
using `fields` argument. This will now not return the instance of the
User rable but a list of tuples.

``` python
users = User.search(search_value="Simpson", fields=['name','email'])
users
```

    [('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Homer Simpson', 'homer.simpson@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com')]

Now let’s retreive our records again

``` python
users = User.search(search_value="bart")
users
```

    [User(created_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 453142), updated_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 453152), id=UUID('2f30794b-12bf-4c15-acb8-f673c329db40'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 37, 22, 450919)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 35, 42, 792670), updated_at=datetime.datetime(2024, 12, 19, 12, 35, 42, 792700), id=UUID('3f686d36-65d5-48fa-b4ef-efa20c552d99'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 35, 42, 790064)),
     User(created_at=datetime.datetime(2024, 12, 18, 13, 46, 56, 424225), updated_at=datetime.datetime(2024, 12, 18, 13, 46, 56, 424237), id=UUID('420cc98d-9932-459d-b0e6-4a2f78ae8446'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 18, 14, 46, 56, 412409)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 35, 10, 261956), updated_at=datetime.datetime(2024, 12, 19, 12, 35, 10, 261966), id=UUID('8699c000-4bc7-47a8-b68a-982aaad8e380'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 35, 10, 260092)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 34, 34, 910466), updated_at=datetime.datetime(2024, 12, 19, 12, 34, 34, 910474), id=UUID('a1537834-22b9-4c1b-94a0-4d68f82ae3ed'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 34, 34, 909023)),
     User(created_at=datetime.datetime(2024, 12, 19, 12, 36, 2, 538502), updated_at=datetime.datetime(2024, 12, 19, 12, 36, 2, 538548), id=UUID('a4ac7f2e-8f9e-4882-b0fd-796419f9862a'), name='Bart Simpson', password='password', email='bart@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 36, 2, 535652))]

..and remove the first two results using the `delete` function

``` python
for user in users[:len(users)-1]:
    user.delete()

for user in User.all():
    print(user.name)
```

    Bart Simpson
    Homer Simpson

we also have the option to filter the records using `filter` function
for a specific model field.

``` python
results = User.filter(name="Homer Simpson")
results
```

    [User(created_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 346125), updated_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 417729), id=UUID('8ae7ed20-8579-47ee-830f-121a0dac4762'), name='Homer Simpson', password='password', email='homer.simpson@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 37, 22, 340771))]

``` python
results = User.filter(email="homer.simpson@simpson.com")
results
```

    [User(created_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 346125), updated_at=datetime.datetime(2024, 12, 19, 12, 37, 22, 417729), id=UUID('8ae7ed20-8579-47ee-830f-121a0dac4762'), name='Homer Simpson', password='password', email='homer.simpson@simpson.com', joined_at=datetime.datetime(2024, 12, 19, 13, 37, 22, 340771))]

Similar to `search`, `filter` can take the same argumants, like
`fields`, `sorting_field` and other (for full list navigate to the db
section).

``` python
results = User.filter(name="simp",exact_match=False,fields=["name","email"])
results
```

    [('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Homer Simpson', 'homer.simpson@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com'),
     ('Bart Simpson', 'bart@simpson.com')]

We can also combine field filters.

``` python
results = User.filter(name="simp",email="hom",exact_match=False,fields=["name","email"])
results
```

    [('Homer Simpson', 'homer.simpson@simpson.com')]

For more deatails visit related docs for
[SQLModel](https://sqlmodel.tiangolo.com/) and
[Alembic](https://alembic.sqlalchemy.org/en/latest/)
