# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.

from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar, Literal

from pyavd._schema.models.avd_indexed_list import AvdIndexedList
from pyavd._schema.models.avd_list import AvdList
from pyavd._schema.models.avd_model import AvdModel
from pyavd._schema.models.eos_cli_config_gen_root_model import EosCliConfigGenRootModel

if TYPE_CHECKING:
    from pyavd._utils import Undefined, UndefinedType


class EosCliConfigGen(EosCliConfigGenRootModel):
    """Subclass of AvdModel."""

    class AaaAccounting(AvdModel):
        """Subclass of AvdModel."""

        class Exec(AvdModel):
            """Subclass of AvdModel."""

            class Console(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}, "_custom_data": {"type": dict}}
                type: Literal["none", "start-stop", "stop-only"]
                group: str | None
                """Group Name."""
                logging: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Console.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            logging: logging
                            _custom_data: _custom_data

                        """

            class Default(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}, "_custom_data": {"type": dict}}
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            logging: logging
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"console": {"type": Console}, "default": {"type": Default}, "_custom_data": {"type": dict}}
            console: Console
            """Subclass of AvdModel."""
            default: Default
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    console: Console | UndefinedType = Undefined,
                    default: Default | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Exec.


                    Subclass of AvdModel.

                    Args:
                        console: Subclass of AvdModel.
                        default: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class System(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "_custom_data": {"type": dict}}
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"default": {"type": Default}, "_custom_data": {"type": dict}}
            default: Default
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: Default | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    System.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "group": {"type": str}, "_custom_data": {"type": dict}}
                type: Literal["start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            group: Group Name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"default": {"type": Default}, "_custom_data": {"type": dict}}
            default: Default
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: Default | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Commands(AvdModel):
            """Subclass of AvdModel."""

            class ConsoleItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                commands: str | None
                """Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another."""
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        commands: str | None | UndefinedType = Undefined,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConsoleItem.


                        Subclass of AvdModel.

                        Args:
                            commands: Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another.
                            type: type
                            group: Group Name.
                            logging: logging
                            _custom_data: _custom_data

                        """

            class Console(AvdList[ConsoleItem]):
                """Subclass of AvdList with `ConsoleItem` items."""

            Console._item_type = ConsoleItem

            class DefaultItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                commands: str | None
                """Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another."""
                type: Literal["none", "start-stop", "stop-only"] | None
                group: str | None
                """Group Name."""
                logging: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        commands: str | None | UndefinedType = Undefined,
                        type: Literal["none", "start-stop", "stop-only"] | None | UndefinedType = Undefined,
                        group: str | None | UndefinedType = Undefined,
                        logging: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultItem.


                        Subclass of AvdModel.

                        Args:
                            commands: Privilege level 'all' or 0-15. Ensure that if ranges are used, they do not overlap with one another.
                            type: type
                            group: Group Name.
                            logging: logging
                            _custom_data: _custom_data

                        """

            class Default(AvdList[DefaultItem]):
                """Subclass of AvdList with `DefaultItem` items."""

            Default._item_type = DefaultItem

            _fields: ClassVar[dict] = {"console": {"type": Console}, "default": {"type": Default}, "_custom_data": {"type": dict}}
            console: Console
            """Subclass of AvdList with `ConsoleItem` items."""
            default: Default
            """Subclass of AvdList with `DefaultItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    console: Console | UndefinedType = Undefined,
                    default: Default | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Commands.


                    Subclass of AvdModel.

                    Args:
                        console: Subclass of AvdList with `ConsoleItem` items.
                        default: Subclass of AvdList with `DefaultItem` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "exec": {"type": Exec},
            "system": {"type": System},
            "dot1x": {"type": Dot1x},
            "commands": {"type": Commands},
            "_custom_data": {"type": dict},
        }
        exec: Exec
        """Subclass of AvdModel."""
        system: System
        """Subclass of AvdModel."""
        dot1x: Dot1x
        """Subclass of AvdModel."""
        commands: Commands
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                exec: Exec | UndefinedType = Undefined,
                system: System | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                commands: Commands | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAccounting.


                Subclass of AvdModel.

                Args:
                    exec: Subclass of AvdModel.
                    system: Subclass of AvdModel.
                    dot1x: Subclass of AvdModel.
                    commands: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class AaaAuthentication(AvdModel):
        """Subclass of AvdModel."""

        class Login(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}, "console": {"type": str}, "_custom_data": {"type": dict}}
            default: str | None
            """
            Login authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            - "group radius group MYGROUP local"
            """
            console: str | None
            """
            Console authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    default: str | None | UndefinedType = Undefined,
                    console: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Login.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Login authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP none"
                           - "group radius group MYGROUP local"
                        console:
                           Console authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group radius group MYGROUP local"
                        _custom_data: _custom_data

                    """

        class Enable(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}, "_custom_data": {"type": dict}}
            default: str | None
            """
            Enable authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Enable.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Enable authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group radius group MYGROUP local"
                        _custom_data: _custom_data

                    """

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}, "_custom_data": {"type": dict}}
            default: str | None
            """
            802.1x authentication method(s) as a string.
            Examples:
            - "group radius"
            - "group MYGROUP group
            radius"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        default:
                           802.1x authentication method(s) as a string.
                           Examples:  # fmt: skip
                           - "group radius"
                           - "group MYGROUP group
                           radius"
                        _custom_data: _custom_data

                    """

        class Policies(AvdModel):
            """Subclass of AvdModel."""

            class Local(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"allow_nopassword": {"type": bool}, "_custom_data": {"type": dict}}
                allow_nopassword: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, allow_nopassword: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Local.


                        Subclass of AvdModel.

                        Args:
                            allow_nopassword: allow_nopassword
                            _custom_data: _custom_data

                        """

            class Lockout(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"failure": {"type": int}, "duration": {"type": int}, "window": {"type": int}, "_custom_data": {"type": dict}}
                failure: int | None
                duration: int | None
                window: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        failure: int | None | UndefinedType = Undefined,
                        duration: int | None | UndefinedType = Undefined,
                        window: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lockout.


                        Subclass of AvdModel.

                        Args:
                            failure: failure
                            duration: duration
                            window: window
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "on_failure_log": {"type": bool},
                "on_success_log": {"type": bool},
                "local": {"type": Local},
                "lockout": {"type": Lockout},
                "_custom_data": {"type": dict},
            }
            on_failure_log: bool | None
            on_success_log: bool | None
            local: Local
            """Subclass of AvdModel."""
            lockout: Lockout
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    on_failure_log: bool | None | UndefinedType = Undefined,
                    on_success_log: bool | None | UndefinedType = Undefined,
                    local: Local | UndefinedType = Undefined,
                    lockout: Lockout | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Policies.


                    Subclass of AvdModel.

                    Args:
                        on_failure_log: on_failure_log
                        on_success_log: on_success_log
                        local: Subclass of AvdModel.
                        lockout: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "login": {"type": Login},
            "enable": {"type": Enable},
            "dot1x": {"type": Dot1x},
            "policies": {"type": Policies},
            "_custom_data": {"type": dict},
        }
        login: Login
        """Subclass of AvdModel."""
        enable: Enable
        """Subclass of AvdModel."""
        dot1x: Dot1x
        """Subclass of AvdModel."""
        policies: Policies
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                login: Login | UndefinedType = Undefined,
                enable: Enable | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAuthentication.


                Subclass of AvdModel.

                Args:
                    login: Subclass of AvdModel.
                    enable: Subclass of AvdModel.
                    dot1x: Subclass of AvdModel.
                    policies: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class AaaAuthorization(AvdModel):
        """Subclass of AvdModel."""

        class Policy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"local_default_role": {"type": str}, "_custom_data": {"type": dict}}
            local_default_role: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, local_default_role: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Policy.


                    Subclass of AvdModel.

                    Args:
                        local_default_role: local_default_role
                        _custom_data: _custom_data

                    """

        class Exec(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": str}, "_custom_data": {"type": dict}}
            default: str | None
            """
            Exec authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            -
            "group radius group MYGROUP local"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Exec.


                    Subclass of AvdModel.

                    Args:
                        default:
                           Exec authorization method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP none"
                           -
                           "group radius group MYGROUP local"
                        _custom_data: _custom_data

                    """

        class Dynamic(AvdModel):
            """Subclass of AvdModel."""

            class Dot1xAdditionalGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Dot1xAdditionalGroups._item_type = str

            _fields: ClassVar[dict] = {"dot1x_additional_groups": {"type": Dot1xAdditionalGroups}, "_custom_data": {"type": dict}}
            dot1x_additional_groups: Dot1xAdditionalGroups
            """Subclass of AvdList with `str` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    dot1x_additional_groups: Dot1xAdditionalGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dynamic.


                    Subclass of AvdModel.

                    Args:
                        dot1x_additional_groups: Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class Commands(AvdModel):
            """Subclass of AvdModel."""

            class PrivilegeItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "default": {"type": str}, "_custom_data": {"type": dict}}
                level: str | None
                """Privilege level(s) 0-15."""
                default: str | None
                """
                Command authorization method(s) as a string.
                Examples:
                - "group tacacs+ local"
                - "group MYGROUP
                none"
                - "group tacacs+ group MYGROUP local"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        default: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PrivilegeItem.


                        Subclass of AvdModel.

                        Args:
                            level: Privilege level(s) 0-15.
                            default:
                               Command authorization method(s) as a string.
                               Examples:  # fmt: skip
                               - "group tacacs+ local"
                               - "group MYGROUP
                               none"
                               - "group tacacs+ group MYGROUP local"
                            _custom_data: _custom_data

                        """

            class Privilege(AvdList[PrivilegeItem]):
                """Subclass of AvdList with `PrivilegeItem` items."""

            Privilege._item_type = PrivilegeItem

            _fields: ClassVar[dict] = {"all_default": {"type": str}, "privilege": {"type": Privilege}, "_custom_data": {"type": dict}}
            all_default: str | None
            """
            Command authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group tacacs+ group MYGROUP local
            """
            privilege: Privilege
            """Subclass of AvdList with `PrivilegeItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    all_default: str | None | UndefinedType = Undefined,
                    privilege: Privilege | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Commands.


                    Subclass of AvdModel.

                    Args:
                        all_default:
                           Command authorization method(s) as a string.
                           Examples:  # fmt: skip
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group tacacs+ group MYGROUP local
                        privilege: Subclass of AvdList with `PrivilegeItem` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "policy": {"type": Policy},
            "exec": {"type": Exec},
            "config_commands": {"type": bool},
            "serial_console": {"type": bool},
            "dynamic": {"type": Dynamic},
            "commands": {"type": Commands},
            "_custom_data": {"type": dict},
        }
        policy: Policy
        """Subclass of AvdModel."""
        exec: Exec
        """Subclass of AvdModel."""
        config_commands: bool | None
        serial_console: bool | None
        dynamic: Dynamic
        """Subclass of AvdModel."""
        commands: Commands
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                policy: Policy | UndefinedType = Undefined,
                exec: Exec | UndefinedType = Undefined,
                config_commands: bool | None | UndefinedType = Undefined,
                serial_console: bool | None | UndefinedType = Undefined,
                dynamic: Dynamic | UndefinedType = Undefined,
                commands: Commands | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AaaAuthorization.


                Subclass of AvdModel.

                Args:
                    policy: Subclass of AvdModel.
                    exec: Subclass of AvdModel.
                    config_commands: config_commands
                    serial_console: serial_console
                    dynamic: Subclass of AvdModel.
                    commands: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class AaaRoot(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sha512_password": {"type": str}, "_custom_data": {"type": dict}}
            sha512_password: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, sha512_password: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        sha512_password: sha512_password
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"disabled": {"type": bool}, "secret": {"type": Secret}, "_custom_data": {"type": dict}}
        disabled: bool | None
        """Set to `true` to configure `no aaa root` which is the EOS default."""
        secret: Secret
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | None | UndefinedType = Undefined,
                secret: Secret | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AaaRoot.


                Subclass of AvdModel.

                Args:
                    disabled: Set to `true` to configure `no aaa root` which is the EOS default.
                    secret: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class AaaServerGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class ServersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"server": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            server: str | None
            """Hostname or IP address."""
            vrf: str | None
            """VRF name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    server: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServersItem.


                    Subclass of AvdModel.

                    Args:
                        server: Hostname or IP address.
                        vrf: VRF name.
                        _custom_data: _custom_data

                    """

        class Servers(AvdList[ServersItem]):
            """Subclass of AvdList with `ServersItem` items."""

        Servers._item_type = ServersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "type": {"type": str}, "servers": {"type": Servers}, "_custom_data": {"type": dict}}
        name: str
        """Group name."""
        type: Literal["tacacs+", "radius", "ldap"] | None
        servers: Servers
        """Subclass of AvdList with `ServersItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                type: Literal["tacacs+", "radius", "ldap"] | None | UndefinedType = Undefined,
                servers: Servers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AaaServerGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Group name.
                    type: type
                    servers: Subclass of AvdList with `ServersItem` items.
                    _custom_data: _custom_data

                """

    class AaaServerGroups(AvdIndexedList[str, AaaServerGroupsItem]):
        """Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    AaaServerGroups._item_type = AaaServerGroupsItem

    class AccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ip any any"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "permit_response_traffic": {"type": str},
            "sequence_numbers": {"type": SequenceNumbers},
            "_custom_data": {"type": dict},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        permit_response_traffic: Literal["nat"] | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                permit_response_traffic: Literal["nat"] | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    permit_response_traffic:
                       Permit response traffic automatically based on NAT translations.
                       Minimum EOS version requirement
                       4.32.2F.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class AccessLists(AvdIndexedList[str, AccessListsItem]):
        """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    AccessLists._item_type = AccessListsItem

    class AddressLocking(AvdModel):
        """Subclass of AvdModel."""

        class DhcpServersIpv4(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DhcpServersIpv4._item_type = str

        class LeasesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip": {"type": str}, "mac": {"type": str}, "_custom_data": {"type": dict}}
            ip: str
            """IP address."""
            mac: str
            """MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, ip: str | UndefinedType = Undefined, mac: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    LeasesItem.


                    Subclass of AvdModel.

                    Args:
                        ip: IP address.
                        mac: MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh).
                        _custom_data: _custom_data

                    """

        class Leases(AvdList[LeasesItem]):
            """Subclass of AvdList with `LeasesItem` items."""

        Leases._item_type = LeasesItem

        class LockedAddress(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "expiration_mac_disabled": {"type": bool},
                "ipv4_enforcement_disabled": {"type": bool},
                "ipv6_enforcement_disabled": {"type": bool},
                "_custom_data": {"type": dict},
            }
            expiration_mac_disabled: bool | None
            """Configure deauthorizing locked addresses upon MAC aging out."""
            ipv4_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv4 addresses."""
            ipv6_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv6 addresses."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    expiration_mac_disabled: bool | None | UndefinedType = Undefined,
                    ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                    ipv6_enforcement_disabled: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LockedAddress.


                    Subclass of AvdModel.

                    Args:
                        expiration_mac_disabled: Configure deauthorizing locked addresses upon MAC aging out.
                        ipv4_enforcement_disabled: Configure enforcement for locked IPv4 addresses.
                        ipv6_enforcement_disabled: Configure enforcement for locked IPv6 addresses.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "dhcp_servers_ipv4": {"type": DhcpServersIpv4},
            "disabled": {"type": bool},
            "leases": {"type": Leases},
            "local_interface": {"type": str},
            "locked_address": {"type": LockedAddress},
            "_custom_data": {"type": dict},
        }
        dhcp_servers_ipv4: DhcpServersIpv4
        """Subclass of AvdList with `str` items."""
        disabled: bool | None
        """Disable IP locking on configured ports."""
        leases: Leases
        """Subclass of AvdList with `LeasesItem` items."""
        local_interface: str | None
        locked_address: LockedAddress
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                dhcp_servers_ipv4: DhcpServersIpv4 | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                leases: Leases | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                locked_address: LockedAddress | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AddressLocking.


                Subclass of AvdModel.

                Args:
                    dhcp_servers_ipv4: Subclass of AvdList with `str` items.
                    disabled: Disable IP locking on configured ports.
                    leases: Subclass of AvdList with `LeasesItem` items.
                    local_interface: local_interface
                    locked_address: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class AgentsItem(AvdModel):
        """Subclass of AvdModel."""

        class EnvironmentVariablesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Environment variable name."""
            value: str
            """Environment variable value."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    value: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EnvironmentVariablesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Environment variable name.
                        value: Environment variable value.
                        _custom_data: _custom_data

                    """

        class EnvironmentVariables(AvdIndexedList[str, EnvironmentVariablesItem]):
            """Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        EnvironmentVariables._item_type = EnvironmentVariablesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "environment_variables": {"type": EnvironmentVariables}, "_custom_data": {"type": dict}}
        name: str
        """Agent name."""
        environment_variables: EnvironmentVariables
        """Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                environment_variables: EnvironmentVariables | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AgentsItem.


                Subclass of AvdModel.

                Args:
                    name: Agent name.
                    environment_variables: Subclass of AvdIndexedList with `EnvironmentVariablesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Agents(AvdIndexedList[str, AgentsItem]):
        """Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Agents._item_type = AgentsItem

    class ApplicationTrafficRecognition(AvdModel):
        """Subclass of AvdModel."""

        class CategoriesItem(AvdModel):
            """Subclass of AvdModel."""

            class ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                """Application name."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.
                            _custom_data: _custom_data

                        """

            class Applications(AvdList[ApplicationsItem]):
                """Subclass of AvdList with `ApplicationsItem` items."""

            Applications._item_type = ApplicationsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "applications": {"type": Applications}, "_custom_data": {"type": dict}}
            name: str
            """Category name."""
            applications: Applications
            """
            List of applications.

            Subclass of AvdList with `ApplicationsItem` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    applications: Applications | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CategoriesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Category name.
                        applications:
                           List of applications.

                           Subclass of AvdList with `ApplicationsItem` items.
                        _custom_data: _custom_data

                    """

        class Categories(AvdIndexedList[str, CategoriesItem]):
            """Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Categories._item_type = CategoriesItem

        class FieldSets(AvdModel):
            """Subclass of AvdModel."""

            class L4PortsItem(AvdModel):
                """Subclass of AvdModel."""

                class PortValues(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                PortValues._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "port_values": {"type": PortValues}, "_custom_data": {"type": dict}}
                name: str
                """L4 port field-set name."""
                port_values: PortValues
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        port_values: PortValues | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        L4PortsItem.


                        Subclass of AvdModel.

                        Args:
                            name: L4 port field-set name.
                            port_values: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class L4Ports(AvdIndexedList[str, L4PortsItem]):
                """Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            L4Ports._item_type = L4PortsItem

            class Ipv4PrefixesItem(AvdModel):
                """Subclass of AvdModel."""

                class PrefixValues(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                PrefixValues._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefix_values": {"type": PrefixValues}, "_custom_data": {"type": dict}}
                name: str
                """IPv4 prefix field-set name."""
                prefix_values: PrefixValues
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        prefix_values: PrefixValues | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4PrefixesItem.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 prefix field-set name.
                            prefix_values: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class Ipv4Prefixes(AvdIndexedList[str, Ipv4PrefixesItem]):
                """Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4Prefixes._item_type = Ipv4PrefixesItem

            _fields: ClassVar[dict] = {"l4_ports": {"type": L4Ports}, "ipv4_prefixes": {"type": Ipv4Prefixes}, "_custom_data": {"type": dict}}
            l4_ports: L4Ports
            """
            L4 port field-set.

            Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name`
            (`str`).
            """
            ipv4_prefixes: Ipv4Prefixes
            """
            IPv4 prefix field set.

            Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is
            `name` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    l4_ports: L4Ports | UndefinedType = Undefined,
                    ipv4_prefixes: Ipv4Prefixes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FieldSets.


                    Subclass of AvdModel.

                    Args:
                        l4_ports:
                           L4 port field-set.

                           Subclass of AvdIndexedList with `L4PortsItem` items. Primary key is `name`
                           (`str`).
                        ipv4_prefixes:
                           IPv4 prefix field set.

                           Subclass of AvdIndexedList with `Ipv4PrefixesItem` items. Primary key is
                           `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Applications(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                class DscpRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                DscpRanges._item_type = str

                class Protocols(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Protocols._item_type = str

                class ProtocolRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ProtocolRanges._item_type = str

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "src_prefix_set_name": {"type": str},
                    "dest_prefix_set_name": {"type": str},
                    "dscp_ranges": {"type": DscpRanges},
                    "protocols": {"type": Protocols},
                    "protocol_ranges": {"type": ProtocolRanges},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Application name."""
                src_prefix_set_name: str | None
                """Source prefix set name."""
                dest_prefix_set_name: str | None
                """Destination prefix set name."""
                dscp_ranges: DscpRanges
                """
                Accept DSCP value(s) or range(s).
                DSCP values can be between 0 and 63.
                Other valid values are cs0 to
                cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                Note: The values are not sorted so the list items
                need to be supplied in the right order to match the CLI if required.

                Subclass of AvdList with `str`
                items.
                """
                protocols: Protocols
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.

                Subclass of
                AvdList with `str` items.
                """
                protocol_ranges: ProtocolRanges
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.

                Subclass of AvdList
                with `str` items.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        src_prefix_set_name: str | None | UndefinedType = Undefined,
                        dest_prefix_set_name: str | None | UndefinedType = Undefined,
                        dscp_ranges: DscpRanges | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        protocol_ranges: ProtocolRanges | UndefinedType = Undefined,
                        udp_src_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                        udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            src_prefix_set_name: Source prefix set name.
                            dest_prefix_set_name: Destination prefix set name.
                            dscp_ranges:
                               Accept DSCP value(s) or range(s).
                               DSCP values can be between 0 and 63.
                               Other valid values are cs0 to
                               cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                               Note: The values are not sorted so the list items
                               need to be supplied in the right order to match the CLI if required.

                               Subclass of AvdList with `str`
                               items.
                            protocols:
                               List of protocols to consider for this application.
                               To use port field-sets (source, destination or
                               both), the list
                               must contain only one or two protocols, either `tcp` or `udp`.
                               When using both
                               protocols, one line is rendered for each in the configuration,
                               hence the field-sets must have the
                               same value for `tcp_src_port_set_name` and
                               `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                               and `udp_dest_port_set_name`
                               if set in order to generate valid configuration in EOS.

                               Subclass of
                               AvdList with `str` items.
                            protocol_ranges:
                               Accept protocol value(s) or range(s).
                               Protocol values can be between 1 and 255.

                               Subclass of AvdList
                               with `str` items.
                            udp_src_port_set_name:
                               Name of field set for UDP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `tcp_src_port_set_name`.
                            tcp_src_port_set_name:
                               Name of field set for TCP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `udp_src_port_set_name`.
                            udp_dest_port_set_name:
                               Name of field set for UDP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `tcp_dest_port_set_name`.
                            tcp_dest_port_set_name:
                               Name of field set for TCP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `udp_dest_port_set_name`.
                            _custom_data: _custom_data

                        """

            class Ipv4Applications(AvdIndexedList[str, Ipv4ApplicationsItem]):
                """Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4Applications._item_type = Ipv4ApplicationsItem

            class L4ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                class Protocols(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Protocols._item_type = str

                class ProtocolRanges(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ProtocolRanges._item_type = str

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "protocols": {"type": Protocols},
                    "protocol_ranges": {"type": ProtocolRanges},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Application name."""
                protocols: Protocols
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.

                Subclass of
                AvdList with `str` items.
                """
                protocol_ranges: ProtocolRanges
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.

                Subclass of AvdList
                with `str` items.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        protocol_ranges: ProtocolRanges | UndefinedType = Undefined,
                        udp_src_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                        udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        L4ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application name.
                            protocols:
                               List of protocols to consider for this application.
                               To use port field-sets (source, destination or
                               both), the list
                               must contain only one or two protocols, either `tcp` or `udp`.
                               When using both
                               protocols, one line is rendered for each in the configuration,
                               hence the field-sets must have the
                               same value for `tcp_src_port_set_name` and
                               `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                               and `udp_dest_port_set_name`
                               if set in order to generate valid configuration in EOS.

                               Subclass of
                               AvdList with `str` items.
                            protocol_ranges:
                               Accept protocol value(s) or range(s).
                               Protocol values can be between 1 and 255.

                               Subclass of AvdList
                               with `str` items.
                            udp_src_port_set_name:
                               Name of field set for UDP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `tcp_src_port_set_name`.
                            tcp_src_port_set_name:
                               Name of field set for TCP source ports.
                               When the `protocols` list contain both `tcp` and `udp`, this
                               key value
                               must be the same as `udp_src_port_set_name`.
                            udp_dest_port_set_name:
                               Name of field set for UDP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `tcp_dest_port_set_name`.
                            tcp_dest_port_set_name:
                               Name of field set for TCP destination ports.
                               When the `protocols` list contain both `tcp` and `udp`,
                               this key value
                               must be the same as `udp_dest_port_set_name`.
                            _custom_data: _custom_data

                        """

            class L4Applications(AvdIndexedList[str, L4ApplicationsItem]):
                """Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            L4Applications._item_type = L4ApplicationsItem

            _fields: ClassVar[dict] = {
                "ipv4_applications": {"type": Ipv4Applications},
                "l4_applications": {"type": L4Applications},
                "_custom_data": {"type": dict},
            }
            ipv4_applications: Ipv4Applications
            """
            List of user defined IPv4 applications. The name should be unique over all defined applications
            (ipv4 and l4).

            Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name`
            (`str`).
            """
            l4_applications: L4Applications
            """
            List of user defined L4 applications. The name should be unique over all defined applications (ipv4
            and l4).

            Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_applications: Ipv4Applications | UndefinedType = Undefined,
                    l4_applications: L4Applications | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Applications.


                    Subclass of AvdModel.

                    Args:
                        ipv4_applications:
                           List of user defined IPv4 applications. The name should be unique over all defined applications
                           (ipv4 and l4).

                           Subclass of AvdIndexedList with `Ipv4ApplicationsItem` items. Primary key is `name`
                           (`str`).
                        l4_applications:
                           List of user defined L4 applications. The name should be unique over all defined applications (ipv4
                           and l4).

                           Subclass of AvdIndexedList with `L4ApplicationsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class ApplicationProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ApplicationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                """Application Name."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ApplicationsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Application Name.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.
                            _custom_data: _custom_data

                        """

            class Applications(AvdList[ApplicationsItem]):
                """Subclass of AvdList with `ApplicationsItem` items."""

            Applications._item_type = ApplicationsItem

            class ApplicationTransports(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            ApplicationTransports._item_type = str

            class CategoriesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "service": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                """Name of a category."""
                service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"] | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        service: Literal["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        CategoriesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Name of a category.
                            service:
                               Service Name.
                               Specific service to target for this application.
                               If no service is specified, all
                               supported services of the application are matched.
                               Not all valid values are valid for all
                               applications, check on EOS CLI.
                            _custom_data: _custom_data

                        """

            class Categories(AvdList[CategoriesItem]):
                """Subclass of AvdList with `CategoriesItem` items."""

            Categories._item_type = CategoriesItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "applications": {"type": Applications},
                "application_transports": {"type": ApplicationTransports},
                "categories": {"type": Categories},
                "_custom_data": {"type": dict},
            }
            name: str
            """Application Profile name."""
            applications: Applications
            """
            List of applications part of the application profile.

            Subclass of AvdList with `ApplicationsItem`
            items.
            """
            application_transports: ApplicationTransports
            """
            List of transport protocols.

            Subclass of AvdList with `str` items.
            """
            categories: Categories
            """
            Categories under this application profile.

            Subclass of AvdList with `CategoriesItem` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    applications: Applications | UndefinedType = Undefined,
                    application_transports: ApplicationTransports | UndefinedType = Undefined,
                    categories: Categories | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ApplicationProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Application Profile name.
                        applications:
                           List of applications part of the application profile.

                           Subclass of AvdList with `ApplicationsItem`
                           items.
                        application_transports:
                           List of transport protocols.

                           Subclass of AvdList with `str` items.
                        categories:
                           Categories under this application profile.

                           Subclass of AvdList with `CategoriesItem` items.
                        _custom_data: _custom_data

                    """

        class ApplicationProfiles(AvdIndexedList[str, ApplicationProfilesItem]):
            """Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ApplicationProfiles._item_type = ApplicationProfilesItem

        _fields: ClassVar[dict] = {
            "categories": {"type": Categories},
            "field_sets": {"type": FieldSets},
            "applications": {"type": Applications},
            "application_profiles": {"type": ApplicationProfiles},
            "_custom_data": {"type": dict},
        }
        categories: Categories
        """
        List of categories.

        Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name`
        (`str`).
        """
        field_sets: FieldSets
        """Subclass of AvdModel."""
        applications: Applications
        """Subclass of AvdModel."""
        application_profiles: ApplicationProfiles
        """
        Group of applications.

        Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key
        is `name` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                categories: Categories | UndefinedType = Undefined,
                field_sets: FieldSets | UndefinedType = Undefined,
                applications: Applications | UndefinedType = Undefined,
                application_profiles: ApplicationProfiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ApplicationTrafficRecognition.


                Subclass of AvdModel.

                Args:
                    categories:
                       List of categories.

                       Subclass of AvdIndexedList with `CategoriesItem` items. Primary key is `name`
                       (`str`).
                    field_sets: Subclass of AvdModel.
                    applications: Subclass of AvdModel.
                    application_profiles:
                       Group of applications.

                       Subclass of AvdIndexedList with `ApplicationProfilesItem` items. Primary key
                       is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Arp(AvdModel):
        """Subclass of AvdModel."""

        class Persistent(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "refresh_delay": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool
            """Restore the ARP cache after reboot."""
            refresh_delay: int | None
            """Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    refresh_delay: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Persistent.


                    Subclass of AvdModel.

                    Args:
                        enabled: Restore the ARP cache after reboot.
                        refresh_delay: Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600).
                        _custom_data: _custom_data

                    """

        class Aging(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"timeout_default": {"type": int}, "_custom_data": {"type": dict}}
            timeout_default: int | None
            """Timeout in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, timeout_default: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Aging.


                    Subclass of AvdModel.

                    Args:
                        timeout_default: Timeout in seconds.
                        _custom_data: _custom_data

                    """

        class StaticEntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_address": {"type": str}, "vrf": {"type": str}, "mac_address": {"type": str}, "_custom_data": {"type": dict}}
            ipv4_address: str
            """ARP entry IPv4 address."""
            vrf: str | None
            """ARP entry VRF."""
            mac_address: str
            """ARP entry MAC address."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    mac_address: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticEntriesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv4_address: ARP entry IPv4 address.
                        vrf: ARP entry VRF.
                        mac_address: ARP entry MAC address.
                        _custom_data: _custom_data

                    """

        class StaticEntries(AvdList[StaticEntriesItem]):
            """Subclass of AvdList with `StaticEntriesItem` items."""

        StaticEntries._item_type = StaticEntriesItem

        _fields: ClassVar[dict] = {
            "persistent": {"type": Persistent},
            "aging": {"type": Aging},
            "static_entries": {"type": StaticEntries},
            "_custom_data": {"type": dict},
        }
        persistent: Persistent
        """Subclass of AvdModel."""
        aging: Aging
        """Subclass of AvdModel."""
        static_entries: StaticEntries
        """
        Static ARP entries.

        Subclass of AvdList with `StaticEntriesItem` items.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                persistent: Persistent | UndefinedType = Undefined,
                aging: Aging | UndefinedType = Undefined,
                static_entries: StaticEntries | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Arp.


                Subclass of AvdModel.

                Args:
                    persistent: Subclass of AvdModel.
                    aging: Subclass of AvdModel.
                    static_entries:
                       Static ARP entries.

                       Subclass of AvdList with `StaticEntriesItem` items.
                    _custom_data: _custom_data

                """

    class AsPath(AvdModel):
        """Subclass of AvdModel."""

        class AccessListsItem(AvdModel):
            """Subclass of AvdModel."""

            class EntriesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "type": {"type": str},
                    "match": {"type": str},
                    "origin": {"type": str, "default": "any"},
                    "_custom_data": {"type": dict},
                }
                type: Literal["permit", "deny"] | None
                match: str | None
                """Regex To Match."""
                origin: Literal["any", "egp", "igp", "incomplete"]
                """Default value: `"any"`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                        match: str | None | UndefinedType = Undefined,
                        origin: Literal["any", "egp", "igp", "incomplete"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EntriesItem.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            match: Regex To Match.
                            origin: origin
                            _custom_data: _custom_data

                        """

            class Entries(AvdList[EntriesItem]):
                """Subclass of AvdList with `EntriesItem` items."""

            Entries._item_type = EntriesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}, "_custom_data": {"type": dict}}
            name: str
            """Access List Name."""
            entries: Entries
            """Subclass of AvdList with `EntriesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    entries: Entries | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessListsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Access List Name.
                        entries: Subclass of AvdList with `EntriesItem` items.
                        _custom_data: _custom_data

                    """

        class AccessLists(AvdIndexedList[str, AccessListsItem]):
            """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        AccessLists._item_type = AccessListsItem

        _fields: ClassVar[dict] = {"regex_mode": {"type": str}, "access_lists": {"type": AccessLists}, "_custom_data": {"type": dict}}
        regex_mode: Literal["asn", "string"] | None
        access_lists: AccessLists
        """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                regex_mode: Literal["asn", "string"] | None | UndefinedType = Undefined,
                access_lists: AccessLists | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                AsPath.


                Subclass of AvdModel.

                Args:
                    regex_mode: regex_mode
                    access_lists: Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Banners(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"login": {"type": str}, "motd": {"type": str}, "_custom_data": {"type": dict}}
        login: str | None
        """Multiline string ending with EOF on the last line."""
        motd: str | None
        """Multiline string ending with EOF on the last line."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                login: str | None | UndefinedType = Undefined,
                motd: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Banners.


                Subclass of AvdModel.

                Args:
                    login: Multiline string ending with EOF on the last line.
                    motd: Multiline string ending with EOF on the last line.
                    _custom_data: _custom_data

                """

    class BgpGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class Neighbors(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Neighbors._item_type = str

        class BgpMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpMaintenanceProfiles._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "vrf": {"type": str},
            "neighbors": {"type": Neighbors},
            "bgp_maintenance_profiles": {"type": BgpMaintenanceProfiles},
            "_custom_data": {"type": dict},
        }
        name: str
        """Group Name."""
        vrf: str | None
        neighbors: Neighbors
        """Subclass of AvdList with `str` items."""
        bgp_maintenance_profiles: BgpMaintenanceProfiles
        """Subclass of AvdList with `str` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                bgp_maintenance_profiles: BgpMaintenanceProfiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                BgpGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Group Name.
                    vrf: vrf
                    neighbors: Subclass of AvdList with `str` items.
                    bgp_maintenance_profiles: Subclass of AvdList with `str` items.
                    _custom_data: _custom_data

                """

    class BgpGroups(AvdIndexedList[str, BgpGroupsItem]):
        """Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    BgpGroups._item_type = BgpGroupsItem

    class Boot(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hash_algorithm": {"type": str, "default": "sha512"}, "key": {"type": str}, "_custom_data": {"type": dict}}
            hash_algorithm: Literal["md5", "sha512"]
            """Default value: `"sha512"`"""
            key: str | None
            """Hashed Password."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    hash_algorithm: Literal["md5", "sha512"] | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        hash_algorithm: hash_algorithm
                        key: Hashed Password.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"secret": {"type": Secret}, "_custom_data": {"type": dict}}
        secret: Secret
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, secret: Secret | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                Boot.


                Subclass of AvdModel.

                Args:
                    secret: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ClassMaps(AvdModel):
        """Subclass of AvdModel."""

        class PbrItem(AvdModel):
            """Subclass of AvdModel."""

            class Ip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}, "_custom_data": {"type": dict}}
                access_group: str | None
                """Standard Access-List Name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, access_group: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Ip.


                        Subclass of AvdModel.

                        Args:
                            access_group: Standard Access-List Name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ip": {"type": Ip}, "_custom_data": {"type": dict}}
            name: str
            """Class-Map Name."""
            ip: Ip
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, name: str | UndefinedType = Undefined, ip: Ip | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    PbrItem.


                    Subclass of AvdModel.

                    Args:
                        name: Class-Map Name.
                        ip: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Pbr(AvdIndexedList[str, PbrItem]):
            """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            """Subclass of AvdModel."""

            class Ip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}, "_custom_data": {"type": dict}}
                access_group: str | None
                """IPv4 Access-List Name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, access_group: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Ip.


                        Subclass of AvdModel.

                        Args:
                            access_group: IPv4 Access-List Name.
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"access_group": {"type": str}, "_custom_data": {"type": dict}}
                access_group: str | None
                """IPv6 Access-List Name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, access_group: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            access_group: IPv6 Access-List Name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "vlan": {"type": str},
                "cos": {"type": str},
                "ip": {"type": Ip},
                "ipv6": {"type": Ipv6},
                "_custom_data": {"type": dict},
            }
            name: str
            """Class-Map Name."""
            vlan: str | None
            """VLAN value(s) or range(s) of VLAN values."""
            cos: str | None
            """CoS value(s) or range(s) of CoS values."""
            ip: Ip
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    cos: str | None | UndefinedType = Undefined,
                    ip: Ip | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    QosItem.


                    Subclass of AvdModel.

                    Args:
                        name: Class-Map Name.
                        vlan: VLAN value(s) or range(s) of VLAN values.
                        cos: CoS value(s) or range(s) of CoS values.
                        ip: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Qos(AvdIndexedList[str, QosItem]):
            """Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}, "_custom_data": {"type": dict}}
        pbr: Pbr
        """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""
        qos: Qos
        """Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self, *, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
            ) -> None:
                """
                ClassMaps.


                Subclass of AvdModel.

                Args:
                    pbr: Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
                    qos: Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Clock(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"timezone": {"type": str}, "_custom_data": {"type": dict}}
        timezone: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, timezone: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                Clock.


                Subclass of AvdModel.

                Args:
                    timezone: timezone
                    _custom_data: _custom_data

                """

    class CommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "action": {"type": str}, "_custom_data": {"type": dict}}
        name: str
        """Community-list Name."""
        action: str
        """
        Action as string.
        Example: "permit GSHUT 65123:123"
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                CommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    action:
                       Action as string.
                       Example: "permit GSHUT 65123:123"
                    _custom_data: _custom_data

                """

    class CommunityLists(AvdIndexedList[str, CommunityListsItem]):
        """Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    CommunityLists._item_type = CommunityListsItem

    class CustomTemplates(AvdList[str]):
        """Subclass of AvdList with `str` items."""

    CustomTemplates._item_type = str

    class Cvx(AvdModel):
        """Subclass of AvdModel."""

        class PeerHosts(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        PeerHosts._item_type = str

        class Services(AvdModel):
            """Subclass of AvdModel."""

            class Mcs(AvdModel):
                """Subclass of AvdModel."""

                class Redis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"password": {"type": str}, "password_type": {"type": str, "default": "7"}, "_custom_data": {"type": dict}}
                    password: str | None
                    """Hashed password using the password_type."""
                    password_type: Literal["0", "7", "8a"]
                    """Default value: `"7"`"""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            password: str | None | UndefinedType = Undefined,
                            password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redis.


                            Subclass of AvdModel.

                            Args:
                                password: Hashed password using the password_type.
                                password_type: password_type
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"redis": {"type": Redis}, "shutdown": {"type": bool}, "_custom_data": {"type": dict}}
                redis: Redis
                """Subclass of AvdModel."""
                shutdown: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        redis: Redis | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mcs.


                        Subclass of AvdModel.

                        Args:
                            redis: Subclass of AvdModel.
                            shutdown: shutdown
                            _custom_data: _custom_data

                        """

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "vtep_mac_learning": {"type": str}, "_custom_data": {"type": dict}}
                shutdown: bool | None
                vtep_mac_learning: Literal["control-plane", "data-plane"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        shutdown: bool | None | UndefinedType = Undefined,
                        vtep_mac_learning: Literal["control-plane", "data-plane"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            shutdown: shutdown
                            vtep_mac_learning: vtep_mac_learning
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"mcs": {"type": Mcs}, "vxlan": {"type": Vxlan}, "_custom_data": {"type": dict}}
            mcs: Mcs
            """Subclass of AvdModel."""
            vxlan: Vxlan
            """
            VXLAN Controller service.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    mcs: Mcs | UndefinedType = Undefined,
                    vxlan: Vxlan | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Services.


                    Subclass of AvdModel.

                    Args:
                        mcs: Subclass of AvdModel.
                        vxlan:
                           VXLAN Controller service.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "shutdown": {"type": bool},
            "peer_hosts": {"type": PeerHosts},
            "services": {"type": Services},
            "_custom_data": {"type": dict},
        }
        shutdown: bool | None
        peer_hosts: PeerHosts
        """Subclass of AvdList with `str` items."""
        services: Services
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                peer_hosts: PeerHosts | UndefinedType = Undefined,
                services: Services | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Cvx.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    peer_hosts: Subclass of AvdList with `str` items.
                    services: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class DaemonTerminattr(AvdModel):
        """Subclass of AvdModel."""

        class Cvaddrs(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Cvaddrs._item_type = str

        class ClustersItem(AvdModel):
            """Subclass of AvdModel."""

            class Cvaddrs(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Cvaddrs._item_type = str

            class Cvauth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "method": {"type": str},
                    "key": {"type": str},
                    "token_file": {"type": str},
                    "cert_file": {"type": str},
                    "ca_file": {"type": str},
                    "key_file": {"type": str},
                    "_custom_data": {"type": dict},
                }
                method: Literal["token", "token-secure", "key", "certs"] | None
                key: str | None
                token_file: str | None
                """
                Token file path.
                e.g. "/tmp/token"
                """
                cert_file: str | None
                """
                Client certificate file path.
                e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                """
                ca_file: str | None
                """
                CA certificate file path (on-prem only).
                e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                """
                key_file: str | None
                """
                Client certificate key file path.
                e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        method: Literal["token", "token-secure", "key", "certs"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        token_file: str | None | UndefinedType = Undefined,
                        cert_file: str | None | UndefinedType = Undefined,
                        ca_file: str | None | UndefinedType = Undefined,
                        key_file: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Cvauth.


                        Subclass of AvdModel.

                        Args:
                            method: method
                            key: key
                            token_file:
                               Token file path.
                               e.g. "/tmp/token"
                            cert_file:
                               Client certificate file path.
                               e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                            ca_file:
                               CA certificate file path (on-prem only).
                               e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                            key_file:
                               Client certificate key file path.
                               e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "cvaddrs": {"type": Cvaddrs},
                "cvauth": {"type": Cvauth},
                "cvobscurekeyfile": {"type": bool},
                "cvproxy": {"type": str},
                "cvsourceip": {"type": str},
                "cvsourceintf": {"type": str},
                "cvvrf": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Cluster Name."""
            cvaddrs: Cvaddrs
            """
            Streaming address(es) for CloudVision cluster.
            - TCP 9910 is used for CV on-prem
            - TCP 443 is used
            for CV as a Service


            Subclass of AvdList with `str` items.
            """
            cvauth: Cvauth
            """
            Authentication scheme used to connect to CloudVision.


            Subclass of AvdModel.
            """
            cvobscurekeyfile: bool | None
            """Encrypt the private key used for authentication to CloudVision."""
            cvproxy: str | None
            """
            Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
            the cloud.
            The expected form is http://[user:password@]ip:port, e.g.:
            `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
            """
            cvsourceip: str | None
            """Set source IP address in case of in-band management."""
            cvsourceintf: str | None
            """
            Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
            The
            interface name is case sensitive and has to match the interface name in the running-config,
            e.g.:Vlan100.
            """
            cvvrf: str | None
            """The VRF to use to connect to CloudVision."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    cvaddrs: Cvaddrs | UndefinedType = Undefined,
                    cvauth: Cvauth | UndefinedType = Undefined,
                    cvobscurekeyfile: bool | None | UndefinedType = Undefined,
                    cvproxy: str | None | UndefinedType = Undefined,
                    cvsourceip: str | None | UndefinedType = Undefined,
                    cvsourceintf: str | None | UndefinedType = Undefined,
                    cvvrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClustersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Cluster Name.
                        cvaddrs:
                           Streaming address(es) for CloudVision cluster.
                           - TCP 9910 is used for CV on-prem
                           - TCP 443 is used
                           for CV as a Service


                           Subclass of AvdList with `str` items.
                        cvauth:
                           Authentication scheme used to connect to CloudVision.


                           Subclass of AvdModel.
                        cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                        cvproxy:
                           Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                           the cloud.
                           The expected form is http://[user:password@]ip:port, e.g.:
                           `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                        cvsourceip: Set source IP address in case of in-band management.
                        cvsourceintf:
                           Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
                           The
                           interface name is case sensitive and has to match the interface name in the running-config,
                           e.g.:Vlan100.
                        cvvrf: The VRF to use to connect to CloudVision.
                        _custom_data: _custom_data

                    """

        class Clusters(AvdIndexedList[str, ClustersItem]):
            """Subclass of AvdIndexedList with `ClustersItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Clusters._item_type = ClustersItem

        class Cvauth(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "method": {"type": str},
                "key": {"type": str},
                "token_file": {"type": str},
                "cert_file": {"type": str},
                "ca_file": {"type": str},
                "key_file": {"type": str},
                "_custom_data": {"type": dict},
            }
            method: Literal["token", "token-secure", "key", "certs"] | None
            key: str | None
            token_file: str | None
            """
            Token file path.
            e.g. "/tmp/token"
            """
            cert_file: str | None
            """
            Client certificate file path.
            e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
            """
            ca_file: str | None
            """
            CA certificate file path (on-prem only).
            e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
            """
            key_file: str | None
            """
            Client certificate key file path.
            e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    method: Literal["token", "token-secure", "key", "certs"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    token_file: str | None | UndefinedType = Undefined,
                    cert_file: str | None | UndefinedType = Undefined,
                    ca_file: str | None | UndefinedType = Undefined,
                    key_file: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Cvauth.


                    Subclass of AvdModel.

                    Args:
                        method: method
                        key: key
                        token_file:
                           Token file path.
                           e.g. "/tmp/token"
                        cert_file:
                           Client certificate file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                        ca_file:
                           CA certificate file path (on-prem only).
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                        key_file:
                           Client certificate key file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "cvaddrs": {"type": Cvaddrs},
            "clusters": {"type": Clusters},
            "cvauth": {"type": Cvauth},
            "cvobscurekeyfile": {"type": bool},
            "cvproxy": {"type": str},
            "cvsourceip": {"type": str},
            "cvsourceintf": {"type": str},
            "cvvrf": {"type": str},
            "cvgnmi": {"type": bool},
            "disable_aaa": {"type": bool},
            "grpcaddr": {"type": str},
            "grpcreadonly": {"type": bool},
            "ingestexclude": {"type": str},
            "smashexcludes": {"type": str},
            "taillogs": {"type": str},
            "ecodhcpaddr": {"type": str},
            "ipfix": {"type": bool},
            "ipfixaddr": {"type": str},
            "sflow": {"type": bool},
            "sflowaddr": {"type": str},
            "cvconfig": {"type": bool},
            "_custom_data": {"type": dict},
        }
        cvaddrs: Cvaddrs
        """
        Streaming address(es) for CloudVision single cluster.
        - TCP 9910 is used for CV on-prem
        - TCP 443 is
        used for CV as a Service


        Subclass of AvdList with `str` items.
        """
        clusters: Clusters
        """
        Multiple CloudVision clusters.


        Subclass of AvdIndexedList with `ClustersItem` items. Primary key
        is `name` (`str`).
        """
        cvauth: Cvauth
        """
        Authentication scheme used to connect to CloudVision.


        Subclass of AvdModel.
        """
        cvobscurekeyfile: bool | None
        """Encrypt the private key used for authentication to CloudVision."""
        cvproxy: str | None
        """
        Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
        the cloud.
        The expected form is http://[user:password@]ip:port, e.g.:
        `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
        """
        cvsourceip: str | None
        """Set source IP address in case of in-band management."""
        cvsourceintf: str | None
        """
        Set source interface in case of in-band management.
        The interface name is case sensitive and has to
        match the interface name in the running-config, e.g.:Vlan100.
        """
        cvvrf: str | None
        """The VRF to use to connect to CloudVision."""
        cvgnmi: bool | None
        """Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1."""
        disable_aaa: bool | None
        """
        Disable AAA authorization and accounting.
        When setting this flag, all commands pushed from
        CloudVision are applied directly to the CLI without authorization.
        """
        grpcaddr: str | None
        """
        Set the gRPC server address, the default is 127.0.0.1:6042.
        e.g. "MGMT/0.0.0.0:6042"
        """
        grpcreadonly: bool | None
        """gNMI read-only mode - Disable gnmi.Set()."""
        ingestexclude: str | None
        """
        Exclude paths from Sysdb on the ingest side.
        e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
        """
        smashexcludes: str | None
        """
        Exclude paths from the shared memory table.
        e.g. "ale,flexCounter,hardware,kni,pulse,strata"
        """
        taillogs: str | None
        """
        Enable log file collection; /var/log/messages is streamed by default if no path is set.
        e.g.
        "/var/log/messages"
        """
        ecodhcpaddr: str | None
        """
        ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
        "127.0.0.1:67").
        """
        ipfix: bool | None
        """
        Enable IPFIX provider (TerminAttr default is true).
        This flag is enabled by default and does not
        have to be added to the daemon configuration.
        """
        ipfixaddr: str | None
        """
        ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
        "127.0.0.1:4739").
        """
        sflow: bool | None
        """Enable sFlow provider (TerminAttr default is true)."""
        sflowaddr: str | None
        """
        ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
        "127.0.0.1:6343").
        """
        cvconfig: bool | None
        """Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                cvaddrs: Cvaddrs | UndefinedType = Undefined,
                clusters: Clusters | UndefinedType = Undefined,
                cvauth: Cvauth | UndefinedType = Undefined,
                cvobscurekeyfile: bool | None | UndefinedType = Undefined,
                cvproxy: str | None | UndefinedType = Undefined,
                cvsourceip: str | None | UndefinedType = Undefined,
                cvsourceintf: str | None | UndefinedType = Undefined,
                cvvrf: str | None | UndefinedType = Undefined,
                cvgnmi: bool | None | UndefinedType = Undefined,
                disable_aaa: bool | None | UndefinedType = Undefined,
                grpcaddr: str | None | UndefinedType = Undefined,
                grpcreadonly: bool | None | UndefinedType = Undefined,
                ingestexclude: str | None | UndefinedType = Undefined,
                smashexcludes: str | None | UndefinedType = Undefined,
                taillogs: str | None | UndefinedType = Undefined,
                ecodhcpaddr: str | None | UndefinedType = Undefined,
                ipfix: bool | None | UndefinedType = Undefined,
                ipfixaddr: str | None | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                sflowaddr: str | None | UndefinedType = Undefined,
                cvconfig: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DaemonTerminattr.


                Subclass of AvdModel.

                Args:
                    cvaddrs:
                       Streaming address(es) for CloudVision single cluster.
                       - TCP 9910 is used for CV on-prem
                       - TCP 443 is
                       used for CV as a Service


                       Subclass of AvdList with `str` items.
                    clusters:
                       Multiple CloudVision clusters.


                       Subclass of AvdIndexedList with `ClustersItem` items. Primary key
                       is `name` (`str`).
                    cvauth:
                       Authentication scheme used to connect to CloudVision.


                       Subclass of AvdModel.
                    cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                    cvproxy:
                       Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                       the cloud.
                       The expected form is http://[user:password@]ip:port, e.g.:
                       `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                    cvsourceip: Set source IP address in case of in-band management.
                    cvsourceintf:
                       Set source interface in case of in-band management.
                       The interface name is case sensitive and has to
                       match the interface name in the running-config, e.g.:Vlan100.
                    cvvrf: The VRF to use to connect to CloudVision.
                    cvgnmi: Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1.
                    disable_aaa:
                       Disable AAA authorization and accounting.
                       When setting this flag, all commands pushed from
                       CloudVision are applied directly to the CLI without authorization.
                    grpcaddr:
                       Set the gRPC server address, the default is 127.0.0.1:6042.
                       e.g. "MGMT/0.0.0.0:6042"
                    grpcreadonly: gNMI read-only mode - Disable gnmi.Set().
                    ingestexclude:
                       Exclude paths from Sysdb on the ingest side.
                       e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
                    smashexcludes:
                       Exclude paths from the shared memory table.
                       e.g. "ale,flexCounter,hardware,kni,pulse,strata"
                    taillogs:
                       Enable log file collection; /var/log/messages is streamed by default if no path is set.
                       e.g.
                       "/var/log/messages"
                    ecodhcpaddr:
                       ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
                       "127.0.0.1:67").
                    ipfix:
                       Enable IPFIX provider (TerminAttr default is true).
                       This flag is enabled by default and does not
                       have to be added to the daemon configuration.
                    ipfixaddr:
                       ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
                       "127.0.0.1:4739").
                    sflow: Enable sFlow provider (TerminAttr default is true).
                    sflowaddr:
                       ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
                       "127.0.0.1:6343").
                    cvconfig: Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false).
                    _custom_data: _custom_data

                """

    class DaemonsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "exec": {"type": str}, "enabled": {"type": bool, "default": True}, "_custom_data": {"type": dict}}
        name: str
        """Daemon Name."""
        exec: str
        """command to run as a daemon."""
        enabled: bool
        """Default value: `True`"""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                exec: str | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DaemonsItem.


                Subclass of AvdModel.

                Args:
                    name: Daemon Name.
                    exec: command to run as a daemon.
                    enabled: enabled
                    _custom_data: _custom_data

                """

    class Daemons(AvdIndexedList[str, DaemonsItem]):
        """Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Daemons._item_type = DaemonsItem

    class DhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        class Servers(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Servers._item_type = str

        _fields: ClassVar[dict] = {
            "servers": {"type": Servers},
            "tunnel_requests_disabled": {"type": bool},
            "mlag_peerlink_requests_disabled": {"type": bool},
            "_custom_data": {"type": dict},
        }
        servers: Servers
        """Subclass of AvdList with `str` items."""
        tunnel_requests_disabled: bool | None
        mlag_peerlink_requests_disabled: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                servers: Servers | UndefinedType = Undefined,
                tunnel_requests_disabled: bool | None | UndefinedType = Undefined,
                mlag_peerlink_requests_disabled: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DhcpRelay.


                Subclass of AvdModel.

                Args:
                    servers: Subclass of AvdList with `str` items.
                    tunnel_requests_disabled: tunnel_requests_disabled
                    mlag_peerlink_requests_disabled: mlag_peerlink_requests_disabled
                    _custom_data: _custom_data

                """

    class DhcpServersItem(AvdModel):
        """Subclass of AvdModel."""

        class LeaseTimeIpv4(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}, "_custom_data": {"type": dict}}
            days: int
            hours: int
            minutes: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    days: int | UndefinedType = Undefined,
                    hours: int | UndefinedType = Undefined,
                    minutes: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LeaseTimeIpv4.


                    Subclass of AvdModel.

                    Args:
                        days: days
                        hours: hours
                        minutes: minutes
                        _custom_data: _custom_data

                    """

        class LeaseTimeIpv6(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}, "_custom_data": {"type": dict}}
            days: int
            hours: int
            minutes: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    days: int | UndefinedType = Undefined,
                    hours: int | UndefinedType = Undefined,
                    minutes: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LeaseTimeIpv6.


                    Subclass of AvdModel.

                    Args:
                        days: days
                        hours: hours
                        minutes: minutes
                        _custom_data: _custom_data

                    """

        class DnsServersIpv4(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DnsServersIpv4._item_type = str

        class DnsServersIpv6(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        DnsServersIpv6._item_type = str

        class TftpServer(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"file_ipv4": {"type": str}, "file_ipv6": {"type": str}, "_custom_data": {"type": dict}}
            file_ipv4: str | None
            """Name of TFTP file for IPv4 clients."""
            file_ipv6: str | None
            """Name of TFTP file for IPv6 clients."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    file_ipv4: str | None | UndefinedType = Undefined,
                    file_ipv6: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TftpServer.


                    Subclass of AvdModel.

                    Args:
                        file_ipv4: Name of TFTP file for IPv4 clients.
                        file_ipv6: Name of TFTP file for IPv6 clients.
                        _custom_data: _custom_data

                    """

        class Ipv4VendorOptionsItem(AvdModel):
            """Subclass of AvdModel."""

            class SubOptionsItem(AvdModel):
                """Subclass of AvdModel."""

                class ArrayIpv4Address(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                ArrayIpv4Address._item_type = str

                _fields: ClassVar[dict] = {
                    "code": {"type": int},
                    "string": {"type": str},
                    "ipv4_address": {"type": str},
                    "array_ipv4_address": {"type": ArrayIpv4Address},
                    "_custom_data": {"type": dict},
                }
                code: int
                string: str | None
                """
                String value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                ipv4_address: str | None
                """
                IPv4 address value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                array_ipv4_address: ArrayIpv4Address
                """
                Array of IPv4 addresses for suboption data.
                Only one of `string`, `ipv4_address` and
                `array_ipv4_address` variables should be used for any one suboption.
                The order of precedence if
                multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                Subclass of AvdList with `str` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        code: int | UndefinedType = Undefined,
                        string: str | None | UndefinedType = Undefined,
                        ipv4_address: str | None | UndefinedType = Undefined,
                        array_ipv4_address: ArrayIpv4Address | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SubOptionsItem.


                        Subclass of AvdModel.

                        Args:
                            code: code
                            string:
                               String value for suboption data.
                               Only one of `string`, `ipv4_address` and `array_ipv4_address`
                               variables should be used for any one suboption.
                               The order of precedence if multiple of these
                               variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                            ipv4_address:
                               IPv4 address value for suboption data.
                               Only one of `string`, `ipv4_address` and `array_ipv4_address`
                               variables should be used for any one suboption.
                               The order of precedence if multiple of these
                               variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                            array_ipv4_address:
                               Array of IPv4 addresses for suboption data.
                               Only one of `string`, `ipv4_address` and
                               `array_ipv4_address` variables should be used for any one suboption.
                               The order of precedence if
                               multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                               Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class SubOptions(AvdIndexedList[int, SubOptionsItem]):
                """Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`)."""

                _primary_key: ClassVar[str] = "code"

            SubOptions._item_type = SubOptionsItem

            _fields: ClassVar[dict] = {"vendor_id": {"type": str}, "sub_options": {"type": SubOptions}, "_custom_data": {"type": dict}}
            vendor_id: str
            sub_options: SubOptions
            """Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    vendor_id: str | UndefinedType = Undefined,
                    sub_options: SubOptions | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4VendorOptionsItem.


                    Subclass of AvdModel.

                    Args:
                        vendor_id: vendor_id
                        sub_options: Subclass of AvdIndexedList with `SubOptionsItem` items. Primary key is `code` (`int`).
                        _custom_data: _custom_data

                    """

        class Ipv4VendorOptions(AvdIndexedList[str, Ipv4VendorOptionsItem]):
            """Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`)."""

            _primary_key: ClassVar[str] = "vendor_id"

        Ipv4VendorOptions._item_type = Ipv4VendorOptionsItem

        class SubnetsItem(AvdModel):
            """Subclass of AvdModel."""

            class DnsServers(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            DnsServers._item_type = str

            class RangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"start": {"type": str}, "end": {"type": str}, "_custom_data": {"type": dict}}
                start: str
                end: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        start: str | UndefinedType = Undefined,
                        end: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RangesItem.


                        Subclass of AvdModel.

                        Args:
                            start: start
                            end: end
                            _custom_data: _custom_data

                        """

            class Ranges(AvdList[RangesItem]):
                """Subclass of AvdList with `RangesItem` items."""

            Ranges._item_type = RangesItem

            class LeaseTime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}, "_custom_data": {"type": dict}}
                days: int
                hours: int
                minutes: int
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        days: int | UndefinedType = Undefined,
                        hours: int | UndefinedType = Undefined,
                        minutes: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LeaseTime.


                        Subclass of AvdModel.

                        Args:
                            days: days
                            hours: hours
                            minutes: minutes
                            _custom_data: _custom_data

                        """

            class ReservationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "mac_address": {"type": str},
                    "hostname": {"type": str},
                    "ipv4_address": {"type": str},
                    "ipv6_address": {"type": str},
                    "_custom_data": {"type": dict},
                }
                mac_address: str
                """Ethernet address in format - HHHH.HHHH.HHHH"""
                hostname: str | None
                ipv4_address: str | None
                """
                Valid IPv4 address from the given subnet.
                This should only be used within an IPv4 subnet.
                """
                ipv6_address: str | None
                """
                Valid IPv6 address from the given subnet.
                This should only be used within an IPv6 subnet.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mac_address: str | UndefinedType = Undefined,
                        hostname: str | None | UndefinedType = Undefined,
                        ipv4_address: str | None | UndefinedType = Undefined,
                        ipv6_address: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ReservationsItem.


                        Subclass of AvdModel.

                        Args:
                            mac_address: Ethernet address in format - HHHH.HHHH.HHHH
                            hostname: hostname
                            ipv4_address:
                               Valid IPv4 address from the given subnet.
                               This should only be used within an IPv4 subnet.
                            ipv6_address:
                               Valid IPv6 address from the given subnet.
                               This should only be used within an IPv6 subnet.
                            _custom_data: _custom_data

                        """

            class Reservations(AvdIndexedList[str, ReservationsItem]):
                """Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is `mac_address` (`str`)."""

                _primary_key: ClassVar[str] = "mac_address"

            Reservations._item_type = ReservationsItem

            _fields: ClassVar[dict] = {
                "subnet": {"type": str},
                "name": {"type": str},
                "default_gateway": {"type": str},
                "dns_servers": {"type": DnsServers},
                "ranges": {"type": Ranges},
                "lease_time": {"type": LeaseTime},
                "reservations": {"type": Reservations},
                "_custom_data": {"type": dict},
            }
            subnet: str
            """IPv4/IPv6 subnet."""
            name: str | None
            default_gateway: str | None
            dns_servers: DnsServers
            """Subclass of AvdList with `str` items."""
            ranges: Ranges
            """Subclass of AvdList with `RangesItem` items."""
            lease_time: LeaseTime
            """Subclass of AvdModel."""
            reservations: Reservations
            """
            DHCP client reservations.

            Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is
            `mac_address` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    subnet: str | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    default_gateway: str | None | UndefinedType = Undefined,
                    dns_servers: DnsServers | UndefinedType = Undefined,
                    ranges: Ranges | UndefinedType = Undefined,
                    lease_time: LeaseTime | UndefinedType = Undefined,
                    reservations: Reservations | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SubnetsItem.


                    Subclass of AvdModel.

                    Args:
                        subnet: IPv4/IPv6 subnet.
                        name: name
                        default_gateway: default_gateway
                        dns_servers: Subclass of AvdList with `str` items.
                        ranges: Subclass of AvdList with `RangesItem` items.
                        lease_time: Subclass of AvdModel.
                        reservations:
                           DHCP client reservations.

                           Subclass of AvdIndexedList with `ReservationsItem` items. Primary key is
                           `mac_address` (`str`).
                        _custom_data: _custom_data

                    """

        class Subnets(AvdIndexedList[str, SubnetsItem]):
            """Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`)."""

            _primary_key: ClassVar[str] = "subnet"

        Subnets._item_type = SubnetsItem

        _fields: ClassVar[dict] = {
            "disabled": {"type": bool},
            "vrf": {"type": str},
            "lease_time_ipv4": {"type": LeaseTimeIpv4},
            "lease_time_ipv6": {"type": LeaseTimeIpv6},
            "dns_domain_name_ipv4": {"type": str},
            "dns_domain_name_ipv6": {"type": str},
            "dns_servers_ipv4": {"type": DnsServersIpv4},
            "dns_servers_ipv6": {"type": DnsServersIpv6},
            "tftp_server": {"type": TftpServer},
            "ipv4_vendor_options": {"type": Ipv4VendorOptions},
            "subnets": {"type": Subnets},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        disabled: bool | None
        vrf: str
        """VRF in which to configure the DHCP server, use `default` to indicate default VRF."""
        lease_time_ipv4: LeaseTimeIpv4
        """Subclass of AvdModel."""
        lease_time_ipv6: LeaseTimeIpv6
        """Subclass of AvdModel."""
        dns_domain_name_ipv4: str | None
        dns_domain_name_ipv6: str | None
        dns_servers_ipv4: DnsServersIpv4
        """
        List of DNS servers for IPv4 clients.

        Subclass of AvdList with `str` items.
        """
        dns_servers_ipv6: DnsServersIpv6
        """
        List of DNS servers for IPv6 clients.

        Subclass of AvdList with `str` items.
        """
        tftp_server: TftpServer
        """Subclass of AvdModel."""
        ipv4_vendor_options: Ipv4VendorOptions
        """Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`)."""
        subnets: Subnets
        """Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`)."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | None | UndefinedType = Undefined,
                vrf: str | UndefinedType = Undefined,
                lease_time_ipv4: LeaseTimeIpv4 | UndefinedType = Undefined,
                lease_time_ipv6: LeaseTimeIpv6 | UndefinedType = Undefined,
                dns_domain_name_ipv4: str | None | UndefinedType = Undefined,
                dns_domain_name_ipv6: str | None | UndefinedType = Undefined,
                dns_servers_ipv4: DnsServersIpv4 | UndefinedType = Undefined,
                dns_servers_ipv6: DnsServersIpv6 | UndefinedType = Undefined,
                tftp_server: TftpServer | UndefinedType = Undefined,
                ipv4_vendor_options: Ipv4VendorOptions | UndefinedType = Undefined,
                subnets: Subnets | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DhcpServersItem.


                Subclass of AvdModel.

                Args:
                    disabled: disabled
                    vrf: VRF in which to configure the DHCP server, use `default` to indicate default VRF.
                    lease_time_ipv4: Subclass of AvdModel.
                    lease_time_ipv6: Subclass of AvdModel.
                    dns_domain_name_ipv4: dns_domain_name_ipv4
                    dns_domain_name_ipv6: dns_domain_name_ipv6
                    dns_servers_ipv4:
                       List of DNS servers for IPv4 clients.

                       Subclass of AvdList with `str` items.
                    dns_servers_ipv6:
                       List of DNS servers for IPv6 clients.

                       Subclass of AvdList with `str` items.
                    tftp_server: Subclass of AvdModel.
                    ipv4_vendor_options: Subclass of AvdIndexedList with `Ipv4VendorOptionsItem` items. Primary key is `vendor_id` (`str`).
                    subnets: Subclass of AvdIndexedList with `SubnetsItem` items. Primary key is `subnet` (`str`).
                    eos_cli: Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class DhcpServers(AvdIndexedList[str, DhcpServersItem]):
        """Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`)."""

        _primary_key: ClassVar[str] = "vrf"

    DhcpServers._item_type = DhcpServersItem

    class DomainList(AvdList[str]):
        """Subclass of AvdList with `str` items."""

    DomainList._item_type = str

    class Dot1x(AvdModel):
        """Subclass of AvdModel."""

        class MacBasedAuthentication(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"delay": {"type": int}, "hold_period": {"type": int}, "_custom_data": {"type": dict}}
            delay: int | None
            hold_period: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    delay: int | None | UndefinedType = Undefined,
                    hold_period: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MacBasedAuthentication.


                    Subclass of AvdModel.

                    Args:
                        delay: delay
                        hold_period: hold_period
                        _custom_data: _custom_data

                    """

        class RadiusAvPairUsernameFormat(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"delimiter": {"type": str}, "mac_string_case": {"type": str}, "_custom_data": {"type": dict}}
            delimiter: Literal["colon", "hyphen", "none", "period"]
            """Delimiter to use in MAC address string."""
            mac_string_case: Literal["lowercase", "uppercase"]
            """MAC address string in lowercase/uppercase."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    delimiter: Literal["colon", "hyphen", "none", "period"] | UndefinedType = Undefined,
                    mac_string_case: Literal["lowercase", "uppercase"] | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RadiusAvPairUsernameFormat.


                    Subclass of AvdModel.

                    Args:
                        delimiter: Delimiter to use in MAC address string.
                        mac_string_case: MAC address string in lowercase/uppercase.
                        _custom_data: _custom_data

                    """

        class RadiusAvPair(AvdModel):
            """Subclass of AvdModel."""

            class Lldp(AvdModel):
                """Subclass of AvdModel."""

                class SystemName(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool
                    auth_only: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            auth_only: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SystemName.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only
                                _custom_data: _custom_data

                            """

                class SystemDescription(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool
                    auth_only: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            auth_only: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SystemDescription.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "system_name": {"type": SystemName},
                    "system_description": {"type": SystemDescription},
                    "_custom_data": {"type": dict},
                }
                system_name: SystemName
                """
                LLDP system name (LLDP TLV 5) av-pair.

                Subclass of AvdModel.
                """
                system_description: SystemDescription
                """
                LLDP system description (LLDP TLV 6) av-pair.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        system_name: SystemName | UndefinedType = Undefined,
                        system_description: SystemDescription | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lldp.


                        Subclass of AvdModel.

                        Args:
                            system_name:
                               LLDP system name (LLDP TLV 5) av-pair.

                               Subclass of AvdModel.
                            system_description:
                               LLDP system description (LLDP TLV 6) av-pair.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Dhcp(AvdModel):
                """Subclass of AvdModel."""

                class Hostname(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool
                    auth_only: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            auth_only: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Hostname.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only
                                _custom_data: _custom_data

                            """

                class ParameterRequestList(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool
                    auth_only: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            auth_only: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ParameterRequestList.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only
                                _custom_data: _custom_data

                            """

                class VendorClassId(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "auth_only": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool
                    auth_only: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            auth_only: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VendorClassId.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                auth_only: auth_only
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "hostname": {"type": Hostname},
                    "parameter_request_list": {"type": ParameterRequestList},
                    "vendor_class_id": {"type": VendorClassId},
                    "_custom_data": {"type": dict},
                }
                hostname: Hostname
                """
                Hostname (DHCP Option 12).

                Subclass of AvdModel.
                """
                parameter_request_list: ParameterRequestList
                """
                Parameters requested by host (DHCP Option 55).

                Subclass of AvdModel.
                """
                vendor_class_id: VendorClassId
                """
                Vendor class identifier (DHCP Option 60).

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        hostname: Hostname | UndefinedType = Undefined,
                        parameter_request_list: ParameterRequestList | UndefinedType = Undefined,
                        vendor_class_id: VendorClassId | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dhcp.


                        Subclass of AvdModel.

                        Args:
                            hostname:
                               Hostname (DHCP Option 12).

                               Subclass of AvdModel.
                            parameter_request_list:
                               Parameters requested by host (DHCP Option 55).

                               Subclass of AvdModel.
                            vendor_class_id:
                               Vendor class identifier (DHCP Option 60).

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "service_type": {"type": bool},
                "framed_mtu": {"type": int},
                "lldp": {"type": Lldp},
                "dhcp": {"type": Dhcp},
                "_custom_data": {"type": dict},
            }
            service_type: bool | None
            framed_mtu: int | None
            lldp: Lldp
            """Subclass of AvdModel."""
            dhcp: Dhcp
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    service_type: bool | None | UndefinedType = Undefined,
                    framed_mtu: int | None | UndefinedType = Undefined,
                    lldp: Lldp | UndefinedType = Undefined,
                    dhcp: Dhcp | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RadiusAvPair.


                    Subclass of AvdModel.

                    Args:
                        service_type: service_type
                        framed_mtu: framed_mtu
                        lldp: Subclass of AvdModel.
                        dhcp: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Aaa(AvdModel):
            """Subclass of AvdModel."""

            class Unresponsive(AvdModel):
                """Subclass of AvdModel."""

                class Action(AvdModel):
                    """Subclass of AvdModel."""

                    class CachedResultsTimeout(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}, "_custom_data": {"type": dict}}
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Literal["days", "hours", "minutes", "seconds"]
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.


                                Subclass of AvdModel.

                                Args:
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                        "traffic_allow_vlan": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    """Subclass of AvdModel."""
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive action apply cached-results
                    else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""
                    traffic_allow_vlan: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                            traffic_allow_vlan: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Action.


                            Subclass of AvdModel.

                            Args:
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: Subclass of AvdModel.
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive action apply cached-results
                                   else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.
                                traffic_allow_vlan: traffic_allow_vlan
                                _custom_data: _custom_data

                            """

                class PhoneAction(AvdModel):
                    """Subclass of AvdModel."""

                    class CachedResultsTimeout(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}, "_custom_data": {"type": dict}}
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Literal["days", "hours", "minutes", "seconds"]
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.


                                Subclass of AvdModel.

                                Args:
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    """Subclass of AvdModel."""
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive phone action apply cached-
                    results else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PhoneAction.


                            Subclass of AvdModel.

                            Args:
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: Subclass of AvdModel.
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive phone action apply cached-
                                   results else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "eap_response": {"type": str},
                    "action": {"type": Action},
                    "phone_action": {"type": PhoneAction},
                    "recovery_action_reauthenticate": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                eap_response: Literal["success", "disabled"] | None
                """EAP response to send."""
                action: Action
                """
                Set action for supplicant when AAA times out.

                Subclass of AvdModel.
                """
                phone_action: PhoneAction
                """
                Set action for supplicant when AAA times out.

                Subclass of AvdModel.
                """
                recovery_action_reauthenticate: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        eap_response: Literal["success", "disabled"] | None | UndefinedType = Undefined,
                        action: Action | UndefinedType = Undefined,
                        phone_action: PhoneAction | UndefinedType = Undefined,
                        recovery_action_reauthenticate: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Unresponsive.


                        Subclass of AvdModel.

                        Args:
                            eap_response: EAP response to send.
                            action:
                               Set action for supplicant when AAA times out.

                               Subclass of AvdModel.
                            phone_action:
                               Set action for supplicant when AAA times out.

                               Subclass of AvdModel.
                            recovery_action_reauthenticate: recovery_action_reauthenticate
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"unresponsive": {"type": Unresponsive}, "accounting_update_interval": {"type": int}, "_custom_data": {"type": dict}}
            unresponsive: Unresponsive
            """
            Configure AAA timeout options.

            Subclass of AvdModel.
            """
            accounting_update_interval: int | None
            """Interval period in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    unresponsive: Unresponsive | UndefinedType = Undefined,
                    accounting_update_interval: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Aaa.


                    Subclass of AvdModel.

                    Args:
                        unresponsive:
                           Configure AAA timeout options.

                           Subclass of AvdModel.
                        accounting_update_interval: Interval period in seconds.
                        _custom_data: _custom_data

                    """

        class CaptivePortal(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "url": {"type": str},
                "ssl_profile": {"type": str},
                "start_limit_infinite": {"type": bool},
                "access_list_ipv4": {"type": str},
                "_custom_data": {"type": dict},
            }
            enabled: bool
            url: str | None
            """
            Supported URL type:
              - http: http://<hostname>[:<port>]
              - https: https://<hostname>[:<port>]
            """
            ssl_profile: str | None
            start_limit_infinite: bool | None
            """Set captive-portal start limit to infinite."""
            access_list_ipv4: str | None
            """Standard access-list name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    start_limit_infinite: bool | None | UndefinedType = Undefined,
                    access_list_ipv4: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CaptivePortal.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        url:
                           Supported URL type:
                             - http: http://<hostname>[:<port>]
                             - https: https://<hostname>[:<port>]
                        ssl_profile: ssl_profile
                        start_limit_infinite: Set captive-portal start limit to infinite.
                        access_list_ipv4: Standard access-list name.
                        _custom_data: _custom_data

                    """

        class Supplicant(AvdModel):
            """Subclass of AvdModel."""

            class ProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "eap_method": {"type": str},
                    "identity": {"type": str},
                    "passphrase_type": {"type": str, "default": "7"},
                    "passphrase": {"type": str},
                    "ssl_profile": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                eap_method: Literal["fast", "tls"] | None
                """
                Extensible Authentication Protocol method:
                  - EAP Flexible Authentication via Secure Tunneling.
                  -
                EAP with Transport Layer Security.
                """
                identity: str | None
                """User identity."""
                passphrase_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""
                passphrase: str | None
                """Extensible Authentication Protocol password."""
                ssl_profile: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        eap_method: Literal["fast", "tls"] | None | UndefinedType = Undefined,
                        identity: str | None | UndefinedType = Undefined,
                        passphrase_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                        passphrase: str | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            eap_method:
                               Extensible Authentication Protocol method:
                                 - EAP Flexible Authentication via Secure Tunneling.
                                 -
                               EAP with Transport Layer Security.
                            identity: User identity.
                            passphrase_type: passphrase_type
                            passphrase: Extensible Authentication Protocol password.
                            ssl_profile: ssl_profile
                            _custom_data: _custom_data

                        """

            class Profiles(AvdIndexedList[str, ProfilesItem]):
                """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {
                "profiles": {"type": Profiles},
                "logging": {"type": bool},
                "disconnect_cached_results_timeout": {"type": int},
                "_custom_data": {"type": dict},
            }
            profiles: Profiles
            """
            Dot1x supplicant profiles.

            Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
            `name` (`str`).
            """
            logging: bool | None
            """Enable supplicant logging."""
            disconnect_cached_results_timeout: int | None
            """Timeout in seconds for removing a disconnected supplicant."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    profiles: Profiles | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                    disconnect_cached_results_timeout: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Supplicant.


                    Subclass of AvdModel.

                    Args:
                        profiles:
                           Dot1x supplicant profiles.

                           Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
                           `name` (`str`).
                        logging: Enable supplicant logging.
                        disconnect_cached_results_timeout: Timeout in seconds for removing a disconnected supplicant.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "system_auth_control": {"type": bool},
            "protocol_lldp_bypass": {"type": bool},
            "protocol_bpdu_bypass": {"type": bool},
            "dynamic_authorization": {"type": bool},
            "mac_based_authentication": {"type": MacBasedAuthentication},
            "radius_av_pair_username_format": {"type": RadiusAvPairUsernameFormat},
            "radius_av_pair": {"type": RadiusAvPair},
            "aaa": {"type": Aaa},
            "captive_portal": {"type": CaptivePortal},
            "supplicant": {"type": Supplicant},
            "_custom_data": {"type": dict},
        }
        system_auth_control: bool | None
        protocol_lldp_bypass: bool | None
        protocol_bpdu_bypass: bool | None
        dynamic_authorization: bool | None
        mac_based_authentication: MacBasedAuthentication
        """Subclass of AvdModel."""
        radius_av_pair_username_format: RadiusAvPairUsernameFormat
        """
        RADIUS AV-pair username settings.

        Subclass of AvdModel.
        """
        radius_av_pair: RadiusAvPair
        """Subclass of AvdModel."""
        aaa: Aaa
        """
        Configure AAA parameters.

        Subclass of AvdModel.
        """
        captive_portal: CaptivePortal
        """
        Web authentication feature authenticates a supplicant through a web page, referred to as a captive
        portal.

        Subclass of AvdModel.
        """
        supplicant: Supplicant
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                system_auth_control: bool | None | UndefinedType = Undefined,
                protocol_lldp_bypass: bool | None | UndefinedType = Undefined,
                protocol_bpdu_bypass: bool | None | UndefinedType = Undefined,
                dynamic_authorization: bool | None | UndefinedType = Undefined,
                mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                radius_av_pair_username_format: RadiusAvPairUsernameFormat | UndefinedType = Undefined,
                radius_av_pair: RadiusAvPair | UndefinedType = Undefined,
                aaa: Aaa | UndefinedType = Undefined,
                captive_portal: CaptivePortal | UndefinedType = Undefined,
                supplicant: Supplicant | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Dot1x.


                Subclass of AvdModel.

                Args:
                    system_auth_control: system_auth_control
                    protocol_lldp_bypass: protocol_lldp_bypass
                    protocol_bpdu_bypass: protocol_bpdu_bypass
                    dynamic_authorization: dynamic_authorization
                    mac_based_authentication: Subclass of AvdModel.
                    radius_av_pair_username_format:
                       RADIUS AV-pair username settings.

                       Subclass of AvdModel.
                    radius_av_pair: Subclass of AvdModel.
                    aaa:
                       Configure AAA parameters.

                       Subclass of AvdModel.
                    captive_portal:
                       Web authentication feature authenticates a supplicant through a web page, referred to as a captive
                       portal.

                       Subclass of AvdModel.
                    supplicant: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class DpsInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}, "_custom_data": {"type": dict}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name,"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sampled: str | None | UndefinedType = Undefined,
                    hardware: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name,
                        _custom_data: _custom_data

                    """

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}, "_custom_data": {"type": dict}}
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: Literal["ingress", "egress"] | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                    direction: Literal["ingress", "egress"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Segment Size for IPv4.
                        ipv6: Segment Size for IPv6.
                        direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "ip_address": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: Literal["Dps1"]
        """"Dps1" is currently the only supported interface."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        """Maximum Transmission Unit in bytes."""
        ip_address: str | None
        """IPv4 address/mask."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: Literal["Dps1"] | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DpsInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: "Dps1" is currently the only supported interface.
                    description: description
                    shutdown: shutdown
                    mtu: Maximum Transmission Unit in bytes.
                    ip_address: IPv4 address/mask.
                    flow_tracker: Subclass of AvdModel.
                    tcp_mss_ceiling: Subclass of AvdModel.
                    eos_cli: Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class DpsInterfaces(AvdIndexedList[str, DpsInterfacesItem]):
        """Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    DpsInterfaces._item_type = DpsInterfacesItem

    class DynamicPrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class PrefixList(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}, "_custom_data": {"type": dict}}
            ipv4: str | None
            """Prefix-list name."""
            ipv6: str | None
            """Prefix-list name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: str | None | UndefinedType = Undefined,
                    ipv6: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrefixList.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Prefix-list name.
                        ipv6: Prefix-list name.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"name": {"type": str}, "match_map": {"type": str}, "prefix_list": {"type": PrefixList}, "_custom_data": {"type": dict}}
        name: str | None
        """Dynamic prefix-list name."""
        match_map: str | None
        """Route-map name."""
        prefix_list: PrefixList
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                match_map: str | None | UndefinedType = Undefined,
                prefix_list: PrefixList | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                DynamicPrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Dynamic prefix-list name.
                    match_map: Route-map name.
                    prefix_list: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class DynamicPrefixLists(AvdList[DynamicPrefixListsItem]):
        """Subclass of AvdList with `DynamicPrefixListsItem` items."""

    DynamicPrefixLists._item_type = DynamicPrefixListsItem

    class EnablePassword(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"disabled": {"type": bool}, "hash_algorithm": {"type": str}, "key": {"type": str}, "_custom_data": {"type": dict}}
        disabled: bool | None
        """Set to `true` to configure `no enable password` which is the EOS default."""
        hash_algorithm: Literal["md5", "sha512"] | None
        key: str | None
        """
        Must be the hash of the password using the specified algorithm.
        By default EOS salts the password,
        so the simplest is to generate the hash on an EOS device.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | None | UndefinedType = Undefined,
                hash_algorithm: Literal["md5", "sha512"] | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                EnablePassword.


                Subclass of AvdModel.

                Args:
                    disabled: Set to `true` to configure `no enable password` which is the EOS default.
                    hash_algorithm: hash_algorithm
                    key:
                       Must be the hash of the password using the specified algorithm.
                       By default EOS salts the password,
                       so the simplest is to generate the hash on an EOS device.
                    _custom_data: _custom_data

                """

    class EosCliConfigGenConfiguration(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "enable": {"type": bool, "default": True},
            "hide_passwords": {"type": bool, "default": False},
            "_custom_data": {"type": dict},
        }
        enable: bool
        """
        Generate device EOS configurations.

        Default value: `True`
        """
        hide_passwords: bool
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the configuration if true.

        Default value: `False`
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable: bool | UndefinedType = Undefined,
                hide_passwords: bool | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                EosCliConfigGenConfiguration.


                Subclass of AvdModel.

                Args:
                    enable: Generate device EOS configurations.
                    hide_passwords:
                       Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                       the configuration if true.
                    _custom_data: _custom_data

                """

    class EosCliConfigGenDocumentation(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"enable": {"type": bool, "default": True}, "hide_passwords": {"type": bool, "default": True}, "_custom_data": {"type": dict}}
        enable: bool
        """
        Generate device Markdown documentation.

        Default value: `True`
        """
        hide_passwords: bool
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the documentation if true.

        Default value: `True`
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable: bool | UndefinedType = Undefined,
                hide_passwords: bool | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                EosCliConfigGenDocumentation.


                Subclass of AvdModel.

                Args:
                    enable: Generate device Markdown documentation.
                    hide_passwords:
                       Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                       the documentation if true.
                    _custom_data: _custom_data

                """

    class Errdisable(AvdModel):
        """Subclass of AvdModel."""

        class Detect(AvdModel):
            """Subclass of AvdModel."""

            class Causes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Causes._item_type = str

            _fields: ClassVar[dict] = {"causes": {"type": Causes}, "_custom_data": {"type": dict}}
            causes: Causes
            """Subclass of AvdList with `str` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, causes: Causes | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Detect.


                    Subclass of AvdModel.

                    Args:
                        causes: Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class Recovery(AvdModel):
            """Subclass of AvdModel."""

            class Causes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Causes._item_type = str

            _fields: ClassVar[dict] = {"causes": {"type": Causes}, "interval": {"type": int, "default": 300}, "_custom_data": {"type": dict}}
            causes: Causes
            """Subclass of AvdList with `str` items."""
            interval: int
            """
            Interval in seconds.

            Default value: `300`
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    causes: Causes | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Recovery.


                    Subclass of AvdModel.

                    Args:
                        causes: Subclass of AvdList with `str` items.
                        interval: Interval in seconds.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"detect": {"type": Detect}, "recovery": {"type": Recovery}, "_custom_data": {"type": dict}}
        detect: Detect
        """Subclass of AvdModel."""
        recovery: Recovery
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                detect: Detect | UndefinedType = Undefined,
                recovery: Recovery | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Errdisable.


                Subclass of AvdModel.

                Args:
                    detect: Subclass of AvdModel.
                    recovery: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class EthernetInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trunk": {"type": str}, "vlan": {"type": int}, "_custom_data": {"type": dict}}
            trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
            vlan: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        trunk: trunk
                        vlan: vlan
                        _custom_data: _custom_data

                    """

        class L2Protocol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}, "_custom_data": {"type": dict}}
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                    forwarding_profile: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    L2Protocol.


                    Subclass of AvdModel.

                    Args:
                        encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                        forwarding_profile: L2 protocol forwarding profile.
                        _custom_data: _custom_data

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class AddressLocking(AvdModel):
            """Subclass of AvdModel."""

            class AddressFamily(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}, "_custom_data": {"type": dict}}
                ipv4: bool | None
                """Enable/disable address locking for IPv4."""
                ipv6: bool | None
                """Enable/disable address locking for IPv6."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: bool | None | UndefinedType = Undefined,
                        ipv6: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Enable/disable address locking for IPv4.
                            ipv6: Enable/disable address locking for IPv6.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "ipv4": {"type": bool},
                "ipv6": {"type": bool},
                "address_family": {"type": AddressFamily},
                "ipv4_enforcement_disabled": {"type": bool},
                "_custom_data": {"type": dict},
            }
            ipv4: bool | None
            """
            Enable address locking for IPv4.
            For EOS version 4.31 and above, the `address_family.ipv4` parameter
            should be used instead.
            """
            ipv6: bool | None
            """
            Enable address locking for IPv6.
            For EOS version 4.31 and above, the `address_family.ipv6` parameter
            should be used instead.
            """
            address_family: AddressFamily
            """
            Configure address locking per address family.
            The `address_locking.ipv4/ipv6` and
            `address_locking.address_family.ipv4/ipv6` are mutually exclusive and
            `address_locking.address_family.ipv4/ipv6` take precedence.
            Introduced in EOS 4.31.0F.

            Subclass of
            AvdModel.
            """
            ipv4_enforcement_disabled: bool | None
            """Disable enforcement for IPv4 locked addresses."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    address_family: AddressFamily | UndefinedType = Undefined,
                    ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressLocking.


                    Subclass of AvdModel.

                    Args:
                        ipv4:
                           Enable address locking for IPv4.
                           For EOS version 4.31 and above, the `address_family.ipv4` parameter
                           should be used instead.
                        ipv6:
                           Enable address locking for IPv6.
                           For EOS version 4.31 and above, the `address_family.ipv6` parameter
                           should be used instead.
                        address_family:
                           Configure address locking per address family.
                           The `address_locking.ipv4/ipv6` and
                           `address_locking.address_family.ipv4/ipv6` are mutually exclusive and
                           `address_locking.address_family.ipv4/ipv6` take precedence.
                           Introduced in EOS 4.31.0F.

                           Subclass of
                           AvdModel.
                        ipv4_enforcement_disabled: Disable enforcement for IPv4 locked addresses.
                        _custom_data: _custom_data

                    """

        class Flowcontrol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"received": {"type": str}, "_custom_data": {"type": dict}}
            received: Literal["desired", "on", "off"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    received: Literal["desired", "on", "off"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Flowcontrol.


                    Subclass of AvdModel.

                    Args:
                        received: received
                        _custom_data: _custom_data

                    """

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}, "_custom_data": {"type": dict}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sampled: str | None | UndefinedType = Undefined,
                    hardware: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name.
                        _custom_data: _custom_data

                    """

        class ErrorCorrectionEncoding(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool, "default": True},
                "fire_code": {"type": bool},
                "reed_solomon": {"type": bool},
                "_custom_data": {"type": dict},
            }
            enabled: bool
            """Default value: `True`"""
            fire_code: bool | None
            reed_solomon: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    fire_code: bool | None | UndefinedType = Undefined,
                    reed_solomon: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ErrorCorrectionEncoding.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        fire_code: fire_code
                        reed_solomon: reed_solomon
                        _custom_data: _custom_data

                    """

        class LinkTrackingGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Group name."""
            direction: Literal["upstream", "downstream"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkTrackingGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        direction: direction
                        _custom_data: _custom_data

                    """

        class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
            """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class LinkTracking(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Groups._item_type = str

            _fields: ClassVar[dict] = {"direction": {"type": str}, "groups": {"type": Groups}, "_custom_data": {"type": dict}}
            direction: Literal["upstream", "downstream"] | None
            groups: Groups
            """
            Link state group(s) an interface belongs to.

            Subclass of AvdList with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkTracking.


                    Subclass of AvdModel.

                    Args:
                        direction: direction
                        groups:
                           Link state group(s) an interface belongs to.

                           Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class EvpnEthernetSegment(AvdModel):
            """Subclass of AvdModel."""

            class DesignatedForwarderElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                algorithm: Literal["modulus", "preference"] | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["modulus", "preference"] | None | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                        dont_preempt: bool | None | UndefinedType = Undefined,
                        hold_time: int | None | UndefinedType = Undefined,
                        subsequent_hold_time: int | None | UndefinedType = Undefined,
                        candidate_reachability_required: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DesignatedForwarderElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm: algorithm
                            preference_value: Preference_value is only used when "algorithm" is "preference".
                            dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                            hold_time: hold_time
                            subsequent_hold_time: subsequent_hold_time
                            candidate_reachability_required: candidate_reachability_required
                            _custom_data: _custom_data

                        """

            class Mpls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}, "_custom_data": {"type": dict}}
                shared_index: int | None
                tunnel_flood_filter_time: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        shared_index: int | None | UndefinedType = Undefined,
                        tunnel_flood_filter_time: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mpls.


                        Subclass of AvdModel.

                        Args:
                            shared_index: shared_index
                            tunnel_flood_filter_time: tunnel_flood_filter_time
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
                "_custom_data": {"type": dict},
            }
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Literal["all-active", "single-active"] | None
            designated_forwarder_election: DesignatedForwarderElection
            """Subclass of AvdModel."""
            mpls: Mpls
            """Subclass of AvdModel."""
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    identifier: str | None | UndefinedType = Undefined,
                    redundancy: Literal["all-active", "single-active"] | None | UndefinedType = Undefined,
                    designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                    mpls: Mpls | UndefinedType = Undefined,
                    route_target: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnEthernetSegment.


                    Subclass of AvdModel.

                    Args:
                        identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                        redundancy: redundancy
                        designated_forwarder_election: Subclass of AvdModel.
                        mpls: Subclass of AvdModel.
                        route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.
                        _custom_data: _custom_data

                    """

        class EncapsulationDot1q(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"vlan": {"type": int}, "inner_vlan": {"type": int}, "_custom_data": {"type": dict}}
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    vlan: int | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EncapsulationDot1q.


                    Subclass of AvdModel.

                    Args:
                        vlan: VLAD ID.
                        inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.
                        _custom_data: _custom_data

                    """

        class EncapsulationVlan(AvdModel):
            """Subclass of AvdModel."""

            class Client(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}, "_custom_data": {"type": dict}}
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Client VLAN ID.
                                outer: Client Outer VLAN ID.
                                inner: Client Inner VLAN ID.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                    "_custom_data": {"type": dict},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                unmatched: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        unmatched: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Client.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            unmatched: unmatched
                            encapsulation: encapsulation
                            vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_encapsulation: inner_encapsulation
                            _custom_data: _custom_data

                        """

            class Network(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}, "_custom_data": {"type": dict}}
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network outer VLAN ID."""
                    inner: int | None
                    """Network inner VLAN ID."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Network VLAN ID.
                                outer: Network outer VLAN ID.
                                inner: Network inner VLAN ID.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                    "_custom_data": {"type": dict},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                client: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        client: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Network.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            client: client
                            encapsulation:
                               `untagged` (no encapsulation) is applicable for `untagged` client only.
                               `client` and `client inner`
                               (retain client encapsulation) is not applicable for `untagged` client.
                            vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_vlan: Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_encapsulation: inner_encapsulation
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"client": {"type": Client}, "network": {"type": Network}, "_custom_data": {"type": dict}}
            client: Client
            """Subclass of AvdModel."""
            network: Network
            """
            Network encapsulations are all optional and skipped if using client unmatched.

            Subclass of
            AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    client: Client | UndefinedType = Undefined,
                    network: Network | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EncapsulationVlan.


                    Subclass of AvdModel.

                    Args:
                        client: Subclass of AvdModel.
                        network:
                           Network encapsulations are all optional and skipped if using client unmatched.

                           Subclass of
                           AvdModel.
                        _custom_data: _custom_data

                    """

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class IpHelpersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            ip_helper: str
            source_interface: str | None
            """Source interface name."""
            vrf: str | None
            """VRF name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_helper: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpHelpersItem.


                    Subclass of AvdModel.

                    Args:
                        ip_helper: ip_helper
                        source_interface: Source interface name.
                        vrf: VRF name.
                        _custom_data: _custom_data

                    """

        class IpHelpers(AvdIndexedList[str, IpHelpersItem]):
            """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""

            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "service_profile": {"type": str},
                "destination": {"type": Destination},
                "source": {"type": Source},
                "_custom_data": {"type": dict},
            }
            service_profile: str | None
            """NAT interface profile."""
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    service_profile: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        service_profile: NAT interface profile.
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
                "_custom_data": {"type": dict},
            }
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: ipv6_prefix
                        valid_lifetime: Infinite or lifetime in seconds.
                        preferred_lifetime: Infinite or lifetime in seconds.
                        no_autoconfig_flag: no_autoconfig_flag
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
                "_custom_data": {"type": dict},
            }
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    source_address: str | None | UndefinedType = Undefined,
                    link_address: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6DhcpRelayDestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        address: DHCP server's IPv6 address.
                        vrf: vrf
                        local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                        source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                        link_address: Override the default link address specified in the relayed DHCP packet.
                        _custom_data: _custom_data

                    """

        class Ipv6DhcpRelayDestinations(AvdIndexedList[str, Ipv6DhcpRelayDestinationsItem]):
            """
            Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
            (`str`).
            """

            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "out": {"type": bool}, "_custom_data": {"type": dict}}
                    boundary: str | None
                    """ACL name or multicast IP subnet."""
                    out: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            boundary: str | None | UndefinedType = Undefined,
                            out: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: ACL name or multicast IP subnet.
                                out: out
                                _custom_data: _custom_data

                            """

                class Boundaries(AvdList[BoundariesItem]):
                    """Subclass of AvdList with `BoundariesItem` items."""

                Boundaries._item_type = BoundariesItem

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "static": {"type": bool}, "_custom_data": {"type": dict}}
                boundaries: Boundaries
                """Subclass of AvdList with `BoundariesItem` items."""
                static: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            boundaries: Subclass of AvdList with `BoundariesItem` items.
                            static: static
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "_custom_data": {"type": dict}}
                    boundary: str | None
                    """ACL name or multicast IP subnet."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, boundary: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: ACL name or multicast IP subnet.
                                _custom_data: _custom_data

                            """

                class Boundaries(AvdList[BoundariesItem]):
                    """Subclass of AvdList with `BoundariesItem` items."""

                Boundaries._item_type = BoundariesItem

                _fields: ClassVar[dict] = {"boundaries": {"type": Boundaries}, "static": {"type": bool}, "_custom_data": {"type": dict}}
                boundaries: Boundaries
                """Subclass of AvdList with `BoundariesItem` items."""
                static: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            boundaries: Subclass of AvdList with `BoundariesItem` items.
                            static: static
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}, "_custom_data": {"type": dict}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password - only type 7 supported."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password - only type 7 supported.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}, "_custom_data": {"type": dict}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: str | None | UndefinedType = Undefined,
                            interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                    "_custom_data": {"type": dict},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            hello: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class MacSecurity(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"profile": {"type": str}, "_custom_data": {"type": dict}}
            profile: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, profile: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    MacSecurity.


                    Subclass of AvdModel.

                    Args:
                        profile: profile
                        _custom_data: _custom_data

                    """

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv4_segment_size": {"type": int},
                "ipv6_segment_size": {"type": int},
                "direction": {"type": str},
                "_custom_data": {"type": dict},
            }
            ipv4_segment_size: int | None
            ipv6_segment_size: int | None
            direction: Literal["egress", "ingress"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_segment_size: int | None | UndefinedType = Undefined,
                    ipv6_segment_size: int | None | UndefinedType = Undefined,
                    direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4_segment_size: ipv4_segment_size
                        ipv6_segment_size: ipv6_segment_size
                        direction: direction
                        _custom_data: _custom_data

                    """

        class ChannelGroup(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "mode": {"type": str}, "_custom_data": {"type": dict}}
            id: int | None
            mode: Literal["on", "active", "passive"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | None | UndefinedType = Undefined,
                    mode: Literal["on", "active", "passive"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ChannelGroup.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        mode: mode
                        _custom_data: _custom_data

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}, "_custom_data": {"type": dict}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    both: Both | UndefinedType = Undefined,
                    level_1: Level1 | UndefinedType = Undefined,
                    level_2: Level2 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Poe(AvdModel):
            """Subclass of AvdModel."""

            class Reboot(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "_custom_data": {"type": dict}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Reboot.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.
                            _custom_data: _custom_data

                        """

            class LinkDown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "power_off_delay": {"type": int}, "_custom_data": {"type": dict}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""
                power_off_delay: int | None
                """
                Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                seconds in EOS.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined,
                        power_off_delay: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LinkDown.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.
                            power_off_delay:
                               Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                               seconds in EOS.
                            _custom_data: _custom_data

                        """

            class Shutdown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "_custom_data": {"type": dict}}
                action: Literal["maintain", "power-off"] | None
                """PoE action for interface."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["maintain", "power-off"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Shutdown.


                        Subclass of AvdModel.

                        Args:
                            action: PoE action for interface.
                            _custom_data: _custom_data

                        """

            class Limit(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"field_class": {"type": int}, "watts": {"type": str}, "fixed": {"type": bool}, "_custom_data": {"type": dict}}
                _field_to_key_map: ClassVar[dict] = {"field_class": "class"}
                _key_to_field_map: ClassVar[dict] = {"class": "field_class"}
                field_class: int | None
                watts: str | None
                fixed: bool | None
                """Set to ignore hardware classification."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        field_class: int | None | UndefinedType = Undefined,
                        watts: str | None | UndefinedType = Undefined,
                        fixed: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Limit.


                        Subclass of AvdModel.

                        Args:
                            field_class: field_class
                            watts: watts
                            fixed: Set to ignore hardware classification.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "disabled": {"type": bool, "default": False},
                "priority": {"type": str},
                "reboot": {"type": Reboot},
                "link_down": {"type": LinkDown},
                "shutdown": {"type": Shutdown},
                "limit": {"type": Limit},
                "negotiation_lldp": {"type": bool},
                "legacy_detect": {"type": bool},
                "_custom_data": {"type": dict},
            }
            disabled: bool
            """
            Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.

            Default value: `False`
            """
            priority: Literal["critical", "high", "medium", "low"] | None
            """Prioritize a port's power in the event that one of the switch's power supplies loses power."""
            reboot: Reboot
            """
            Set the PoE power behavior for a PoE port when the system is rebooted.

            Subclass of AvdModel.
            """
            link_down: LinkDown
            """
            Set the PoE power behavior for a PoE port when the port goes down.

            Subclass of AvdModel.
            """
            shutdown: Shutdown
            """
            Set the PoE power behavior for a PoE port when the port is admin down.

            Subclass of AvdModel.
            """
            limit: Limit
            """
            Override the hardware-negotiated power limit using either wattage or a power class. Note that if
            using a power class, AVD will automatically convert the class value to the wattage value
            corresponding to that power class.

            Subclass of AvdModel.
            """
            negotiation_lldp: bool | None
            """
            Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
            EOS.
            """
            legacy_detect: bool | None
            """
            Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
            can cause false positive detections.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    disabled: bool | UndefinedType = Undefined,
                    priority: Literal["critical", "high", "medium", "low"] | None | UndefinedType = Undefined,
                    reboot: Reboot | UndefinedType = Undefined,
                    link_down: LinkDown | UndefinedType = Undefined,
                    shutdown: Shutdown | UndefinedType = Undefined,
                    limit: Limit | UndefinedType = Undefined,
                    negotiation_lldp: bool | None | UndefinedType = Undefined,
                    legacy_detect: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Poe.


                    Subclass of AvdModel.

                    Args:
                        disabled: Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.
                        priority: Prioritize a port's power in the event that one of the switch's power supplies loses power.
                        reboot:
                           Set the PoE power behavior for a PoE port when the system is rebooted.

                           Subclass of AvdModel.
                        link_down:
                           Set the PoE power behavior for a PoE port when the port goes down.

                           Subclass of AvdModel.
                        shutdown:
                           Set the PoE power behavior for a PoE port when the port is admin down.

                           Subclass of AvdModel.
                        limit:
                           Override the hardware-negotiated power limit using either wattage or a power class. Note that if
                           using a power class, AVD will automatically convert the class value to the wattage value
                           corresponding to that power class.

                           Subclass of AvdModel.
                        negotiation_lldp:
                           Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
                           EOS.
                        legacy_detect:
                           Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
                           can cause false positive detections.
                        _custom_data: _custom_data

                    """

        class Ptp(AvdModel):
            """Subclass of AvdModel."""

            class Announce(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                timeout: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | None | UndefinedType = Undefined,
                        timeout: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Announce.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            timeout: timeout
                            _custom_data: _custom_data

                        """

            class Profile(AvdModel):
                """Subclass of AvdModel."""

                class G82751(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"destination_mac_address": {"type": str}, "_custom_data": {"type": dict}}
                    destination_mac_address: Literal["forwardable", "non-forwardable"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            destination_mac_address: Literal["forwardable", "non-forwardable"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            G82751.


                            Subclass of AvdModel.

                            Args:
                                destination_mac_address: destination_mac_address
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"g8275_1": {"type": G82751}, "_custom_data": {"type": dict}}
                g8275_1: G82751
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, g8275_1: G82751 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Profile.


                        Subclass of AvdModel.

                        Args:
                            g8275_1: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class SyncMessage(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        SyncMessage.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
                "_custom_data": {"type": dict},
            }
            enable: bool | None
            announce: Announce
            """Subclass of AvdModel."""
            delay_req: int | None
            delay_mechanism: Literal["e2e", "p2p"] | None
            profile: Profile
            """Subclass of AvdModel."""
            sync_message: SyncMessage
            """Subclass of AvdModel."""
            role: Literal["master", "dynamic"] | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Literal["ipv4", "ipv6", "layer2"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    announce: Announce | UndefinedType = Undefined,
                    delay_req: int | None | UndefinedType = Undefined,
                    delay_mechanism: Literal["e2e", "p2p"] | None | UndefinedType = Undefined,
                    profile: Profile | UndefinedType = Undefined,
                    sync_message: SyncMessage | UndefinedType = Undefined,
                    role: Literal["master", "dynamic"] | None | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    transport: Literal["ipv4", "ipv6", "layer2"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ptp.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        announce: Subclass of AvdModel.
                        delay_req: delay_req
                        delay_mechanism: delay_mechanism
                        profile: Subclass of AvdModel.
                        sync_message: Subclass of AvdModel.
                        role: role
                        vlan: VLAN can be 'all' or list of vlans as string.
                        transport: transport
                        _custom_data: _custom_data

                    """

        class StormControl(AvdModel):
            """Subclass of AvdModel."""

            class All(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        All.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class Broadcast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Broadcast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class Multicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Multicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class UnknownUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        UnknownUnicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
                "_custom_data": {"type": dict},
            }
            all: All
            """Subclass of AvdModel."""
            broadcast: Broadcast
            """Subclass of AvdModel."""
            multicast: Multicast
            """Subclass of AvdModel."""
            unknown_unicast: UnknownUnicast
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    all: All | UndefinedType = Undefined,
                    broadcast: Broadcast | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StormControl.


                    Subclass of AvdModel.

                    Args:
                        all: Subclass of AvdModel.
                        broadcast: Subclass of AvdModel.
                        multicast: Subclass of AvdModel.
                        unknown_unicast: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "link_status": {"type": bool},
                    "congestion_drops": {"type": bool},
                    "spanning_tree": {"type": bool},
                    "storm_control_discards": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                link_status: bool | None
                congestion_drops: bool | None
                spanning_tree: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        link_status: bool | None | UndefinedType = Undefined,
                        congestion_drops: bool | None | UndefinedType = Undefined,
                        spanning_tree: bool | None | UndefinedType = Undefined,
                        storm_control_discards: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status
                            congestion_drops: congestion_drops
                            spanning_tree: spanning_tree
                            storm_control_discards: Discards due to storm-control.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}, "_custom_data": {"type": dict}}
            event: Event
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Lldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}, "_custom_data": {"type": dict}}
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    transmit: bool | None | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    ztp_vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lldp.


                    Subclass of AvdModel.

                    Args:
                        transmit: transmit
                        receive: receive
                        ztp_vlan: ZTP vlan number.
                        _custom_data: _custom_data

                    """

        class VlanTranslationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "field_from": {"type": str},
                "to": {"type": int},
                "direction": {"type": str, "default": "both"},
                "_custom_data": {"type": dict},
            }
            _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
            _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: Literal["in", "out", "both"]
            """Default value: `"both"`"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    field_from: str | None | UndefinedType = Undefined,
                    to: int | None | UndefinedType = Undefined,
                    direction: Literal["in", "out", "both"] | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslationsItem.


                    Subclass of AvdModel.

                    Args:
                        field_from: List of vlans as string (only one vlan if direction is "both").
                        to: VLAN ID.
                        direction: direction
                        _custom_data: _custom_data

                    """

        class VlanTranslations(AvdList[VlanTranslationsItem]):
            """Subclass of AvdList with `VlanTranslationsItem` items."""

        VlanTranslations._item_type = VlanTranslationsItem

        class Dot1x(AvdModel):
            """Subclass of AvdModel."""

            class Pae(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "_custom_data": {"type": dict}}
                mode: Literal["authenticator"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, mode: Literal["authenticator"] | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Pae.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            _custom_data: _custom_data

                        """

            class AuthenticationFailure(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "allow_vlan": {"type": int}, "_custom_data": {"type": dict}}
                action: Literal["allow", "drop"] | None
                allow_vlan: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["allow", "drop"] | None | UndefinedType = Undefined,
                        allow_vlan: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AuthenticationFailure.


                        Subclass of AvdModel.

                        Args:
                            action: action
                            allow_vlan: allow_vlan
                            _custom_data: _custom_data

                        """

            class HostMode(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"mode": {"type": str}, "multi_host_authenticated": {"type": bool}, "_custom_data": {"type": dict}}
                mode: Literal["multi-host", "single-host"] | None
                multi_host_authenticated: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["multi-host", "single-host"] | None | UndefinedType = Undefined,
                        multi_host_authenticated: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostMode.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            multi_host_authenticated: multi_host_authenticated
                            _custom_data: _custom_data

                        """

            class MacBasedAuthentication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "always": {"type": bool},
                    "host_mode_common": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                always: bool | None
                host_mode_common: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        host_mode_common: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MacBasedAuthentication.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            host_mode_common: host_mode_common
                            _custom_data: _custom_data

                        """

            class Timeout(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "idle_host": {"type": int},
                    "quiet_period": {"type": int},
                    "reauth_period": {"type": str},
                    "reauth_timeout_ignore": {"type": bool},
                    "tx_period": {"type": int},
                    "_custom_data": {"type": dict},
                }
                idle_host: int | None
                quiet_period: int | None
                reauth_period: str | None
                """Value can be 60-4294967295 or 'server'."""
                reauth_timeout_ignore: bool | None
                tx_period: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        idle_host: int | None | UndefinedType = Undefined,
                        quiet_period: int | None | UndefinedType = Undefined,
                        reauth_period: str | None | UndefinedType = Undefined,
                        reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                        tx_period: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Timeout.


                        Subclass of AvdModel.

                        Args:
                            idle_host: idle_host
                            quiet_period: quiet_period
                            reauth_period: Value can be 60-4294967295 or 'server'.
                            reauth_timeout_ignore: reauth_timeout_ignore
                            tx_period: tx_period
                            _custom_data: _custom_data

                        """

            class Unauthorized(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "access_vlan_membership_egress": {"type": bool},
                    "native_vlan_membership_egress": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                access_vlan_membership_egress: bool | None
                native_vlan_membership_egress: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                        native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Unauthorized.


                        Subclass of AvdModel.

                        Args:
                            access_vlan_membership_egress: access_vlan_membership_egress
                            native_vlan_membership_egress: native_vlan_membership_egress
                            _custom_data: _custom_data

                        """

            class Eapol(AvdModel):
                """Subclass of AvdModel."""

                class AuthenticationFailureFallbackMba(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    timeout: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timeout: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AuthenticationFailureFallbackMba.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timeout: timeout
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "disabled": {"type": bool},
                    "authentication_failure_fallback_mba": {"type": AuthenticationFailureFallbackMba},
                    "_custom_data": {"type": dict},
                }
                disabled: bool | None
                authentication_failure_fallback_mba: AuthenticationFailureFallbackMba
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        disabled: bool | None | UndefinedType = Undefined,
                        authentication_failure_fallback_mba: AuthenticationFailureFallbackMba | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Eapol.


                        Subclass of AvdModel.

                        Args:
                            disabled: disabled
                            authentication_failure_fallback_mba: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Aaa(AvdModel):
                """Subclass of AvdModel."""

                class Unresponsive(AvdModel):
                    """Subclass of AvdModel."""

                    class Action(AvdModel):
                        """Subclass of AvdModel."""

                        class CachedResultsTimeout(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}, "_custom_data": {"type": dict}}
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Literal["days", "hours", "minutes", "seconds"]
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    time_duration: int | None | UndefinedType = Undefined,
                                    time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    CachedResultsTimeout.


                                    Subclass of AvdModel.

                                    Args:
                                        time_duration:
                                           Enable caching for a specific duration -
                                           <1-10000>      duration in days
                                           <1-14400000>   duration in
                                           minutes
                                           <1-240000>     duration in hours
                                           <1-864000000>  duration in seconds
                                        time_duration_unit: time_duration_unit
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "traffic_allow_access_list": {"type": str},
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                            "traffic_allow_vlan": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        traffic_allow_access_list: str | None
                        """Name of standard access-list to apply when AAA times out."""
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        """Subclass of AvdModel."""
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive action apply cached-results
                        else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""
                        traffic_allow_vlan: int | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                traffic_allow_access_list: str | None | UndefinedType = Undefined,
                                apply_cached_results: bool | None | UndefinedType = Undefined,
                                cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                                apply_alternate: bool | None | UndefinedType = Undefined,
                                traffic_allow: bool | None | UndefinedType = Undefined,
                                traffic_allow_vlan: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Action.


                                Subclass of AvdModel.

                                Args:
                                    traffic_allow_access_list: Name of standard access-list to apply when AAA times out.
                                    apply_cached_results: Use results from a previous AAA response.
                                    cached_results_timeout: Subclass of AvdModel.
                                    apply_alternate:
                                       Apply alternate action if primary action fails.
                                       eg. aaa unresponsive action apply cached-results
                                       else traffic allow
                                    traffic_allow: Set action for supplicant traffic when AAA times out.
                                    traffic_allow_vlan: traffic_allow_vlan
                                    _custom_data: _custom_data

                                """

                    class PhoneAction(AvdModel):
                        """Subclass of AvdModel."""

                        class CachedResultsTimeout(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"time_duration": {"type": int}, "time_duration_unit": {"type": str}, "_custom_data": {"type": dict}}
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Literal["days", "hours", "minutes", "seconds"]
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    time_duration: int | None | UndefinedType = Undefined,
                                    time_duration_unit: Literal["days", "hours", "minutes", "seconds"] | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    CachedResultsTimeout.


                                    Subclass of AvdModel.

                                    Args:
                                        time_duration:
                                           Enable caching for a specific duration -
                                           <1-10000>      duration in days
                                           <1-14400000>   duration in
                                           minutes
                                           <1-240000>     duration in hours
                                           <1-864000000>  duration in seconds
                                        time_duration_unit: time_duration_unit
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        """Subclass of AvdModel."""
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive phone action apply cached-
                        results else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                apply_cached_results: bool | None | UndefinedType = Undefined,
                                cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                                apply_alternate: bool | None | UndefinedType = Undefined,
                                traffic_allow: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PhoneAction.


                                Subclass of AvdModel.

                                Args:
                                    apply_cached_results: Use results from a previous AAA response.
                                    cached_results_timeout: Subclass of AvdModel.
                                    apply_alternate:
                                       Apply alternate action if primary action fails.
                                       eg. aaa unresponsive phone action apply cached-
                                       results else traffic allow
                                    traffic_allow: Set action for supplicant traffic when AAA times out.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "eap_response": {"type": str},
                        "action": {"type": Action},
                        "phone_action": {"type": PhoneAction},
                        "_custom_data": {"type": dict},
                    }
                    eap_response: Literal["success", "disabled"] | None
                    """EAP response to send. EOS default is `success`."""
                    action: Action
                    """
                    Set action for supplicant when AAA times out.

                    Subclass of AvdModel.
                    """
                    phone_action: PhoneAction
                    """
                    Set action for supplicant when AAA times out.

                    Subclass of AvdModel.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            eap_response: Literal["success", "disabled"] | None | UndefinedType = Undefined,
                            action: Action | UndefinedType = Undefined,
                            phone_action: PhoneAction | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Unresponsive.


                            Subclass of AvdModel.

                            Args:
                                eap_response: EAP response to send. EOS default is `success`.
                                action:
                                   Set action for supplicant when AAA times out.

                                   Subclass of AvdModel.
                                phone_action:
                                   Set action for supplicant when AAA times out.

                                   Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"unresponsive": {"type": Unresponsive}, "_custom_data": {"type": dict}}
                unresponsive: Unresponsive
                """
                Configure AAA timeout options.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, unresponsive: Unresponsive | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Aaa.


                        Subclass of AvdModel.

                        Args:
                            unresponsive:
                               Configure AAA timeout options.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "port_control": {"type": str},
                "port_control_force_authorized_phone": {"type": bool},
                "reauthentication": {"type": bool},
                "pae": {"type": Pae},
                "authentication_failure": {"type": AuthenticationFailure},
                "host_mode": {"type": HostMode},
                "mac_based_authentication": {"type": MacBasedAuthentication},
                "mac_based_access_list": {"type": bool},
                "timeout": {"type": Timeout},
                "reauthorization_request_limit": {"type": int},
                "unauthorized": {"type": Unauthorized},
                "eapol": {"type": Eapol},
                "aaa": {"type": Aaa},
                "_custom_data": {"type": dict},
            }
            port_control: Literal["auto", "force-authorized", "force-unauthorized"] | None
            port_control_force_authorized_phone: bool | None
            reauthentication: bool | None
            pae: Pae
            """Subclass of AvdModel."""
            authentication_failure: AuthenticationFailure
            """Subclass of AvdModel."""
            host_mode: HostMode
            """Subclass of AvdModel."""
            mac_based_authentication: MacBasedAuthentication
            """Subclass of AvdModel."""
            mac_based_access_list: bool | None
            """Operate interface in per-mac access-list mode."""
            timeout: Timeout
            """Subclass of AvdModel."""
            reauthorization_request_limit: int | None
            unauthorized: Unauthorized
            """Subclass of AvdModel."""
            eapol: Eapol
            """Subclass of AvdModel."""
            aaa: Aaa
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    port_control: Literal["auto", "force-authorized", "force-unauthorized"] | None | UndefinedType = Undefined,
                    port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                    reauthentication: bool | None | UndefinedType = Undefined,
                    pae: Pae | UndefinedType = Undefined,
                    authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                    host_mode: HostMode | UndefinedType = Undefined,
                    mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                    mac_based_access_list: bool | None | UndefinedType = Undefined,
                    timeout: Timeout | UndefinedType = Undefined,
                    reauthorization_request_limit: int | None | UndefinedType = Undefined,
                    unauthorized: Unauthorized | UndefinedType = Undefined,
                    eapol: Eapol | UndefinedType = Undefined,
                    aaa: Aaa | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dot1x.


                    Subclass of AvdModel.

                    Args:
                        port_control: port_control
                        port_control_force_authorized_phone: port_control_force_authorized_phone
                        reauthentication: reauthentication
                        pae: Subclass of AvdModel.
                        authentication_failure: Subclass of AvdModel.
                        host_mode: Subclass of AvdModel.
                        mac_based_authentication: Subclass of AvdModel.
                        mac_based_access_list: Operate interface in per-mac access-list mode.
                        timeout: Subclass of AvdModel.
                        reauthorization_request_limit: reauthorization_request_limit
                        unauthorized: Subclass of AvdModel.
                        eapol: Subclass of AvdModel.
                        aaa: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Rate in kbps, pps or percent.
                           Supported options are platform dependent.
                           Examples:  # fmt: skip
                           - "5000 kbps"
                           -
                           "1000 pps"
                           - "20 percent"
                        _custom_data: _custom_data

                    """

        class Qos(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}, "_custom_data": {"type": dict}}
            trust: Literal["dscp", "cos", "disabled"] | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trust: Literal["dscp", "cos", "disabled"] | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    cos: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Qos.


                    Subclass of AvdModel.

                    Args:
                        trust: trust
                        dscp: DSCP value.
                        cos: COS value.
                        _custom_data: _custom_data

                    """

        class PriorityFlowControl(AvdModel):
            """Subclass of AvdModel."""

            class PrioritiesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"priority": {"type": int}, "no_drop": {"type": bool}, "_custom_data": {"type": dict}}
                priority: int
                no_drop: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        priority: int | UndefinedType = Undefined,
                        no_drop: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PrioritiesItem.


                        Subclass of AvdModel.

                        Args:
                            priority: priority
                            no_drop: no_drop
                            _custom_data: _custom_data

                        """

            class Priorities(AvdIndexedList[int, PrioritiesItem]):
                """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""

                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "priorities": {"type": Priorities}, "_custom_data": {"type": dict}}
            enabled: bool | None
            priorities: Priorities
            """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    priorities: Priorities | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PriorityFlowControl.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        priorities: Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`).
                        _custom_data: _custom_data

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
                "_custom_data": {"type": dict},
            }
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier
                        _custom_data: _custom_data

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}, "_custom_data": {"type": dict}}
                input: str | None
                """Policy Based Routing Policy-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Policy Based Routing Policy-map name.
                            _custom_data: _custom_data

                        """

            class Qos(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}, "_custom_data": {"type": dict}}
                input: str
                """Quality of Service Policy-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Qos.


                        Subclass of AvdModel.

                        Args:
                            input: Quality of Service Policy-map name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}, "_custom_data": {"type": dict}}
            pbr: Pbr
            """Subclass of AvdModel."""
            qos: Qos
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    pbr: Pbr | UndefinedType = Undefined,
                    qos: Qos | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.
                        qos: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}, "igp_sync": {"type": bool}, "_custom_data": {"type": dict}}
                interface: bool | None
                igp_sync: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interface: bool | None | UndefinedType = Undefined,
                        igp_sync: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            igp_sync: igp_sync
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}, "_custom_data": {"type": dict}}
            ip: bool | None
            ldp: Ldp
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip: bool | None | UndefinedType = Undefined,
                    ldp: Ldp | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ip: ip
                        ldp: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class LacpTimer(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"mode": {"type": str}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
            mode: Literal["fast", "normal"] | None
            multiplier: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    mode: Literal["fast", "normal"] | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LacpTimer.


                    Subclass of AvdModel.

                    Args:
                        mode: mode
                        multiplier: multiplier
                        _custom_data: _custom_data

                    """

        class Transceiver(AvdModel):
            """Subclass of AvdModel."""

            class Media(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"override": {"type": str}, "_custom_data": {"type": dict}}
                override: str | None
                """Transceiver type."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, override: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Media.


                        Subclass of AvdModel.

                        Args:
                            override: Transceiver type.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"frequency": {"type": str}, "frequency_unit": {"type": str}, "media": {"type": Media}, "_custom_data": {"type": dict}}
            frequency: str | None
            """Transceiver Laser Frequency in GHz (min 190000, max 200000)."""
            frequency_unit: Literal["ghz"] | None
            """Unit of Transceiver Laser Frequency."""
            media: Media
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    frequency: str | None | UndefinedType = Undefined,
                    frequency_unit: Literal["ghz"] | None | UndefinedType = Undefined,
                    media: Media | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Transceiver.


                    Subclass of AvdModel.

                    Args:
                        frequency: Transceiver Laser Frequency in GHz (min 190000, max 200000).
                        frequency_unit: Unit of Transceiver Laser Frequency.
                        media: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TrafficPolicy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"input": {"type": str}, "output": {"type": str}, "_custom_data": {"type": dict}}
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    input: str | None | UndefinedType = Undefined,
                    output: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficPolicy.


                    Subclass of AvdModel.

                    Args:
                        input: Ingress traffic policy.
                        output: Egress traffic policy.
                        _custom_data: _custom_data

                    """

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"session_tracker": {"type": str}, "_custom_data": {"type": dict}}
            session_tracker: str | None
            """Name of session tracker."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, session_tracker: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        session_tracker: Name of session tracker.
                        _custom_data: _custom_data

                    """

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}, "_custom_data": {"type": dict}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                            _custom_data: _custom_data

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            _custom_data: _custom_data

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.
                        _custom_data: _custom_data

                    """

        class Sflow(AvdModel):
            """Subclass of AvdModel."""

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable": {"type": bool}, "unmodified_enable": {"type": bool}, "_custom_data": {"type": dict}}
                enable: bool | None
                unmodified_enable: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enable: bool | None | UndefinedType = Undefined,
                        unmodified_enable: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable: enable
                            unmodified_enable: unmodified_enable
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "egress": {"type": Egress}, "_custom_data": {"type": dict}}
            enable: bool | None
            egress: Egress
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    egress: Egress | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sflow.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        egress: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class SyncE(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "priority": {"type": str}, "_custom_data": {"type": dict}}
            enable: bool | None
            priority: str | None
            """
            The priority is used to influence the reference clock selection. The EOS default priority is 127.
            The priority can be configured to any integer between 1-255, or set to `disabled`.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    priority: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SyncE.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        priority:
                           The priority is used to influence the reference clock selection. The EOS default priority is 127.
                           The priority can be configured to any integer between 1-255, or set to `disabled`.
                        _custom_data: _custom_data

                    """

        class UcTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Indicate the units to be used for the threshold values."""
                        min: int
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Indicate the units to be used for the threshold values.
                                    min: Set the random-detect ECN minimum-threshold.
                                    max: Set the random-detect ECN maximum-threshold.
                                    max_probability: Set the random-detect ECN max-mark-probability.
                                    weight: Set the random-detect ECN weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: bool | None | UndefinedType = Undefined,
                            threshold: Threshold | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "_custom_data": {"type": dict}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"id": {"type": int}, "random_detect": {"type": RandomDetect}, "_custom_data": {"type": dict}}
            id: int
            """TX-Queue ID."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    UcTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        random_detect: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class UcTxQueues(AvdIndexedList[int, UcTxQueuesItem]):
            """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class TxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Indicate the units to be used for the threshold values."""
                        min: int | None
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | None | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Indicate the units to be used for the threshold values.
                                    min: Set the random-detect ECN minimum-threshold.
                                    max: Set the random-detect ECN maximum-threshold.
                                    max_probability: Set the random-detect ECN max-mark-probability.
                                    weight: Set the random-detect ECN weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: bool | None | UndefinedType = Undefined,
                            threshold: Threshold | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "_custom_data": {"type": dict}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, ecn: Ecn | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"id": {"type": int}, "random_detect": {"type": RandomDetect}, "_custom_data": {"type": dict}}
            id: int
            """TX-Queue ID."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        random_detect: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TxQueues(AvdIndexedList[int, TxQueuesItem]):
            """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class VrrpIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Advertisement(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                """Interval in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Advertisement.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in seconds.
                            _custom_data: _custom_data

                        """

            class Preempt(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"minimum": {"type": int}, "reload": {"type": int}, "_custom_data": {"type": dict}}
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            minimum: int | None | UndefinedType = Undefined,
                            reload: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                minimum: Minimum preempt delay in seconds.
                                reload: Reload preempt delay in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "delay": {"type": Delay}, "_custom_data": {"type": dict}}
                enabled: bool
                delay: Delay
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        delay: Delay | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Preempt.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            delay: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"reload": {"type": int}, "_custom_data": {"type": dict}}
                    reload: int | None
                    """Delay after reload in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, reload: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                reload: Delay after reload in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}, "_custom_data": {"type": dict}}
                delay: Delay
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class TrackedObjectItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}, "_custom_data": {"type": dict}}
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        decrement: int | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackedObjectItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracked object name.
                            decrement: Decrement VRRP priority by 1-254.
                            shutdown: shutdown
                            _custom_data: _custom_data

                        """

            class TrackedObject(AvdIndexedList[str, TrackedObjectItem]):
                """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"address": {"type": str}, "version": {"type": int}, "_custom_data": {"type": dict}}
                address: str
                """Virtual IPv4 address."""
                version: Literal[2, 3] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        version: Literal[2, 3] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv4 address.
                            version: version
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"address": {"type": str}, "_custom_data": {"type": dict}}
                address: str
                """Virtual IPv6 address."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv6 address.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
                "_custom_data": {"type": dict},
            }
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            """Subclass of AvdModel."""
            preempt: Preempt
            """Subclass of AvdModel."""
            timers: Timers
            """Subclass of AvdModel."""
            tracked_object: TrackedObject
            """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    priority_level: int | None | UndefinedType = Undefined,
                    advertisement: Advertisement | UndefinedType = Undefined,
                    preempt: Preempt | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    tracked_object: TrackedObject | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrrpIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: VRID.
                        priority_level: Instance priority.
                        advertisement: Subclass of AvdModel.
                        preempt: Subclass of AvdModel.
                        timers: Subclass of AvdModel.
                        tracked_object: Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`).
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class VrrpIds(AvdIndexedList[int, VrrpIdsItem]):
            """Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class Switchport(AvdModel):
            """Subclass of AvdModel."""

            class Trunk(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": Groups},
                    "_custom_data": {"type": dict},
                }
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs.
                Warning: This should not be combined with
                `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `ethernet_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                """
                groups: Groups
                """
                Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.


                Subclass of
                AvdList with `str` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        native_vlan_tag: bool | None | UndefinedType = Undefined,
                        private_vlan_secondary: bool | None | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Trunk.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan:
                               VLAN ID or range(s) of VLAN IDs.
                               Warning: This should not be combined with
                               `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                            native_vlan:
                               Set native VLAN when interface is in trunking mode.
                               Warning: This should not be combined with
                               `ethernet_interfaces[].native_vlan`.
                            native_vlan_tag:
                               If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                               Warning: This
                               should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                            private_vlan_secondary:
                               Enable secondary VLAN mapping for a private vlan.
                               Warning: This should not be combined with
                               `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                            groups:
                               Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.


                               Subclass of
                               AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class Phone(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vlan": {"type": int}, "trunk": {"type": str}, "_custom_data": {"type": dict}}
                vlan: int | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`."""
                trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        vlan: int | None | UndefinedType = Undefined,
                        trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Phone.


                        Subclass of AvdModel.

                        Args:
                            vlan: Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`.
                            trunk: Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`.
                            _custom_data: _custom_data

                        """

            class Dot1q(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ethertype": {"type": int}, "vlan_tag": {"type": str}, "_custom_data": {"type": dict}}
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Literal["disallowed", "required"] | None
                """Allow/disallow VLAN tagged frames."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ethertype: int | None | UndefinedType = Undefined,
                        vlan_tag: Literal["disallowed", "required"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.


                        Subclass of AvdModel.

                        Args:
                            ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                            vlan_tag: Allow/disallow VLAN tagged frames.
                            _custom_data: _custom_data

                        """

            class VlanTranslations(AvdModel):
                """Subclass of AvdModel."""

                class DirectionInItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionInItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                _custom_data: _custom_data

                            """

                class DirectionIn(AvdList[DirectionInItem]):
                    """Subclass of AvdList with `DirectionInItem` items."""

                DirectionIn._item_type = DirectionInItem

                class DirectionOutItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                            inner_vlan_to: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOutItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel_to:
                                   VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                                   This takes precedence over `to` and
                                   `inner_vlan_to`.
                                inner_vlan_to: Inner VLAN ID to map to.
                                _custom_data: _custom_data

                            """

                class DirectionOut(AvdList[DirectionOutItem]):
                    """Subclass of AvdList with `DirectionOutItem` items."""

                DirectionOut._item_type = DirectionOutItem

                class DirectionBothItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            network: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionBothItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                network:
                                   Enable use of network-side VLAN ID.
                                   This setting can only be enabled when `inner_vlan_from` is
                                   defined.
                                _custom_data: _custom_data

                            """

                class DirectionBoth(AvdList[DirectionBothItem]):
                    """Subclass of AvdList with `DirectionBothItem` items."""

                DirectionBoth._item_type = DirectionBothItem

                _fields: ClassVar[dict] = {
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": DirectionIn},
                    "direction_out": {"type": DirectionOut},
                    "direction_both": {"type": DirectionBoth},
                    "_custom_data": {"type": dict},
                }
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: DirectionIn
                """
                Map ingress traffic only.

                Subclass of AvdList with `DirectionInItem` items.
                """
                direction_out: DirectionOut
                """
                Map egress traffic only.

                Subclass of AvdList with `DirectionOutItem` items.
                """
                direction_both: DirectionBoth
                """
                Map both egress and ingress traffic.

                Subclass of AvdList with `DirectionBothItem` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        in_required: bool | None | UndefinedType = Undefined,
                        out_required: bool | None | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        direction_both: DirectionBoth | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlanTranslations.


                        Subclass of AvdModel.

                        Args:
                            in_required: Drop the ingress traffic that do not match any VLAN mapping.
                            out_required: Drop the egress traffic that do not match any VLAN mapping.
                            direction_in:
                               Map ingress traffic only.

                               Subclass of AvdList with `DirectionInItem` items.
                            direction_out:
                               Map egress traffic only.

                               Subclass of AvdList with `DirectionOutItem` items.
                            direction_both:
                               Map both egress and ingress traffic.

                               Subclass of AvdList with `DirectionBothItem` items.
                            _custom_data: _custom_data

                        """

            class BackupLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": str}, "prefer_vlan": {"type": str}, "_custom_data": {"type": dict}}
                interface: str | None
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interface: str | None | UndefinedType = Undefined,
                        prefer_vlan: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BackupLink.


                        Subclass of AvdModel.

                        Args:
                            interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                            prefer_vlan: VLANs to carry on the backup interface (1-4094).
                            _custom_data: _custom_data

                        """

            class Backup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                    "_custom_data": {"type": dict},
                }
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dest_macaddr: str | None | UndefinedType = Undefined,
                        initial_mac_move_delay: int | None | UndefinedType = Undefined,
                        mac_move_burst: int | None | UndefinedType = Undefined,
                        mac_move_burst_interval: int | None | UndefinedType = Undefined,
                        preemption_delay: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Backup.


                        Subclass of AvdModel.

                        Args:
                            dest_macaddr:
                               Destination MAC address for MAC move updates.
                               The mac address should be multicast or broadcast.
                               Example: 01:00:00:00:00:00
                            initial_mac_move_delay: Initial MAC move delay in milliseconds.
                            mac_move_burst: Size of MAC move bursts.
                            mac_move_burst_interval: MAC move burst interval in milliseconds.
                            preemption_delay: Preemption delay in milliseconds.
                            _custom_data: _custom_data

                        """

            class PortSecurity(AvdModel):
                """Subclass of AvdModel."""

                class MacAddressMaximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"disabled": {"type": bool}, "limit": {"type": int}, "_custom_data": {"type": dict}}
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            disabled: bool | None | UndefinedType = Undefined,
                            limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MacAddressMaximum.


                            Subclass of AvdModel.

                            Args:
                                disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                                limit: MAC address limit.
                                _custom_data: _custom_data

                            """

                class Violation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "protect_log": {"type": bool}, "_custom_data": {"type": dict}}
                    mode: Literal["shutdown", "protect"] | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mode: Literal["shutdown", "protect"] | None | UndefinedType = Undefined,
                            protect_log: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Violation.


                            Subclass of AvdModel.

                            Args:
                                mode: Configure port security mode.
                                protect_log: Log new addresses seen after limit is reached in protect mode.
                                _custom_data: _custom_data

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"range": {"type": str}, "mac_address_maximum": {"type": int}, "_custom_data": {"type": dict}}
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            range: str | UndefinedType = Undefined,
                            mac_address_maximum: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                range:
                                   VLAN ID or range(s) of VLAN IDs, <1-4094>.
                                   Example:  # fmt: skip
                                     - 3
                                     - 1,3
                                     - 1-10
                                mac_address_maximum: mac_address_maximum
                                _custom_data: _custom_data

                            """

                class Vlans(AvdIndexedList[str, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """
                Maximum number of MAC addresses allowed on the interface.

                Subclass of AvdModel.
                """
                violation: Violation
                """
                Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                Subclass of AvdModel.
                """
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                        violation: Violation | UndefinedType = Undefined,
                        vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortSecurity.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            mac_address_maximum:
                               Maximum number of MAC addresses allowed on the interface.

                               Subclass of AvdModel.
                            violation:
                               Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                               Subclass of AvdModel.
                            vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`).
                            _custom_data: _custom_data

                        """

            class Tap(AvdModel):
                """Subclass of AvdModel."""

                class Default(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class NexthopGroups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    NexthopGroups._item_type = str

                    _fields: ClassVar[dict] = {
                        "groups": {"type": Groups},
                        "interfaces": {"type": Interfaces},
                        "nexthop_groups": {"type": NexthopGroups},
                        "_custom_data": {"type": dict},
                    }
                    groups: Groups
                    """
                    Tap group names for the interface.

                    Subclass of AvdList with `str` items.
                    """
                    interfaces: Interfaces
                    """
                    Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                    Subclass of AvdList
                    with `str` items.
                    """
                    nexthop_groups: NexthopGroups
                    """
                    Default nexthop-group names.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            groups: Groups | UndefinedType = Undefined,
                            interfaces: Interfaces | UndefinedType = Undefined,
                            nexthop_groups: NexthopGroups | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Default.


                            Subclass of AvdModel.

                            Args:
                                groups:
                                   Tap group names for the interface.

                                   Subclass of AvdList with `str` items.
                                interfaces:
                                   Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                                   Subclass of AvdList
                                   with `str` items.
                                nexthop_groups:
                                   Default nexthop-group names.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "inner_vlan": {"type": int}, "_custom_data": {"type": dict}}
                    id: int | None
                    """Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535)."""
                    inner_vlan: int | None
                    """Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094)."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | None | UndefinedType = Undefined,
                            inner_vlan: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                id: Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535).
                                inner_vlan: Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094).
                                _custom_data: _custom_data

                            """

                class Truncation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    size: int | None
                    """Ingress packet truncation size in bytes."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Truncation.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                size: Ingress packet truncation size in bytes.
                                _custom_data: _custom_data

                            """

                class MacAddress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}, "_custom_data": {"type": dict}}
                    source: str | None
                    """MAC address for the source."""
                    destination: str | None
                    """MAC address for the destination."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source: str | None | UndefinedType = Undefined,
                            destination: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MacAddress.


                            Subclass of AvdModel.

                            Args:
                                source: MAC address for the source.
                                destination: MAC address for the destination.
                                _custom_data: _custom_data

                            """

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    class Gre(AvdModel):
                        """Subclass of AvdModel."""

                        class ProtocolsItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "protocol": {"type": str},
                                "strip": {"type": bool},
                                "feature_header_length": {"type": int},
                                "re_encapsulation_ethernet_header": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            protocol: str
                            """
                            Protocol type in GRE header.
                            Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                            "0x0".
                            """
                            strip: bool | None
                            """This is a required key to strip GRE encapsulation header with protocols."""
                            feature_header_length: int | None
                            """
                            Feature header length in bytes.
                            Note: This setting does not appear in the EOS running-config for
                            protocol 0x0.
                            """
                            re_encapsulation_ethernet_header: bool | None
                            """
                            Extra ethernet header to prepend to the terminated packet.
                            Note: This setting does not appear in the
                            EOS running-config for protocol 0x0.
                            """
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    protocol: str | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    feature_header_length: int | None | UndefinedType = Undefined,
                                    re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    ProtocolsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        protocol:
                                           Protocol type in GRE header.
                                           Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                           "0x0".
                                        strip: This is a required key to strip GRE encapsulation header with protocols.
                                        feature_header_length:
                                           Feature header length in bytes.
                                           Note: This setting does not appear in the EOS running-config for
                                           protocol 0x0.
                                        re_encapsulation_ethernet_header:
                                           Extra ethernet header to prepend to the terminated packet.
                                           Note: This setting does not appear in the
                                           EOS running-config for protocol 0x0.
                                        _custom_data: _custom_data

                                    """

                        class Protocols(AvdIndexedList[str, ProtocolsItem]):
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            _primary_key: ClassVar[str] = "protocol"

                        Protocols._item_type = ProtocolsItem

                        class DestinationsItem(AvdModel):
                            """Subclass of AvdModel."""

                            class ProtocolsItem(AvdModel):
                                """Subclass of AvdModel."""

                                _fields: ClassVar[dict] = {
                                    "protocol": {"type": str},
                                    "strip": {"type": bool},
                                    "feature_header_length": {"type": int},
                                    "re_encapsulation_ethernet_header": {"type": bool},
                                    "_custom_data": {"type": dict},
                                }
                                protocol: str
                                """
                                Protocol type in GRE header.
                                Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                "0x0".
                                """
                                strip: bool | None
                                """This is a required key to strip GRE encapsulation header for specific destination with protocols."""
                                feature_header_length: int | None
                                """
                                Feature header length in bytes.
                                Note: This setting does not appear in the EOS running-config for
                                protocol 0x0.
                                """
                                re_encapsulation_ethernet_header: bool | None
                                """
                                Extra ethernet header to prepend to the terminated packet.
                                Note: This setting does not appear in the
                                EOS running-config for protocol 0x0.
                                """
                                _custom_data: dict[str, Any]

                                if TYPE_CHECKING:

                                    def __init__(
                                        self,
                                        *,
                                        protocol: str | UndefinedType = Undefined,
                                        strip: bool | None | UndefinedType = Undefined,
                                        feature_header_length: int | None | UndefinedType = Undefined,
                                        re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        ProtocolsItem.


                                        Subclass of AvdModel.

                                        Args:
                                            protocol:
                                               Protocol type in GRE header.
                                               Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                               "0x0".
                                            strip: This is a required key to strip GRE encapsulation header for specific destination with protocols.
                                            feature_header_length:
                                               Feature header length in bytes.
                                               Note: This setting does not appear in the EOS running-config for
                                               protocol 0x0.
                                            re_encapsulation_ethernet_header:
                                               Extra ethernet header to prepend to the terminated packet.
                                               Note: This setting does not appear in the
                                               EOS running-config for protocol 0x0.
                                            _custom_data: _custom_data

                                        """

                            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                                _primary_key: ClassVar[str] = "protocol"

                            Protocols._item_type = ProtocolsItem

                            _fields: ClassVar[dict] = {
                                "destination": {"type": str},
                                "source": {"type": str},
                                "strip": {"type": bool},
                                "protocols": {"type": Protocols},
                                "_custom_data": {"type": dict},
                            }
                            destination: str
                            """Destination IP address of tunnel packets."""
                            source: str | None
                            """
                            Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                            GRE packet that matches the `destination` is terminated.
                            """
                            strip: bool | None
                            """Strip GRE encapsulation header for specific destination."""
                            protocols: Protocols
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    destination: str | UndefinedType = Undefined,
                                    source: str | None | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    protocols: Protocols | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DestinationsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        destination: Destination IP address of tunnel packets.
                                        source:
                                           Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                                           GRE packet that matches the `destination` is terminated.
                                        strip: Strip GRE encapsulation header for specific destination.
                                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).
                                        _custom_data: _custom_data

                                    """

                        class Destinations(AvdIndexedList[str, DestinationsItem]):
                            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                            _primary_key: ClassVar[str] = "destination"

                        Destinations._item_type = DestinationsItem

                        _fields: ClassVar[dict] = {
                            "strip": {"type": bool},
                            "protocols": {"type": Protocols},
                            "destinations": {"type": Destinations},
                            "_custom_data": {"type": dict},
                        }
                        strip: bool | None
                        """Strip GRE encapsulation header for all GRE tunnels."""
                        protocols: Protocols
                        """
                        Protocols for all destinations; destination-specific protocols should be set under the
                        `destinations[].protocols` key.

                        Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                        is `protocol` (`str`).
                        """
                        destinations: Destinations
                        """
                        In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                        mutually exclusive.

                        Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                        `destination` (`str`).
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                strip: bool | None | UndefinedType = Undefined,
                                protocols: Protocols | UndefinedType = Undefined,
                                destinations: Destinations | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Gre.


                                Subclass of AvdModel.

                                Args:
                                    strip: Strip GRE encapsulation header for all GRE tunnels.
                                    protocols:
                                       Protocols for all destinations; destination-specific protocols should be set under the
                                       `destinations[].protocols` key.

                                       Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                                       is `protocol` (`str`).
                                    destinations:
                                       In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                                       mutually exclusive.

                                       Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                                       `destination` (`str`).
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"vxlan_strip": {"type": bool}, "gre": {"type": Gre}, "_custom_data": {"type": dict}}
                    vxlan_strip: bool | None
                    """
                    Strip VXLAN encapsulation header.
                    `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                    exclusive.
                    `mpls_pop_all` takes precedence.
                    """
                    gre: Gre
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vxlan_strip: bool | None | UndefinedType = Undefined,
                            gre: Gre | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                vxlan_strip:
                                   Strip VXLAN encapsulation header.
                                   `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                                   exclusive.
                                   `mpls_pop_all` takes precedence.
                                gre: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "default": {"type": Default},
                    "identity": {"type": Identity},
                    "mpls_pop_all": {"type": bool},
                    "native_vlan": {"type": int},
                    "truncation": {"type": Truncation},
                    "mac_address": {"type": MacAddress},
                    "encapsulation": {"type": Encapsulation},
                    "_custom_data": {"type": dict},
                }
                allowed_vlan: str | None
                """VLAN ID or range(s) of VLAN IDs within range 1-4094."""
                default: Default
                """
                Default tap destination config.

                Subclass of AvdModel.
                """
                identity: Identity
                """Subclass of AvdModel."""
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                native_vlan: int | None
                """Native VLAN ID when interface is in tap mode."""
                truncation: Truncation
                """Subclass of AvdModel."""
                mac_address: MacAddress
                """Subclass of AvdModel."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        default: Default | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        truncation: Truncation | UndefinedType = Undefined,
                        mac_address: MacAddress | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tap.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan: VLAN ID or range(s) of VLAN IDs within range 1-4094.
                            default:
                               Default tap destination config.

                               Subclass of AvdModel.
                            identity: Subclass of AvdModel.
                            mpls_pop_all: Pop all MPLS labels.
                            native_vlan: Native VLAN ID when interface is in tap mode.
                            truncation: Subclass of AvdModel.
                            mac_address: Subclass of AvdModel.
                            encapsulation: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Tool(AvdModel):
                """Subclass of AvdModel."""

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"dot1br_strip": {"type": bool}, "vn_tag_strip": {"type": bool}, "_custom_data": {"type": dict}}
                    dot1br_strip: bool | None
                    """Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS."""
                    vn_tag_strip: bool | None
                    """Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dot1br_strip: bool | None | UndefinedType = Undefined,
                            vn_tag_strip: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                dot1br_strip: Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS.
                                vn_tag_strip: Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS.
                                _custom_data: _custom_data

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "tag": {"type": str},
                        "dot1q_dzgre_source": {"type": str},
                        "qinq_dzgre_source": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    tag: Literal["dot1q", "qinq"] | None
                    dot1q_dzgre_source: Literal["policy", "port"] | None
                    qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            tag: Literal["dot1q", "qinq"] | None | UndefinedType = Undefined,
                            dot1q_dzgre_source: Literal["policy", "port"] | None | UndefinedType = Undefined,
                            qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                tag: tag
                                dot1q_dzgre_source: dot1q_dzgre_source
                                qinq_dzgre_source: qinq_dzgre_source
                                _custom_data: _custom_data

                            """

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "mpls_pop_all": {"type": bool},
                    "encapsulation": {"type": Encapsulation},
                    "allowed_vlan": {"type": str},
                    "identity": {"type": Identity},
                    "groups": {"type": Groups},
                    "dot1q_remove_outer_vlan_tag": {"type": str},
                    "_custom_data": {"type": dict},
                }
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                allowed_vlan: str | None
                """VLAN ID or range of VLAN IDs within range 1-4094."""
                identity: Identity
                """Subclass of AvdModel."""
                groups: Groups
                """
                Tool groups for the interface.

                Subclass of AvdList with `str` items.
                """
                dot1q_remove_outer_vlan_tag: str | None
                """
                Indices of vlan tags to be removed.
                Range: 1-2
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        dot1q_remove_outer_vlan_tag: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tool.


                        Subclass of AvdModel.

                        Args:
                            mpls_pop_all: Pop all MPLS labels.
                            encapsulation: Subclass of AvdModel.
                            allowed_vlan: VLAN ID or range of VLAN IDs within range 1-4094.
                            identity: Subclass of AvdModel.
                            groups:
                               Tool groups for the interface.

                               Subclass of AvdList with `str` items.
                            dot1q_remove_outer_vlan_tag:
                               Indices of vlan tags to be removed.
                               Range: 1-2
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
                "tap": {"type": Tap},
                "tool": {"type": Tool},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            """Warning: This should not be combined with `ethernet_interfaces[].type = routed`."""
            mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
            """Warning: This should not be combined with `ethernet_interfaces[].mode`."""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
            """
            trunk: Trunk
            """Subclass of AvdModel."""
            phone: Phone
            """
            Warning: This should not be combined with `ethernet_interfaces[].phone`.

            Subclass of AvdModel.
            """
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `ethernet_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            """Subclass of AvdModel."""
            source_interface: Literal["tx", "tx multicast"] | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `ethernet_interfaces[].vlan_translations`.

            Subclass of AvdModel.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            """Subclass of AvdModel."""
            backup: Backup
            """
            The `backup_link` is required for this setting.

            Subclass of AvdModel.
            """
            port_security: PortSecurity
            """Subclass of AvdModel."""
            tap: Tap
            """
            In tap mode, the interface operates as a tap port.
            Tap ports receive traffic for replication on one
            or more tool ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            tool: Tool
            """
            In tool mode, the interface operates as a tool port.
            Tool ports replicate traffic received by tap
            ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                    access_vlan: int | None | UndefinedType = Undefined,
                    trunk: Trunk | UndefinedType = Undefined,
                    phone: Phone | UndefinedType = Undefined,
                    pvlan_mapping: str | None | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    source_interface: Literal["tx", "tx multicast"] | None | UndefinedType = Undefined,
                    vlan_translations: VlanTranslations | UndefinedType = Undefined,
                    vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                    backup_link: BackupLink | UndefinedType = Undefined,
                    backup: Backup | UndefinedType = Undefined,
                    port_security: PortSecurity | UndefinedType = Undefined,
                    tap: Tap | UndefinedType = Undefined,
                    tool: Tool | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Switchport.


                    Subclass of AvdModel.

                    Args:
                        enabled: Warning: This should not be combined with `ethernet_interfaces[].type = routed`.
                        mode: Warning: This should not be combined with `ethernet_interfaces[].mode`.
                        access_vlan:
                           Set VLAN when interface is in access mode.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
                        trunk: Subclass of AvdModel.
                        phone:
                           Warning: This should not be combined with `ethernet_interfaces[].phone`.

                           Subclass of AvdModel.
                        pvlan_mapping:
                           Secondary VLAN IDs of the private VLAN mapping.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].pvlan_mapping`.
                        dot1q: Subclass of AvdModel.
                        source_interface:
                           tx: Allow bridged traffic to go out of the source interface.
                           tx multicast: Allow multicast traffic
                           only to go out of the source interface.
                        vlan_translations:
                           VLAN Translation mappings.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].vlan_translations`.

                           Subclass of AvdModel.
                        vlan_forwarding_accept_all: vlan_forwarding_accept_all
                        backup_link: Subclass of AvdModel.
                        backup:
                           The `backup_link` is required for this setting.

                           Subclass of AvdModel.
                        port_security: Subclass of AvdModel.
                        tap:
                           In tap mode, the interface operates as a tap port.
                           Tap ports receive traffic for replication on one
                           or more tool ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        tool:
                           In tool mode, the interface operates as a tool port.
                           Tool ports replicate traffic received by tap
                           ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TrafficEngineering(AvdModel):
            """Subclass of AvdModel."""

            class AdministrativeGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            AdministrativeGroups._item_type = str

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_groups": {"type": AdministrativeGroups}, "_custom_data": {"type": dict}}
            enabled: bool | None
            """Whether to enable traffic-engineering on this interface."""
            administrative_groups: AdministrativeGroups
            """
            List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
            integers 0-127.

            Subclass of AvdList with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    administrative_groups: AdministrativeGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficEngineering.


                    Subclass of AvdModel.

                    Args:
                        enabled: Whether to enable traffic-engineering on this interface.
                        administrative_groups:
                           List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
                           integers 0-127.

                           Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "load_interval": {"type": int},
            "speed": {"type": str},
            "mtu": {"type": int},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "mode": {"type": str},
            "phone": {"type": Phone},
            "l2_protocol": {"type": L2Protocol},
            "mac_timestamp": {"type": str},
            "trunk_groups": {"type": TrunkGroups},
            "type": {"type": str},
            "snmp_trap_link_change": {"type": bool},
            "address_locking": {"type": AddressLocking},
            "flowcontrol": {"type": Flowcontrol},
            "vrf": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "error_correction_encoding": {"type": ErrorCorrectionEncoding},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "link_tracking": {"type": LinkTracking},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "dhcp_client_accept_default_route": {"type": bool},
            "dhcp_server_ipv4": {"type": bool},
            "dhcp_server_ipv6": {"type": bool},
            "ip_helpers": {"type": IpHelpers},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "mac_security": {"type": MacSecurity},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "channel_group": {"type": ChannelGroup},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "isis_authentication": {"type": IsisAuthentication},
            "poe": {"type": Poe},
            "ptp": {"type": Ptp},
            "profile": {"type": str},
            "storm_control": {"type": StormControl},
            "logging": {"type": Logging},
            "lldp": {"type": Lldp},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": VlanTranslations},
            "dot1x": {"type": Dot1x},
            "service_profile": {"type": str},
            "shape": {"type": Shape},
            "qos": {"type": Qos},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "priority_flow_control": {"type": PriorityFlowControl},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "lacp_timer": {"type": LacpTimer},
            "lacp_port_priority": {"type": int},
            "transceiver": {"type": Transceiver},
            "ip_proxy_arp": {"type": bool},
            "traffic_policy": {"type": TrafficPolicy},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "sync_e": {"type": SyncE},
            "port_profile": {"type": str},
            "uc_tx_queues": {"type": UcTxQueues},
            "tx_queues": {"type": TxQueues},
            "vrrp_ids": {"type": VrrpIds},
            "validate_state": {"type": bool},
            "validate_lldp": {"type": bool},
            "switchport": {"type": Switchport},
            "traffic_engineering": {"type": TrafficEngineering},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        description: str | None
        shutdown: bool | None
        load_interval: int | None
        """Interval in seconds for updating interface counters."""
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        native_vlan: int | None
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
        phone: Phone
        """Subclass of AvdModel."""
        l2_protocol: L2Protocol
        """Subclass of AvdModel."""
        mac_timestamp: Literal["before-fcs", "replace-fcs", "header"] | None
        """
        header: Insert timestamp in ethernet header. Supported on platforms like 7500E/R and 7280E/R.
        before-fcs: Insert timestamp before fcs field. Supported on platforms like 7150.
        replace-fcs:
        Replace fcs field with timestamp.
        """
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        type: Literal["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"] | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        The `type = switched/routed` should not be combined with `switchport`.
        """
        snmp_trap_link_change: bool | None
        address_locking: AddressLocking
        """Subclass of AvdModel."""
        flowcontrol: Flowcontrol
        """Subclass of AvdModel."""
        vrf: str | None
        """VRF name."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        error_correction_encoding: ErrorCorrectionEncoding
        """Subclass of AvdModel."""
        link_tracking_groups: LinkTrackingGroups
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
        link_tracking: LinkTracking
        """Subclass of AvdModel."""
        evpn_ethernet_segment: EvpnEthernetSegment
        """Subclass of AvdModel."""
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.

        Subclass of AvdModel.
        """
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        Subclass of AvdModel.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        ip_address: str | None
        """IPv4 address/mask or "dhcp"."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        dhcp_client_accept_default_route: bool | None
        """Install default-route obtained via DHCP."""
        dhcp_server_ipv4: bool | None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None
        """Enable IPv6 DHCP server."""
        ip_helpers: IpHelpers
        """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""
        ip_nat: IpNat
        """Subclass of AvdModel."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        """
        Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
        (`str`).
        """
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        multicast: Multicast
        """
        Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
        of both.

        Subclass of AvdModel.
        """
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password - only type 7 supported."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""
        pim: Pim
        """Subclass of AvdModel."""
        mac_security: MacSecurity
        """Subclass of AvdModel."""
        tcp_mss_ceiling: TcpMssCeiling
        """
        The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
        of
        TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.

        Subclass of
        AvdModel.
        """
        channel_group: ChannelGroup
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None
        isis_hello_padding: bool | None
        isis_authentication_mode: Literal["text", "md5"] | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        isis_authentication: IsisAuthentication
        """
        This key should not be mixed with ethernet_interfaces[].isis_authentication_mode or
        ethernet_interfaces[].isis_authentication_key.

        Subclass of AvdModel.
        """
        poe: Poe
        """Subclass of AvdModel."""
        ptp: Ptp
        """Subclass of AvdModel."""
        profile: str | None
        """Interface profile."""
        storm_control: StormControl
        """Subclass of AvdModel."""
        logging: Logging
        """Subclass of AvdModel."""
        lldp: Lldp
        """Subclass of AvdModel."""
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: VlanTranslations
        """Subclass of AvdList with `VlanTranslationsItem` items."""
        dot1x: Dot1x
        """
        802.1x

        Subclass of AvdModel.
        """
        service_profile: str | None
        """QOS profile."""
        shape: Shape
        """Subclass of AvdModel."""
        qos: Qos
        """Subclass of AvdModel."""
        spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_guard: Literal["loop", "root", "disabled"] | None
        spanning_tree_portfast: Literal["edge", "network"] | None
        vmtracer: bool | None
        priority_flow_control: PriorityFlowControl
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        mpls: Mpls
        """Subclass of AvdModel."""
        lacp_timer: LacpTimer
        """Subclass of AvdModel."""
        lacp_port_priority: int | None
        transceiver: Transceiver
        """Subclass of AvdModel."""
        ip_proxy_arp: bool | None
        traffic_policy: TrafficPolicy
        """Subclass of AvdModel."""
        bgp: Bgp
        """Subclass of AvdModel."""
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        """Subclass of AvdModel."""
        sync_e: SyncE
        """Subclass of AvdModel."""
        port_profile: str | None
        """Key only used for documentation or validation purposes."""
        uc_tx_queues: UcTxQueues
        """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""
        tx_queues: TxQueues
        """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""
        vrrp_ids: VrrpIds
        """
        VRRP model.

        Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
        """
        validate_state: bool | None
        """
        Set to false to disable interface state and LLDP topology validation performed by the
        `eos_validate_state` role.
        """
        validate_lldp: bool | None
        """Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role."""
        switchport: Switchport
        """
        This should not be combined with `ethernet_interfaces[].type = switched/routed`.

        Subclass of
        AvdModel.
        """
        traffic_engineering: TrafficEngineering
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                load_interval: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                l2_mtu: int | None | UndefinedType = Undefined,
                l2_mru: int | None | UndefinedType = Undefined,
                vlans: str | None | UndefinedType = Undefined,
                native_vlan: int | None | UndefinedType = Undefined,
                native_vlan_tag: bool | None | UndefinedType = Undefined,
                mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                l2_protocol: L2Protocol | UndefinedType = Undefined,
                mac_timestamp: Literal["before-fcs", "replace-fcs", "header"] | None | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                type: Literal["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"] | None | UndefinedType = Undefined,
                snmp_trap_link_change: bool | None | UndefinedType = Undefined,
                address_locking: AddressLocking | UndefinedType = Undefined,
                flowcontrol: Flowcontrol | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                error_correction_encoding: ErrorCorrectionEncoding | UndefinedType = Undefined,
                link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
                link_tracking: LinkTracking | UndefinedType = Undefined,
                evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
                encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                vlan_id: int | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                dhcp_client_accept_default_route: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv4: bool | None | UndefinedType = Undefined,
                dhcp_server_ipv6: bool | None | UndefinedType = Undefined,
                ip_helpers: IpHelpers | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                mac_access_group_in: str | None | UndefinedType = Undefined,
                mac_access_group_out: str | None | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                mac_security: MacSecurity | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                channel_group: ChannelGroup | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_authentication_mode: Literal["text", "md5"] | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                poe: Poe | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                storm_control: StormControl | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                lldp: Lldp | UndefinedType = Undefined,
                trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                dot1x: Dot1x | UndefinedType = Undefined,
                service_profile: str | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_guard: Literal["loop", "root", "disabled"] | None | UndefinedType = Undefined,
                spanning_tree_portfast: Literal["edge", "network"] | None | UndefinedType = Undefined,
                vmtracer: bool | None | UndefinedType = Undefined,
                priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                lacp_timer: LacpTimer | UndefinedType = Undefined,
                lacp_port_priority: int | None | UndefinedType = Undefined,
                transceiver: Transceiver | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                traffic_policy: TrafficPolicy | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                peer_interface: str | None | UndefinedType = Undefined,
                peer_type: str | None | UndefinedType = Undefined,
                sflow: Sflow | UndefinedType = Undefined,
                sync_e: SyncE | UndefinedType = Undefined,
                port_profile: str | None | UndefinedType = Undefined,
                uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
                tx_queues: TxQueues | UndefinedType = Undefined,
                vrrp_ids: VrrpIds | UndefinedType = Undefined,
                validate_state: bool | None | UndefinedType = Undefined,
                validate_lldp: bool | None | UndefinedType = Undefined,
                switchport: Switchport | UndefinedType = Undefined,
                traffic_engineering: TrafficEngineering | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                EthernetInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    description: description
                    shutdown: shutdown
                    load_interval: Interval in seconds for updating interface counters.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    mtu: mtu
                    l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                    l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                    vlans:
                       List of switchport vlans as string.
                       For a trunk port this would be a range like "1-200,300".
                       For an
                       access port this would be a single vlan "123".
                    native_vlan: native_vlan
                    native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    mode: mode
                    phone: Subclass of AvdModel.
                    l2_protocol: Subclass of AvdModel.
                    mac_timestamp:
                       header: Insert timestamp in ethernet header. Supported on platforms like 7500E/R and 7280E/R.
                       before-fcs: Insert timestamp before fcs field. Supported on platforms like 7150.
                       replace-fcs:
                       Replace fcs field with timestamp.
                    trunk_groups: Subclass of AvdList with `str` items.
                    type:
                       l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                       The `type = switched/routed` should not be combined with `switchport`.
                    snmp_trap_link_change: snmp_trap_link_change
                    address_locking: Subclass of AvdModel.
                    flowcontrol: Subclass of AvdModel.
                    vrf: VRF name.
                    flow_tracker: Subclass of AvdModel.
                    error_correction_encoding: Subclass of AvdModel.
                    link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                    link_tracking: Subclass of AvdModel.
                    evpn_ethernet_segment: Subclass of AvdModel.
                    encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                    encapsulation_dot1q:
                       Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                       `ethernet_interfaces[].type: l2dot1q`.

                       Subclass of AvdModel.
                    encapsulation_vlan:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `encapsulation_vlan` should not
                       be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                       Subclass of AvdModel.
                    vlan_id:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `vlan_id` should not be combined
                       with `ethernet_interfaces[].type == l2dot1q`.
                    ip_address: IPv4 address/mask or "dhcp".
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                    dhcp_server_ipv4: Enable IPv4 DHCP server.
                    dhcp_server_ipv6: Enable IPv6 DHCP server.
                    ip_helpers: Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`).
                    ip_nat: Subclass of AvdModel.
                    ipv6_enable: ipv6_enable
                    ipv6_address: ipv6_address
                    ipv6_address_link_local: Link local IPv6 address/mask.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    ipv6_dhcp_relay_destinations:
                       Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
                       (`str`).
                    access_group_in: Access list name.
                    access_group_out: Access list name.
                    ipv6_access_group_in: IPv6 access list name.
                    ipv6_access_group_out: IPv6 access list name.
                    mac_access_group_in: MAC access list name.
                    mac_access_group_out: MAC access list name.
                    multicast:
                       Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                       of both.

                       Subclass of AvdModel.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ospf_area: ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password - only type 7 supported.
                    ospf_message_digest_keys: Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    pim: Subclass of AvdModel.
                    mac_security: Subclass of AvdModel.
                    tcp_mss_ceiling:
                       The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
                       of
                       TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.

                       Subclass of
                       AvdModel.
                    channel_group: Subclass of AvdModel.
                    isis_enable: ISIS instance.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_circuit_type: isis_circuit_type
                    isis_hello_padding: isis_hello_padding
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    isis_authentication:
                       This key should not be mixed with ethernet_interfaces[].isis_authentication_mode or
                       ethernet_interfaces[].isis_authentication_key.

                       Subclass of AvdModel.
                    poe: Subclass of AvdModel.
                    ptp: Subclass of AvdModel.
                    profile: Interface profile.
                    storm_control: Subclass of AvdModel.
                    logging: Subclass of AvdModel.
                    lldp: Subclass of AvdModel.
                    trunk_private_vlan_secondary: trunk_private_vlan_secondary
                    pvlan_mapping: List of vlans as string.
                    vlan_translations: Subclass of AvdList with `VlanTranslationsItem` items.
                    dot1x:
                       802.1x

                       Subclass of AvdModel.
                    service_profile: QOS profile.
                    shape: Subclass of AvdModel.
                    qos: Subclass of AvdModel.
                    spanning_tree_bpdufilter: spanning_tree_bpdufilter
                    spanning_tree_bpduguard: spanning_tree_bpduguard
                    spanning_tree_guard: spanning_tree_guard
                    spanning_tree_portfast: spanning_tree_portfast
                    vmtracer: vmtracer
                    priority_flow_control: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    mpls: Subclass of AvdModel.
                    lacp_timer: Subclass of AvdModel.
                    lacp_port_priority: lacp_port_priority
                    transceiver: Subclass of AvdModel.
                    ip_proxy_arp: ip_proxy_arp
                    traffic_policy: Subclass of AvdModel.
                    bgp: Subclass of AvdModel.
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    peer: Key only used for documentation or validation purposes.
                    peer_interface: Key only used for documentation or validation purposes.
                    peer_type: Key only used for documentation or validation purposes.
                    sflow: Subclass of AvdModel.
                    sync_e: Subclass of AvdModel.
                    port_profile: Key only used for documentation or validation purposes.
                    uc_tx_queues: Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`).
                    tx_queues: Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`).
                    vrrp_ids:
                       VRRP model.

                       Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`).
                    validate_state:
                       Set to false to disable interface state and LLDP topology validation performed by the
                       `eos_validate_state` role.
                    validate_lldp: Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role.
                    switchport:
                       This should not be combined with `ethernet_interfaces[].type = switched/routed`.

                       Subclass of
                       AvdModel.
                    traffic_engineering: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class EthernetInterfaces(AvdIndexedList[str, EthernetInterfacesItem]):
        """Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    EthernetInterfaces._item_type = EthernetInterfacesItem

    class EventHandlersItem(AvdModel):
        """Subclass of AvdModel."""

        class Actions(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "bash_command": {"type": str},
                "log": {"type": bool},
                "increment_device_health_metric": {"type": str},
                "_custom_data": {"type": dict},
            }
            bash_command: str | None
            """Define BASH command action. Command could be multiline also."""
            log: bool | None
            """Log a message when the event is triggered."""
            increment_device_health_metric: str | None
            """Name of device-health metric."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bash_command: str | None | UndefinedType = Undefined,
                    log: bool | None | UndefinedType = Undefined,
                    increment_device_health_metric: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Actions.


                    Subclass of AvdModel.

                    Args:
                        bash_command: Define BASH command action. Command could be multiline also.
                        log: Log a message when the event is triggered.
                        increment_device_health_metric: Name of device-health metric.
                        _custom_data: _custom_data

                    """

        class TriggerOnCounters(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "condition": {"type": str},
                "granularity_per_source": {"type": bool},
                "poll_interval": {"type": int},
                "_custom_data": {"type": dict},
            }
            condition: str | None
            """Set the logical expression to evaluate."""
            granularity_per_source: bool | None
            """
            Set the granularity of event counting for a wildcarded condition.
            Example -
              condition (
            Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
              [* wildcard is used
            here]
            """
            poll_interval: int | None
            """Set the polling interval in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    condition: str | None | UndefinedType = Undefined,
                    granularity_per_source: bool | None | UndefinedType = Undefined,
                    poll_interval: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnCounters.


                    Subclass of AvdModel.

                    Args:
                        condition: Set the logical expression to evaluate.
                        granularity_per_source:
                           Set the granularity of event counting for a wildcarded condition.
                           Example -
                             condition (
                           Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
                             [* wildcard is used
                           here]
                        poll_interval: Set the polling interval in seconds.
                        _custom_data: _custom_data

                    """

        class TriggerOnLogging(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"poll_interval": {"type": int}, "regex": {"type": str}, "_custom_data": {"type": dict}}
            poll_interval: int | None
            """Set the polling interval in seconds."""
            regex: str | None
            """Regular expression to use for searching log messages."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    poll_interval: int | None | UndefinedType = Undefined,
                    regex: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnLogging.


                    Subclass of AvdModel.

                    Args:
                        poll_interval: Set the polling interval in seconds.
                        regex: Regular expression to use for searching log messages.
                        _custom_data: _custom_data

                    """

        class TriggerOnIntf(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "interface": {"type": str},
                "ip": {"type": bool},
                "ipv6": {"type": bool},
                "operstatus": {"type": bool},
                "_custom_data": {"type": dict},
            }
            interface: str
            """
            Interface name.
            Example - Ethernet4
                      Loopback4-6
                      Port-channel4,7
            """
            ip: bool | None
            """Action is triggered upon changes to interface IP address assignment."""
            ipv6: bool | None
            """Action is triggered upon changes to interface ipv6 address assignment."""
            operstatus: bool | None
            """Action is triggered upon changes to interface operStatus."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interface: str | UndefinedType = Undefined,
                    ip: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    operstatus: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnIntf.


                    Subclass of AvdModel.

                    Args:
                        interface:
                           Interface name.
                           Example - Ethernet4
                                     Loopback4-6
                                     Port-channel4,7
                        ip: Action is triggered upon changes to interface IP address assignment.
                        ipv6: Action is triggered upon changes to interface ipv6 address assignment.
                        operstatus: Action is triggered upon changes to interface operStatus.
                        _custom_data: _custom_data

                    """

        class TriggerOnMaintenance(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "operation": {"type": str},
                "bgp_peer": {"type": str},
                "action": {"type": str},
                "stage": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "unit": {"type": str},
                "_custom_data": {"type": dict},
            }
            operation: Literal["enter", "exit"]
            bgp_peer: str | None
            """
            Ipv4/Ipv6 address or peer group name.
            Trigger condition occurs on maintenance operation of specified
            BGP peer.
            """
            action: Literal["after", "before", "all", "begin", "end"]
            """Action for maintenance operation."""
            stage: Literal["bgp", "linkdown", "mlag", "ratemon"] | None
            """Action is triggered after/before specified stage."""
            vrf: str | None
            """VRF name. VRF can be defined for "bgp_peer" only."""
            interface: str | None
            """Trigger condition occurs on maintenance operation of specified interface."""
            unit: str | None
            """Name of unit. Trigger condition occurs on maintenance operation of specified unit"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    operation: Literal["enter", "exit"] | UndefinedType = Undefined,
                    bgp_peer: str | None | UndefinedType = Undefined,
                    action: Literal["after", "before", "all", "begin", "end"] | UndefinedType = Undefined,
                    stage: Literal["bgp", "linkdown", "mlag", "ratemon"] | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    interface: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TriggerOnMaintenance.


                    Subclass of AvdModel.

                    Args:
                        operation: operation
                        bgp_peer:
                           Ipv4/Ipv6 address or peer group name.
                           Trigger condition occurs on maintenance operation of specified
                           BGP peer.
                        action: Action for maintenance operation.
                        stage: Action is triggered after/before specified stage.
                        vrf: VRF name. VRF can be defined for "bgp_peer" only.
                        interface: Trigger condition occurs on maintenance operation of specified interface.
                        unit: Name of unit. Trigger condition occurs on maintenance operation of specified unit
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "actions": {"type": Actions},
            "delay": {"type": int},
            "trigger": {"type": str},
            "trigger_on_counters": {"type": TriggerOnCounters},
            "trigger_on_logging": {"type": TriggerOnLogging},
            "trigger_on_intf": {"type": TriggerOnIntf},
            "trigger_on_maintenance": {"type": TriggerOnMaintenance},
            "asynchronous": {"type": bool, "default": False},
            "_custom_data": {"type": dict},
        }
        name: str
        """Event Handler Name."""
        actions: Actions
        """
        Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
        Subclass of AvdModel.
        """
        delay: int | None
        """Event-handler delay in seconds."""
        trigger: Literal["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"] | None
        """Configure event trigger condition."""
        trigger_on_counters: TriggerOnCounters
        """Subclass of AvdModel."""
        trigger_on_logging: TriggerOnLogging
        """Subclass of AvdModel."""
        trigger_on_intf: TriggerOnIntf
        """
        Trigger condition occurs on specified interface changes.
        Note: Any one of the `ip`, `ipv6` and
        `operstatus` key needs to be defined along with the `interface`.

        Subclass of AvdModel.
        """
        trigger_on_maintenance: TriggerOnMaintenance
        """
        Settings required for trigger 'on-maintenance'.

        Subclass of AvdModel.
        """
        asynchronous: bool
        """
        Set the action to be non-blocking.

        Default value: `False`
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                actions: Actions | UndefinedType = Undefined,
                delay: int | None | UndefinedType = Undefined,
                trigger: Literal["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"]
                | None
                | UndefinedType = Undefined,
                trigger_on_counters: TriggerOnCounters | UndefinedType = Undefined,
                trigger_on_logging: TriggerOnLogging | UndefinedType = Undefined,
                trigger_on_intf: TriggerOnIntf | UndefinedType = Undefined,
                trigger_on_maintenance: TriggerOnMaintenance | UndefinedType = Undefined,
                asynchronous: bool | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                EventHandlersItem.


                Subclass of AvdModel.

                Args:
                    name: Event Handler Name.
                    actions:
                       Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
                       Subclass of AvdModel.
                    delay: Event-handler delay in seconds.
                    trigger: Configure event trigger condition.
                    trigger_on_counters: Subclass of AvdModel.
                    trigger_on_logging: Subclass of AvdModel.
                    trigger_on_intf:
                       Trigger condition occurs on specified interface changes.
                       Note: Any one of the `ip`, `ipv6` and
                       `operstatus` key needs to be defined along with the `interface`.

                       Subclass of AvdModel.
                    trigger_on_maintenance:
                       Settings required for trigger 'on-maintenance'.

                       Subclass of AvdModel.
                    asynchronous: Set the action to be non-blocking.
                    _custom_data: _custom_data

                """

    class EventHandlers(AvdIndexedList[str, EventHandlersItem]):
        """Subclass of AvdIndexedList with `EventHandlersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    EventHandlers._item_type = EventHandlersItem

    class EventMonitor(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "_custom_data": {"type": dict}}
        enabled: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                EventMonitor.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    _custom_data: _custom_data

                """

    class FlowTracking(AvdModel):
        """Subclass of AvdModel."""

        class Sampled(AvdModel):
            """Subclass of AvdModel."""

            class Encapsulation(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_ipv6": {"type": bool}, "mpls": {"type": bool}, "_custom_data": {"type": dict}}
                ipv4_ipv6: bool | None
                mpls: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4_ipv6: bool | None | UndefinedType = Undefined,
                        mpls: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Encapsulation.


                        Subclass of AvdModel.

                        Args:
                            ipv4_ipv6: ipv4_ipv6
                            mpls: mpls
                            _custom_data: _custom_data

                        """

            class HardwareOffload(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}, "threshold_minimum": {"type": int}, "_custom_data": {"type": dict}}
                ipv4: bool | None
                """Configure hardware offload for IPv4 traffic."""
                ipv6: bool | None
                """Configure hardware offload for IPv6 traffic."""
                threshold_minimum: int | None
                """Minimum number of samples."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: bool | None | UndefinedType = Undefined,
                        ipv6: bool | None | UndefinedType = Undefined,
                        threshold_minimum: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HardwareOffload.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Configure hardware offload for IPv4 traffic.
                            ipv6: Configure hardware offload for IPv6 traffic.
                            threshold_minimum: Minimum number of samples.
                            _custom_data: _custom_data

                        """

            class TrackersItem(AvdModel):
                """Subclass of AvdModel."""

                class RecordExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "mpls": {"type": bool},
                        "on_inactive_timeout": {"type": int},
                        "on_interval": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    mpls: bool | None
                    """Export MPLS forwarding information."""
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mpls: bool | None | UndefinedType = Undefined,
                            on_inactive_timeout: int | None | UndefinedType = Undefined,
                            on_interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RecordExport.


                            Subclass of AvdModel.

                            Args:
                                mpls: Export MPLS forwarding information.
                                on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                                on_interval: Flow record export interval in milliseconds.
                                _custom_data: _custom_data

                            """

                class ExportersItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Collector(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                host: str | None | UndefinedType = Undefined,
                                port: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Collector.


                                Subclass of AvdModel.

                                Args:
                                    host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                    port: Collector Port Number.
                                    _custom_data: _custom_data

                                """

                    class Format(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ipfix_version": {"type": int}, "_custom_data": {"type": dict}}
                        ipfix_version: int | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, ipfix_version: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                Format.


                                Subclass of AvdModel.

                                Args:
                                    ipfix_version: ipfix_version
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    """Subclass of AvdModel."""
                    format: Format
                    """Subclass of AvdModel."""
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            collector: Collector | UndefinedType = Undefined,
                            format: Format | UndefinedType = Undefined,
                            local_interface: str | None | UndefinedType = Undefined,
                            template_interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportersItem.


                            Subclass of AvdModel.

                            Args:
                                name: Exporter Name.
                                collector: Subclass of AvdModel.
                                format: Subclass of AvdModel.
                                local_interface: Local Source Interface.
                                template_interval: Template interval in milliseconds.
                                _custom_data: _custom_data

                            """

                class Exporters(AvdIndexedList[str, ExportersItem]):
                    """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {
                    "table_size": {"type": int},
                    "record_export": {"type": RecordExport},
                    "name": {"type": str},
                    "exporters": {"type": Exporters},
                    "_custom_data": {"type": dict},
                }
                table_size: int | None
                """Maximum number of entries in flow table."""
                record_export: RecordExport
                """Subclass of AvdModel."""
                name: str
                """Tracker Name."""
                exporters: Exporters
                """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        table_size: int | None | UndefinedType = Undefined,
                        record_export: RecordExport | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        exporters: Exporters | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackersItem.


                        Subclass of AvdModel.

                        Args:
                            table_size: Maximum number of entries in flow table.
                            record_export: Subclass of AvdModel.
                            name: Tracker Name.
                            exporters: Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`).
                            _custom_data: _custom_data

                        """

            class Trackers(AvdIndexedList[str, TrackersItem]):
                """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "encapsulation": {"type": Encapsulation},
                "sample": {"type": int},
                "hardware_offload": {"type": HardwareOffload},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool, "default": False},
                "_custom_data": {"type": dict},
            }
            encapsulation: Encapsulation
            """Subclass of AvdModel."""
            sample: int | None
            hardware_offload: HardwareOffload
            """Subclass of AvdModel."""
            trackers: Trackers
            """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
            shutdown: bool
            """Default value: `False`"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    encapsulation: Encapsulation | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    hardware_offload: HardwareOffload | UndefinedType = Undefined,
                    trackers: Trackers | UndefinedType = Undefined,
                    shutdown: bool | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sampled.


                    Subclass of AvdModel.

                    Args:
                        encapsulation: Subclass of AvdModel.
                        sample: sample
                        hardware_offload: Subclass of AvdModel.
                        trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                        shutdown: shutdown
                        _custom_data: _custom_data

                    """

        class Hardware(AvdModel):
            """Subclass of AvdModel."""

            class Record(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"format_ipfix_standard_timestamps_counters": {"type": bool}, "_custom_data": {"type": dict}}
                format_ipfix_standard_timestamps_counters: bool | None
                """Enable software export of IPFIX data records."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        format_ipfix_standard_timestamps_counters: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Record.


                        Subclass of AvdModel.

                        Args:
                            format_ipfix_standard_timestamps_counters: Enable software export of IPFIX data records.
                            _custom_data: _custom_data

                        """

            class TrackersItem(AvdModel):
                """Subclass of AvdModel."""

                class RecordExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"on_inactive_timeout": {"type": int}, "on_interval": {"type": int}, "_custom_data": {"type": dict}}
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            on_inactive_timeout: int | None | UndefinedType = Undefined,
                            on_interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RecordExport.


                            Subclass of AvdModel.

                            Args:
                                on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                                on_interval: Flow record export interval in milliseconds.
                                _custom_data: _custom_data

                            """

                class ExportersItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Collector(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"host": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                host: str | None | UndefinedType = Undefined,
                                port: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Collector.


                                Subclass of AvdModel.

                                Args:
                                    host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                    port: Collector Port Number.
                                    _custom_data: _custom_data

                                """

                    class Format(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ipfix_version": {"type": int}, "_custom_data": {"type": dict}}
                        ipfix_version: int | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, ipfix_version: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                Format.


                                Subclass of AvdModel.

                                Args:
                                    ipfix_version: ipfix_version
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    """Subclass of AvdModel."""
                    format: Format
                    """Subclass of AvdModel."""
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            collector: Collector | UndefinedType = Undefined,
                            format: Format | UndefinedType = Undefined,
                            local_interface: str | None | UndefinedType = Undefined,
                            template_interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportersItem.


                            Subclass of AvdModel.

                            Args:
                                name: Exporter Name.
                                collector: Subclass of AvdModel.
                                format: Subclass of AvdModel.
                                local_interface: Local Source Interface.
                                template_interval: Template interval in milliseconds.
                                _custom_data: _custom_data

                            """

                class Exporters(AvdIndexedList[str, ExportersItem]):
                    """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "record_export": {"type": RecordExport},
                    "exporters": {"type": Exporters},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Tracker Name."""
                record_export: RecordExport
                """Subclass of AvdModel."""
                exporters: Exporters
                """Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        record_export: RecordExport | UndefinedType = Undefined,
                        exporters: Exporters | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackersItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracker Name.
                            record_export: Subclass of AvdModel.
                            exporters: Subclass of AvdIndexedList with `ExportersItem` items. Primary key is `name` (`str`).
                            _custom_data: _custom_data

                        """

            class Trackers(AvdIndexedList[str, TrackersItem]):
                """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "record": {"type": Record},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool, "default": False},
                "_custom_data": {"type": dict},
            }
            record: Record
            """Subclass of AvdModel."""
            trackers: Trackers
            """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
            shutdown: bool
            """Default value: `False`"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    record: Record | UndefinedType = Undefined,
                    trackers: Trackers | UndefinedType = Undefined,
                    shutdown: bool | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Hardware.


                    Subclass of AvdModel.

                    Args:
                        record: Subclass of AvdModel.
                        trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                        shutdown: shutdown
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"sampled": {"type": Sampled}, "hardware": {"type": Hardware}, "_custom_data": {"type": dict}}
        sampled: Sampled
        """Subclass of AvdModel."""
        hardware: Hardware
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                sampled: Sampled | UndefinedType = Undefined,
                hardware: Hardware | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracking.


                Subclass of AvdModel.

                Args:
                    sampled: Subclass of AvdModel.
                    hardware: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Hardware(AvdModel):
        """Subclass of AvdModel."""

        class AccessList(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"mechanism": {"type": str}, "_custom_data": {"type": dict}}
            mechanism: Literal["algomatch", "none", "tcam"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    mechanism: Literal["algomatch", "none", "tcam"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessList.


                    Subclass of AvdModel.

                    Args:
                        mechanism: mechanism
                        _custom_data: _custom_data

                    """

        class SpeedGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"speed_group": {"type": str}, "serdes": {"type": str}, "_custom_data": {"type": dict}}
            speed_group: str
            serdes: str | None
            """Serdes speed like "10g" or "25g"."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    speed_group: str | UndefinedType = Undefined,
                    serdes: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SpeedGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        speed_group: speed_group
                        serdes: Serdes speed like "10g" or "25g".
                        _custom_data: _custom_data

                    """

        class SpeedGroups(AvdIndexedList[str, SpeedGroupsItem]):
            """Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`)."""

            _primary_key: ClassVar[str] = "speed_group"

        SpeedGroups._item_type = SpeedGroupsItem

        class PortGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"port_group": {"type": str}, "select": {"type": str}, "_custom_data": {"type": dict}}
            port_group: str
            select: str | None
            """Select Ports to activate"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    port_group: str | UndefinedType = Undefined,
                    select: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        port_group: port_group
                        select: Select Ports to activate
                        _custom_data: _custom_data

                    """

        class PortGroups(AvdIndexedList[str, PortGroupsItem]):
            """Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`)."""

            _primary_key: ClassVar[str] = "port_group"

        PortGroups._item_type = PortGroupsItem

        _fields: ClassVar[dict] = {
            "access_list": {"type": AccessList},
            "speed_groups": {"type": SpeedGroups},
            "port_groups": {"type": PortGroups},
            "_custom_data": {"type": dict},
        }
        access_list: AccessList
        """Subclass of AvdModel."""
        speed_groups: SpeedGroups
        """Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`)."""
        port_groups: PortGroups
        """Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                access_list: AccessList | UndefinedType = Undefined,
                speed_groups: SpeedGroups | UndefinedType = Undefined,
                port_groups: PortGroups | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Hardware.


                Subclass of AvdModel.

                Args:
                    access_list: Subclass of AvdModel.
                    speed_groups: Subclass of AvdIndexedList with `SpeedGroupsItem` items. Primary key is `speed_group` (`str`).
                    port_groups: Subclass of AvdIndexedList with `PortGroupsItem` items. Primary key is `port_group` (`str`).
                    _custom_data: _custom_data

                """

    class HardwareCounters(AvdModel):
        """Subclass of AvdModel."""

        class FeaturesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "direction": {"type": str},
                "address_type": {"type": str},
                "layer3": {"type": bool},
                "vrf": {"type": str},
                "prefix": {"type": str},
                "units_packets": {"type": bool},
                "_custom_data": {"type": dict},
            }
            name: Literal[
                "acl",
                "decap-group",
                "directflow",
                "ecn",
                "flow-spec",
                "gre tunnel interface",
                "ip",
                "mpls interface",
                "mpls lfib",
                "mpls tunnel",
                "multicast",
                "nexthop",
                "pbr",
                "pdp",
                "policing interface",
                "qos",
                "qos dual-rate-policer",
                "route",
                "routed-port",
                "segment-security",
                "subinterface",
                "tapagg",
                "traffic-class",
                "traffic-policy",
                "vlan",
                "vlan-interface",
                "vni decap",
                "vni encap",
                "vtep decap",
                "vtep encap",
            ]
            direction: Literal["in", "out", "cpu"] | None
            """
            Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
            Some features DO
            NOT have any direction.
            This validation IS NOT made by the schemas.
            """
            address_type: Literal["ipv4", "ipv6", "mac"] | None
            """
            Supported only for the following features:
            - acl: [ipv4, ipv6, mac] if direction is 'out'
            -
            multicast: [ipv4, ipv6]
            - route: [ipv4, ipv6]
            This validation IS NOT made by the schemas.
            """
            layer3: bool | None
            """Supported only for the 'ip' feature."""
            vrf: str | None
            """
            Supported only for the 'route' feature.
            This validation IS NOT made by the schemas.
            """
            prefix: str | None
            """
            Supported only for the 'route' feature.
            Mandatory for the 'route' feature.
            This validation IS NOT
            made by the schemas.
            """
            units_packets: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: Literal[
                        "acl",
                        "decap-group",
                        "directflow",
                        "ecn",
                        "flow-spec",
                        "gre tunnel interface",
                        "ip",
                        "mpls interface",
                        "mpls lfib",
                        "mpls tunnel",
                        "multicast",
                        "nexthop",
                        "pbr",
                        "pdp",
                        "policing interface",
                        "qos",
                        "qos dual-rate-policer",
                        "route",
                        "routed-port",
                        "segment-security",
                        "subinterface",
                        "tapagg",
                        "traffic-class",
                        "traffic-policy",
                        "vlan",
                        "vlan-interface",
                        "vni decap",
                        "vni encap",
                        "vtep decap",
                        "vtep encap",
                    ]
                    | UndefinedType = Undefined,
                    direction: Literal["in", "out", "cpu"] | None | UndefinedType = Undefined,
                    address_type: Literal["ipv4", "ipv6", "mac"] | None | UndefinedType = Undefined,
                    layer3: bool | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    prefix: str | None | UndefinedType = Undefined,
                    units_packets: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FeaturesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        direction:
                           Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
                           Some features DO
                           NOT have any direction.
                           This validation IS NOT made by the schemas.
                        address_type:
                           Supported only for the following features:
                           - acl: [ipv4, ipv6, mac] if direction is 'out'
                           -
                           multicast: [ipv4, ipv6]
                           - route: [ipv4, ipv6]
                           This validation IS NOT made by the schemas.
                        layer3: Supported only for the 'ip' feature.
                        vrf:
                           Supported only for the 'route' feature.
                           This validation IS NOT made by the schemas.
                        prefix:
                           Supported only for the 'route' feature.
                           Mandatory for the 'route' feature.
                           This validation IS NOT
                           made by the schemas.
                        units_packets: units_packets
                        _custom_data: _custom_data

                    """

        class Features(AvdList[FeaturesItem]):
            """Subclass of AvdList with `FeaturesItem` items."""

        Features._item_type = FeaturesItem

        _fields: ClassVar[dict] = {"features": {"type": Features}, "_custom_data": {"type": dict}}
        features: Features
        """
        This data model allows to configure the list of hardware counters feature
        available on Arista
        platforms.

        The `name` key accepts a list of valid_values which MUST be updated to support
        new
        feature as they are released in EOS.

        The available values of the different keys like 'direction' or
        'address_type'
        are feature and hardware dependent and this model DOES NOT validate that the
        combinations are valid. It is the responsibility of the user of this data model
        to make sure that
        the rendered CLI is accepted by the targeted device.

        Examples:

          * Use:
            ```yaml
        hardware_counters:
              features:
                - name: ip
                  direction: out
                  layer3:
        true
                  units_packets: true
            ```

            to render:
            ```eos
            hardware counter feature
        ip out layer3 units packets
            ```
          * Use:
            ```yaml
            hardware_counters:
              features:
        - name: route
                  address_type: ipv4
                  vrf: test
                  prefix: 192.168.0.0/24
        ```

            to render:
            ```eos
            hardware counter feature route ipv4 vrf test 192.168.0.0/24
        ```


        Subclass of AvdList with `FeaturesItem` items.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, features: Features | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                HardwareCounters.


                Subclass of AvdModel.

                Args:
                    features:
                       This data model allows to configure the list of hardware counters feature
                       available on Arista
                       platforms.

                       The `name` key accepts a list of valid_values which MUST be updated to support
                       new
                       feature as they are released in EOS.

                       The available values of the different keys like 'direction' or
                       'address_type'
                       are feature and hardware dependent and this model DOES NOT validate that the
                       combinations are valid. It is the responsibility of the user of this data model
                       to make sure that
                       the rendered CLI is accepted by the targeted device.

                       Examples:  # fmt: skip

                         * Use:
                           ```yaml
                       hardware_counters:
                             features:
                               - name: ip
                                 direction: out
                                 layer3:
                       true
                                 units_packets: true
                           ```

                           to render:
                           ```eos
                           hardware counter feature
                       ip out layer3 units packets
                           ```
                         * Use:
                           ```yaml
                           hardware_counters:
                             features:
                       - name: route
                                 address_type: ipv4
                                 vrf: test
                                 prefix: 192.168.0.0/24
                       ```

                           to render:
                           ```eos
                           hardware counter feature route ipv4 vrf test 192.168.0.0/24
                       ```


                       Subclass of AvdList with `FeaturesItem` items.
                    _custom_data: _custom_data

                """

    class InterfaceDefaults(AvdModel):
        """Subclass of AvdModel."""

        class Ethernet(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "_custom_data": {"type": dict}}
            shutdown: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, shutdown: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Ethernet.


                    Subclass of AvdModel.

                    Args:
                        shutdown: shutdown
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"ethernet": {"type": Ethernet}, "mtu": {"type": int}, "_custom_data": {"type": dict}}
        ethernet: Ethernet
        """Subclass of AvdModel."""
        mtu: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ethernet: Ethernet | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceDefaults.


                Subclass of AvdModel.

                Args:
                    ethernet: Subclass of AvdModel.
                    mtu: mtu
                    _custom_data: _custom_data

                """

    class InterfaceGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        class Interfaces(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Interfaces._item_type = str

        class BgpMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpMaintenanceProfiles._item_type = str

        class InterfaceMaintenanceProfiles(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        InterfaceMaintenanceProfiles._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "interfaces": {"type": Interfaces},
            "bgp_maintenance_profiles": {"type": BgpMaintenanceProfiles},
            "interface_maintenance_profiles": {"type": InterfaceMaintenanceProfiles},
            "_custom_data": {"type": dict},
        }
        name: str
        """Interface-Group name."""
        interfaces: Interfaces
        """Subclass of AvdList with `str` items."""
        bgp_maintenance_profiles: BgpMaintenanceProfiles
        """Subclass of AvdList with `str` items."""
        interface_maintenance_profiles: InterfaceMaintenanceProfiles
        """Subclass of AvdList with `str` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                interfaces: Interfaces | UndefinedType = Undefined,
                bgp_maintenance_profiles: BgpMaintenanceProfiles | UndefinedType = Undefined,
                interface_maintenance_profiles: InterfaceMaintenanceProfiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: Interface-Group name.
                    interfaces: Subclass of AvdList with `str` items.
                    bgp_maintenance_profiles: Subclass of AvdList with `str` items.
                    interface_maintenance_profiles: Subclass of AvdList with `str` items.
                    _custom_data: _custom_data

                """

    class InterfaceGroups(AvdIndexedList[str, InterfaceGroupsItem]):
        """Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    InterfaceGroups._item_type = InterfaceGroupsItem

    class InterfaceProfilesItem(AvdModel):
        """Subclass of AvdModel."""

        class Commands(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Commands._item_type = str

        _fields: ClassVar[dict] = {"name": {"type": str}, "commands": {"type": Commands}, "_custom_data": {"type": dict}}
        name: str
        """Interface-Profile Name."""
        commands: Commands
        """Subclass of AvdList with `str` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                commands: Commands | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceProfilesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface-Profile Name.
                    commands: Subclass of AvdList with `str` items.
                    _custom_data: _custom_data

                """

    class InterfaceProfiles(AvdIndexedList[str, InterfaceProfilesItem]):
        """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    InterfaceProfiles._item_type = InterfaceProfilesItem

    class IpAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            class SourcePorts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            SourcePorts._item_type = str

            class DestinationPorts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            DestinationPorts._item_type = str

            class TcpFlags(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            TcpFlags._item_type = str

            _fields: ClassVar[dict] = {
                "sequence": {"type": int},
                "remark": {"type": str},
                "action": {"type": str},
                "protocol": {"type": str},
                "source": {"type": str},
                "source_ports_match": {"type": str, "default": "eq"},
                "source_ports": {"type": SourcePorts},
                "destination": {"type": str},
                "destination_ports_match": {"type": str, "default": "eq"},
                "destination_ports": {"type": DestinationPorts},
                "tcp_flags": {"type": TcpFlags},
                "fragments": {"type": bool},
                "log": {"type": bool},
                "ttl": {"type": int},
                "ttl_match": {"type": str, "default": "eq"},
                "icmp_type": {"type": str},
                "icmp_code": {"type": str},
                "nexthop_group": {"type": str},
                "tracked": {"type": bool},
                "dscp": {"type": str},
                "vlan_number": {"type": int},
                "vlan_inner": {"type": bool, "default": False},
                "vlan_mask": {"type": str},
                "_custom_data": {"type": dict},
            }
            sequence: int | None
            """ACL entry sequence number."""
            remark: str | None
            """
            Comment up to 100 characters.
            If remark is defined, other keys in the ACL entry will be ignored.
            """
            action: Literal["permit", "deny"] | None
            """
            ACL action.
            Required except for remarks.
            """
            protocol: str | None
            """
            "ip", "tcp", "udp", "icmp" or other protocol name or number.
            Required except for remarks.
            """
            source: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            source_ports_match: Literal["eq", "gt", "lt", "neq", "range"]
            """Default value: `"eq"`"""
            source_ports: SourcePorts
            """Subclass of AvdList with `str` items."""
            destination: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            destination_ports_match: Literal["eq", "gt", "lt", "neq", "range"]
            """Default value: `"eq"`"""
            destination_ports: DestinationPorts
            """Subclass of AvdList with `str` items."""
            tcp_flags: TcpFlags
            """Subclass of AvdList with `str` items."""
            fragments: bool | None
            """Match non-head fragment packets."""
            log: bool | None
            """Log matches against this rule."""
            ttl: int | None
            """TTL value."""
            ttl_match: Literal["eq", "gt", "lt", "neq"]
            """Default value: `"eq"`"""
            icmp_type: str | None
            """Message type name/number for ICMP packets."""
            icmp_code: str | None
            """Message code for ICMP packets."""
            nexthop_group: str | None
            """nexthop-group name."""
            tracked: bool | None
            """Match packets in existing ICMP/UDP/TCP connections."""
            dscp: str | None
            """DSCP value or name."""
            vlan_number: int | None
            vlan_inner: bool
            """Default value: `False`"""
            vlan_mask: str | None
            """0x000-0xFFF VLAN mask."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | None | UndefinedType = Undefined,
                    remark: str | None | UndefinedType = Undefined,
                    action: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                    protocol: str | None | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    source_ports_match: Literal["eq", "gt", "lt", "neq", "range"] | UndefinedType = Undefined,
                    source_ports: SourcePorts | UndefinedType = Undefined,
                    destination: str | None | UndefinedType = Undefined,
                    destination_ports_match: Literal["eq", "gt", "lt", "neq", "range"] | UndefinedType = Undefined,
                    destination_ports: DestinationPorts | UndefinedType = Undefined,
                    tcp_flags: TcpFlags | UndefinedType = Undefined,
                    fragments: bool | None | UndefinedType = Undefined,
                    log: bool | None | UndefinedType = Undefined,
                    ttl: int | None | UndefinedType = Undefined,
                    ttl_match: Literal["eq", "gt", "lt", "neq"] | UndefinedType = Undefined,
                    icmp_type: str | None | UndefinedType = Undefined,
                    icmp_code: str | None | UndefinedType = Undefined,
                    nexthop_group: str | None | UndefinedType = Undefined,
                    tracked: bool | None | UndefinedType = Undefined,
                    dscp: str | None | UndefinedType = Undefined,
                    vlan_number: int | None | UndefinedType = Undefined,
                    vlan_inner: bool | UndefinedType = Undefined,
                    vlan_mask: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: ACL entry sequence number.
                        remark:
                           Comment up to 100 characters.
                           If remark is defined, other keys in the ACL entry will be ignored.
                        action:
                           ACL action.
                           Required except for remarks.
                        protocol:
                           "ip", "tcp", "udp", "icmp" or other protocol name or number.
                           Required except for remarks.
                        source:
                           "any", "<ip>/<mask>" or "<ip>".
                           "<ip>" without a mask means host.
                           Required except for remarks.
                        source_ports_match: source_ports_match
                        source_ports: Subclass of AvdList with `str` items.
                        destination:
                           "any", "<ip>/<mask>" or "<ip>".
                           "<ip>" without a mask means host.
                           Required except for remarks.
                        destination_ports_match: destination_ports_match
                        destination_ports: Subclass of AvdList with `str` items.
                        tcp_flags: Subclass of AvdList with `str` items.
                        fragments: Match non-head fragment packets.
                        log: Log matches against this rule.
                        ttl: TTL value.
                        ttl_match: ttl_match
                        icmp_type: Message type name/number for ICMP packets.
                        icmp_code: Message code for ICMP packets.
                        nexthop_group: nexthop-group name.
                        tracked: Match packets in existing ICMP/UDP/TCP connections.
                        dscp: DSCP value or name.
                        vlan_number: vlan_number
                        vlan_inner: vlan_inner
                        vlan_mask: 0x000-0xFFF VLAN mask.
                        _custom_data: _custom_data

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "entries": {"type": Entries},
            "permit_response_traffic": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        entries: Entries
        """
        ACL Entries.

        Subclass of AvdList with `EntriesItem` items.
        """
        permit_response_traffic: Literal["nat"] | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                permit_response_traffic: Literal["nat"] | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    entries:
                       ACL Entries.

                       Subclass of AvdList with `EntriesItem` items.
                    permit_response_traffic:
                       Permit response traffic automatically based on NAT translations.
                       Minimum EOS version requirement
                       4.32.2F.
                    _custom_data: _custom_data

                """

    class IpAccessLists(AvdIndexedList[str, IpAccessListsItem]):
        """Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpAccessLists._item_type = IpAccessListsItem

    class IpCommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            class Communities(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Communities._item_type = str

            _fields: ClassVar[dict] = {"action": {"type": str}, "communities": {"type": Communities}, "regexp": {"type": str}, "_custom_data": {"type": dict}}
            action: Literal["permit", "deny"]
            communities: Communities
            """
            If defined, a standard community-list will be configured.
            Supported community strings (case
            insensitive):
            - GSHUT
            - internet
            - local-as
            - no-advertise
            - no-export
            - <1-4294967040>
            - aa:nn
            Subclass of AvdList with `str` items.
            """
            regexp: str | None
            """
            Regular Expression.
            If defined, a regex community-list will be configured.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["permit", "deny"] | UndefinedType = Undefined,
                    communities: Communities | UndefinedType = Undefined,
                    regexp: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        action: action
                        communities:
                           If defined, a standard community-list will be configured.
                           Supported community strings (case
                           insensitive):
                           - GSHUT
                           - internet
                           - local-as
                           - no-advertise
                           - no-export
                           - <1-4294967040>
                           - aa:nn
                           Subclass of AvdList with `str` items.
                        regexp:
                           Regular Expression.
                           If defined, a regex community-list will be configured.
                        _custom_data: _custom_data

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}, "_custom_data": {"type": dict}}
        name: str
        """IP Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpCommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: IP Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.
                    _custom_data: _custom_data

                """

    class IpCommunityLists(AvdIndexedList[str, IpCommunityListsItem]):
        """Subclass of AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpCommunityLists._item_type = IpCommunityListsItem

    class IpDhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "always_on": {"type": bool},
            "all_subnets": {"type": bool},
            "information_option": {"type": bool},
            "_custom_data": {"type": dict},
        }
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode."""
        all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        information_option: bool | None
        """Insert Option-82 information."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                always_on: bool | None | UndefinedType = Undefined,
                all_subnets: bool | None | UndefinedType = Undefined,
                information_option: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpDhcpRelay.


                Subclass of AvdModel.

                Args:
                    always_on: DhcpRelay Agent will be in always-on mode.
                    all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                    information_option: Insert Option-82 information.
                    _custom_data: _custom_data

                """

    class IpDhcpSnooping(AvdModel):
        """Subclass of AvdModel."""

        class InformationOption(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "circuit_id_type": {"type": str},
                "circuit_id_format": {"type": str},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            """Enable insertion of option-82 in DHCP request packets."""
            circuit_id_type: str | None
            """"none" or <0 - 255>."""
            circuit_id_format: Literal["%h:%p", "%p:%v"] | None
            """
            Required if `circuit_id_type` is set.
            - "%h:%p" Hostname and interface name
            - "%p:%v" Interface name
            and VLAN ID
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    circuit_id_type: str | None | UndefinedType = Undefined,
                    circuit_id_format: Literal["%h:%p", "%p:%v"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InformationOption.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable insertion of option-82 in DHCP request packets.
                        circuit_id_type: "none" or <0 - 255>.
                        circuit_id_format:
                           Required if `circuit_id_type` is set.
                           - "%h:%p" Hostname and interface name
                           - "%p:%v" Interface name
                           and VLAN ID
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "bridging": {"type": bool},
            "information_option": {"type": InformationOption},
            "vlan": {"type": str},
            "_custom_data": {"type": dict},
        }
        enabled: bool | None
        bridging: bool | None
        information_option: InformationOption
        """Subclass of AvdModel."""
        vlan: str | None
        """
        VLAN range as string.
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 15,16,17,18
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | None | UndefinedType = Undefined,
                bridging: bool | None | UndefinedType = Undefined,
                information_option: InformationOption | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpDhcpSnooping.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    bridging: bridging
                    information_option: Subclass of AvdModel.
                    vlan:
                       VLAN range as string.
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 15,16,17,18
                    _custom_data: _custom_data

                """

    class IpDomainLookup(AvdModel):
        """Subclass of AvdModel."""

        class SourceInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Source Interface."""
            vrf: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourceInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Source Interface.
                        vrf: vrf
                        _custom_data: _custom_data

                    """

        class SourceInterfaces(AvdIndexedList[str, SourceInterfacesItem]):
            """Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SourceInterfaces._item_type = SourceInterfacesItem

        _fields: ClassVar[dict] = {"source_interfaces": {"type": SourceInterfaces}, "_custom_data": {"type": dict}}
        source_interfaces: SourceInterfaces
        """Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self, *, source_interfaces: SourceInterfaces | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
            ) -> None:
                """
                IpDomainLookup.


                Subclass of AvdModel.

                Args:
                    source_interfaces: Subclass of AvdIndexedList with `SourceInterfacesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class IpExtcommunityListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "extcommunities": {"type": str}, "_custom_data": {"type": dict}}
            type: Literal["permit", "deny"]
            extcommunities: str
            """
            Communities as string.
            Example: "65000:65000"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    type: Literal["permit", "deny"] | UndefinedType = Undefined,
                    extcommunities: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        extcommunities:
                           Communities as string.
                           Example: "65000:65000"
                        _custom_data: _custom_data

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}, "_custom_data": {"type": dict}}
        name: str
        """Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpExtcommunityListsItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.
                    _custom_data: _custom_data

                """

    class IpExtcommunityLists(AvdIndexedList[str, IpExtcommunityListsItem]):
        """Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    IpExtcommunityLists._item_type = IpExtcommunityListsItem

    class IpExtcommunityListsRegexpItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "regexp": {"type": str}, "_custom_data": {"type": dict}}
            type: Literal["permit", "deny"]
            regexp: str
            """Regular Expression."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    type: Literal["permit", "deny"] | UndefinedType = Undefined,
                    regexp: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        regexp: Regular Expression.
                        _custom_data: _custom_data

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "entries": {"type": Entries}, "_custom_data": {"type": dict}}
        name: str
        """Community-list Name."""
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpExtcommunityListsRegexpItem.


                Subclass of AvdModel.

                Args:
                    name: Community-list Name.
                    entries: Subclass of AvdList with `EntriesItem` items.
                    _custom_data: _custom_data

                """

    class IpExtcommunityListsRegexp(AvdIndexedList[str, IpExtcommunityListsRegexpItem]):
        """
        Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
        (`str`).
        """

        _primary_key: ClassVar[str] = "name"

    IpExtcommunityListsRegexp._item_type = IpExtcommunityListsRegexpItem

    class IpFtpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpFtpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.
                    _custom_data: _custom_data

                """

    class IpFtpClientSourceInterfaces(AvdList[IpFtpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items."""

    IpFtpClientSourceInterfaces._item_type = IpFtpClientSourceInterfacesItem

    class IpHardware(AvdModel):
        """Subclass of AvdModel."""

        class Fib(AvdModel):
            """Subclass of AvdModel."""

            class Optimize(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "_custom_data": {"type": dict}}
                    profile: Literal["internet", "urpf-internet"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: Literal["internet", "urpf-internet"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Prefixes.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
                prefixes: Prefixes
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Optimize.


                        Subclass of AvdModel.

                        Args:
                            prefixes: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"optimize": {"type": Optimize}, "_custom_data": {"type": dict}}
            optimize: Optimize
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, optimize: Optimize | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Fib.


                    Subclass of AvdModel.

                    Args:
                        optimize: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"fib": {"type": Fib}, "_custom_data": {"type": dict}}
        fib: Fib
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, fib: Fib | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                IpHardware.


                Subclass of AvdModel.

                Args:
                    fib: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class IpHttpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str | None
        """Interface Name."""
        vrf: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpHttpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: vrf
                    _custom_data: _custom_data

                """

    class IpHttpClientSourceInterfaces(AvdList[IpHttpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items."""

    IpHttpClientSourceInterfaces._item_type = IpHttpClientSourceInterfacesItem

    class IpIgmpSnooping(AvdModel):
        """Subclass of AvdModel."""

        class Querier(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "address": {"type": str},
                "query_interval": {"type": int},
                "max_response_time": {"type": int},
                "last_member_query_interval": {"type": int},
                "last_member_query_count": {"type": int},
                "startup_query_interval": {"type": int},
                "startup_query_count": {"type": int},
                "version": {"type": int},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            address: str | None
            """IP Address."""
            query_interval: int | None
            max_response_time: int | None
            last_member_query_interval: int | None
            last_member_query_count: int | None
            startup_query_interval: int | None
            startup_query_count: int | None
            version: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    query_interval: int | None | UndefinedType = Undefined,
                    max_response_time: int | None | UndefinedType = Undefined,
                    last_member_query_interval: int | None | UndefinedType = Undefined,
                    last_member_query_count: int | None | UndefinedType = Undefined,
                    startup_query_interval: int | None | UndefinedType = Undefined,
                    startup_query_count: int | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Querier.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        address: IP Address.
                        query_interval: query_interval
                        max_response_time: max_response_time
                        last_member_query_interval: last_member_query_interval
                        last_member_query_count: last_member_query_count
                        startup_query_interval: startup_query_interval
                        startup_query_count: startup_query_count
                        version: version
                        _custom_data: _custom_data

                    """

        class VlansItem(AvdModel):
            """Subclass of AvdModel."""

            class Querier(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "address": {"type": str},
                    "query_interval": {"type": int},
                    "max_response_time": {"type": int},
                    "last_member_query_interval": {"type": int},
                    "last_member_query_count": {"type": int},
                    "startup_query_interval": {"type": int},
                    "startup_query_count": {"type": int},
                    "version": {"type": int},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                address: str | None
                """IP Address."""
                query_interval: int | None
                max_response_time: int | None
                last_member_query_interval: int | None
                last_member_query_count: int | None
                startup_query_interval: int | None
                startup_query_count: int | None
                version: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        address: str | None | UndefinedType = Undefined,
                        query_interval: int | None | UndefinedType = Undefined,
                        max_response_time: int | None | UndefinedType = Undefined,
                        last_member_query_interval: int | None | UndefinedType = Undefined,
                        last_member_query_count: int | None | UndefinedType = Undefined,
                        startup_query_interval: int | None | UndefinedType = Undefined,
                        startup_query_count: int | None | UndefinedType = Undefined,
                        version: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Querier.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            address: IP Address.
                            query_interval: query_interval
                            max_response_time: max_response_time
                            last_member_query_interval: last_member_query_interval
                            last_member_query_count: last_member_query_count
                            startup_query_interval: startup_query_interval
                            startup_query_count: startup_query_count
                            version: version
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "enabled": {"type": bool},
                "querier": {"type": Querier},
                "max_groups": {"type": int},
                "fast_leave": {"type": bool},
                "proxy": {"type": bool},
                "_custom_data": {"type": dict},
            }
            id: int
            """VLAN ID."""
            enabled: bool | None
            querier: Querier
            """Subclass of AvdModel."""
            max_groups: int | None
            fast_leave: bool | None
            proxy: bool | None
            """Global proxy settings should be enabled before enabling per-vlan."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    querier: Querier | UndefinedType = Undefined,
                    max_groups: int | None | UndefinedType = Undefined,
                    fast_leave: bool | None | UndefinedType = Undefined,
                    proxy: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlansItem.


                    Subclass of AvdModel.

                    Args:
                        id: VLAN ID.
                        enabled: enabled
                        querier: Subclass of AvdModel.
                        max_groups: max_groups
                        fast_leave: fast_leave
                        proxy: Global proxy settings should be enabled before enabling per-vlan.
                        _custom_data: _custom_data

                    """

        class Vlans(AvdIndexedList[int, VlansItem]):
            """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        _fields: ClassVar[dict] = {
            "globally_enabled": {"type": bool, "default": True},
            "robustness_variable": {"type": int},
            "restart_query_interval": {"type": int},
            "interface_restart_query": {"type": int},
            "fast_leave": {"type": bool},
            "querier": {"type": Querier},
            "proxy": {"type": bool},
            "vlans": {"type": Vlans},
            "_custom_data": {"type": dict},
        }
        globally_enabled: bool
        """
        Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
        deactivate IGMP snooping per vlan.

        Default value: `True`
        """
        robustness_variable: int | None
        restart_query_interval: int | None
        interface_restart_query: int | None
        fast_leave: bool | None
        querier: Querier
        """Subclass of AvdModel."""
        proxy: bool | None
        vlans: Vlans
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                globally_enabled: bool | UndefinedType = Undefined,
                robustness_variable: int | None | UndefinedType = Undefined,
                restart_query_interval: int | None | UndefinedType = Undefined,
                interface_restart_query: int | None | UndefinedType = Undefined,
                fast_leave: bool | None | UndefinedType = Undefined,
                querier: Querier | UndefinedType = Undefined,
                proxy: bool | None | UndefinedType = Undefined,
                vlans: Vlans | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpIgmpSnooping.


                Subclass of AvdModel.

                Args:
                    globally_enabled:
                       Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
                       deactivate IGMP snooping per vlan.
                    robustness_variable: robustness_variable
                    restart_query_interval: restart_query_interval
                    interface_restart_query: interface_restart_query
                    fast_leave: fast_leave
                    querier: Subclass of AvdModel.
                    proxy: proxy
                    vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                    _custom_data: _custom_data

                """

    class IpNameServersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"ip_address": {"type": str}, "vrf": {"type": str}, "priority": {"type": int}, "_custom_data": {"type": dict}}
        ip_address: str
        """IPv4 or IPv6 address for DNS server."""
        vrf: str | None
        """VRF Name."""
        priority: int | None
        """Priority value (lower is first)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ip_address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                priority: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpNameServersItem.


                Subclass of AvdModel.

                Args:
                    ip_address: IPv4 or IPv6 address for DNS server.
                    vrf: VRF Name.
                    priority: Priority value (lower is first).
                    _custom_data: _custom_data

                """

    class IpNameServers(AvdList[IpNameServersItem]):
        """Subclass of AvdList with `IpNameServersItem` items."""

    IpNameServers._item_type = IpNameServersItem

    class IpNat(AvdModel):
        """Subclass of AvdModel."""

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "vrf": {"type": str},
                "destination": {"type": Destination},
                "source": {"type": Source},
                "_custom_data": {"type": dict},
            }
            name: str
            vrf: str | None
            """Specify VRF for NAT profile."""
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        vrf: Specify VRF for NAT profile.
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoolsItem(AvdModel):
            """Subclass of AvdModel."""

            class RangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "first_ip": {"type": str},
                    "last_ip": {"type": str},
                    "first_port": {"type": int},
                    "last_port": {"type": int},
                    "_custom_data": {"type": dict},
                }
                first_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                """
                last_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                `first_ip` and `last_ip` ip
                addresses should lie in same subnet.
                """
                first_port: int | None
                last_port: int | None
                """
                Required when `first_port` is set.
                `last_port` must be greater than or equal to `first_port`.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        first_ip: str | None | UndefinedType = Undefined,
                        last_ip: str | None | UndefinedType = Undefined,
                        first_port: int | None | UndefinedType = Undefined,
                        last_port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RangesItem.


                        Subclass of AvdModel.

                        Args:
                            first_ip:
                               IPv4 address.
                               Required when `type` is `ip-port` and ignored otherwise.
                            last_ip:
                               IPv4 address.
                               Required when `type` is `ip-port` and ignored otherwise.
                               `first_ip` and `last_ip` ip
                               addresses should lie in same subnet.
                            first_port: first_port
                            last_port:
                               Required when `first_port` is set.
                               `last_port` must be greater than or equal to `first_port`.
                            _custom_data: _custom_data

                        """

            class Ranges(AvdList[RangesItem]):
                """Subclass of AvdList with `RangesItem` items."""

            Ranges._item_type = RangesItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "type": {"type": str, "default": "ip-port"},
                "prefix_length": {"type": int},
                "ranges": {"type": Ranges},
                "utilization_log_threshold": {"type": int},
                "_custom_data": {"type": dict},
            }
            name: str
            type: Literal["ip-port", "port-only"]
            """Default value: `"ip-port"`"""
            prefix_length: int | None
            """It is only used and required when `type` is `ip-port`."""
            ranges: Ranges
            """Subclass of AvdList with `RangesItem` items."""
            utilization_log_threshold: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    type: Literal["ip-port", "port-only"] | UndefinedType = Undefined,
                    prefix_length: int | None | UndefinedType = Undefined,
                    ranges: Ranges | UndefinedType = Undefined,
                    utilization_log_threshold: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoolsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        type: type
                        prefix_length: It is only used and required when `type` is `ip-port`.
                        ranges: Subclass of AvdList with `RangesItem` items.
                        utilization_log_threshold: utilization_log_threshold
                        _custom_data: _custom_data

                    """

        class Pools(AvdIndexedList[str, PoolsItem]):
            """Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pools._item_type = PoolsItem

        class Synchronization(AvdModel):
            """Subclass of AvdModel."""

            class PortRange(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "first_port": {"type": int},
                    "last_port": {"type": int},
                    "split_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                first_port: int | None
                last_port: int | None
                """>= first_port."""
                split_disabled: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        first_port: int | None | UndefinedType = Undefined,
                        last_port: int | None | UndefinedType = Undefined,
                        split_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortRange.


                        Subclass of AvdModel.

                        Args:
                            first_port: first_port
                            last_port: >= first_port.
                            split_disabled: split_disabled
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "description": {"type": str},
                "expiry_interval": {"type": int},
                "local_interface": {"type": str},
                "peer_address": {"type": str},
                "port_range": {"type": PortRange},
                "shutdown": {"type": bool},
                "_custom_data": {"type": dict},
            }
            description: str | None
            expiry_interval: int | None
            """In seconds."""
            local_interface: str | None
            """EOS interface name."""
            peer_address: str | None
            """IPv4 address."""
            port_range: PortRange
            """Subclass of AvdModel."""
            shutdown: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    expiry_interval: int | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    peer_address: str | None | UndefinedType = Undefined,
                    port_range: PortRange | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Synchronization.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        expiry_interval: In seconds.
                        local_interface: EOS interface name.
                        peer_address: IPv4 address.
                        port_range: Subclass of AvdModel.
                        shutdown: shutdown
                        _custom_data: _custom_data

                    """

        class Translation(AvdModel):
            """Subclass of AvdModel."""

            class AddressSelection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"any": {"type": bool}, "hash_field_source_ip": {"type": bool}, "_custom_data": {"type": dict}}
                any: bool | None
                hash_field_source_ip: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        any: bool | None | UndefinedType = Undefined,
                        hash_field_source_ip: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressSelection.


                        Subclass of AvdModel.

                        Args:
                            any: any
                            hash_field_source_ip: hash_field_source_ip
                            _custom_data: _custom_data

                        """

            class LowMark(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"percentage": {"type": int}, "host_percentage": {"type": int}, "_custom_data": {"type": dict}}
                percentage: int | None
                """Used to render 'ip nat translation low-mark <percentage>'."""
                host_percentage: int | None
                """Used to render 'ip nat translation low-mark <host_percentage> host'."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        percentage: int | None | UndefinedType = Undefined,
                        host_percentage: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LowMark.


                        Subclass of AvdModel.

                        Args:
                            percentage: Used to render 'ip nat translation low-mark <percentage>'.
                            host_percentage: Used to render 'ip nat translation low-mark <host_percentage> host'.
                            _custom_data: _custom_data

                        """

            class MaxEntries(AvdModel):
                """Subclass of AvdModel."""

                class IpLimitsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip": {"type": str}, "limit": {"type": int}, "_custom_data": {"type": dict}}
                    ip: str
                    """IPv4 address."""
                    limit: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip: str | UndefinedType = Undefined,
                            limit: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpLimitsItem.


                            Subclass of AvdModel.

                            Args:
                                ip: IPv4 address.
                                limit: limit
                                _custom_data: _custom_data

                            """

                class IpLimits(AvdIndexedList[str, IpLimitsItem]):
                    """Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`)."""

                    _primary_key: ClassVar[str] = "ip"

                IpLimits._item_type = IpLimitsItem

                _fields: ClassVar[dict] = {"limit": {"type": int}, "host_limit": {"type": int}, "ip_limits": {"type": IpLimits}, "_custom_data": {"type": dict}}
                limit: int | None
                host_limit: int | None
                ip_limits: IpLimits
                """Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        limit: int | None | UndefinedType = Undefined,
                        host_limit: int | None | UndefinedType = Undefined,
                        ip_limits: IpLimits | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MaxEntries.


                        Subclass of AvdModel.

                        Args:
                            limit: limit
                            host_limit: host_limit
                            ip_limits: Subclass of AvdIndexedList with `IpLimitsItem` items. Primary key is `ip` (`str`).
                            _custom_data: _custom_data

                        """

            class TimeoutsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protocol": {"type": str}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                protocol: Literal["tcp", "udp"]
                timeout: int
                """In seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        protocol: Literal["tcp", "udp"] | UndefinedType = Undefined,
                        timeout: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TimeoutsItem.


                        Subclass of AvdModel.

                        Args:
                            protocol: protocol
                            timeout: In seconds.
                            _custom_data: _custom_data

                        """

            class Timeouts(AvdIndexedList[str, TimeoutsItem]):
                """Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`)."""

                _primary_key: ClassVar[str] = "protocol"

            Timeouts._item_type = TimeoutsItem

            _fields: ClassVar[dict] = {
                "address_selection": {"type": AddressSelection},
                "counters": {"type": bool},
                "low_mark": {"type": LowMark},
                "max_entries": {"type": MaxEntries},
                "timeouts": {"type": Timeouts},
                "_custom_data": {"type": dict},
            }
            address_selection: AddressSelection
            """Subclass of AvdModel."""
            counters: bool | None
            low_mark: LowMark
            """Subclass of AvdModel."""
            max_entries: MaxEntries
            """Subclass of AvdModel."""
            timeouts: Timeouts
            """Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address_selection: AddressSelection | UndefinedType = Undefined,
                    counters: bool | None | UndefinedType = Undefined,
                    low_mark: LowMark | UndefinedType = Undefined,
                    max_entries: MaxEntries | UndefinedType = Undefined,
                    timeouts: Timeouts | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Translation.


                    Subclass of AvdModel.

                    Args:
                        address_selection: Subclass of AvdModel.
                        counters: counters
                        low_mark: Subclass of AvdModel.
                        max_entries: Subclass of AvdModel.
                        timeouts: Subclass of AvdIndexedList with `TimeoutsItem` items. Primary key is `protocol` (`str`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "kernel_buffer_size": {"type": int},
            "profiles": {"type": Profiles},
            "pools": {"type": Pools},
            "synchronization": {"type": Synchronization},
            "translation": {"type": Translation},
            "_custom_data": {"type": dict},
        }
        kernel_buffer_size: int | None
        """Buffer size in MB."""
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        pools: Pools
        """Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`)."""
        synchronization: Synchronization
        """Subclass of AvdModel."""
        translation: Translation
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                kernel_buffer_size: int | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                pools: Pools | UndefinedType = Undefined,
                synchronization: Synchronization | UndefinedType = Undefined,
                translation: Translation | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpNat.


                Subclass of AvdModel.

                Args:
                    kernel_buffer_size: Buffer size in MB.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    pools: Subclass of AvdIndexedList with `PoolsItem` items. Primary key is `name` (`str`).
                    synchronization: Subclass of AvdModel.
                    translation: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class IpRadiusSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str | None
        """Interface Name."""
        vrf: str | None
        """VRF Name."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpRadiusSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.
                    _custom_data: _custom_data

                """

    class IpRadiusSourceInterfaces(AvdList[IpRadiusSourceInterfacesItem]):
        """Subclass of AvdList with `IpRadiusSourceInterfacesItem` items."""

    IpRadiusSourceInterfaces._item_type = IpRadiusSourceInterfacesItem

    class IpSecurity(AvdModel):
        """Subclass of AvdModel."""

        class IkePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "local_id": {"type": str},
                "local_id_fqdn": {"type": str},
                "ike_lifetime": {"type": int},
                "encryption": {"type": str},
                "dh_group": {"type": int},
                "integrity": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Policy name."""
            local_id: str | None
            """
            Local IKE identification.
            Can be an IPv4 or an IPv6 address.
            If both `local_id` and `local_id_fqdn`
            are set, `local_id_fqdn` takes precedence.
            """
            local_id_fqdn: str | None
            """
            Local FQDN or UFQDN IKE identification.
            If both `local_id` and `local_id_fqdn` are set,
            `local_id_fqdn` takes precedence.
            """
            ike_lifetime: int | None
            """IKE lifetime in hours."""
            encryption: Literal["3des", "aes128", "aes256"] | None
            """IKE encryption algorithm."""
            dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 20, 21, 24] | None
            """Diffie-Hellman group for the key exchange."""
            integrity: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            """Integrity algorithm."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    local_id: str | None | UndefinedType = Undefined,
                    local_id_fqdn: str | None | UndefinedType = Undefined,
                    ike_lifetime: int | None | UndefinedType = Undefined,
                    encryption: Literal["3des", "aes128", "aes256"] | None | UndefinedType = Undefined,
                    dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 20, 21, 24] | None | UndefinedType = Undefined,
                    integrity: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IkePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        local_id:
                           Local IKE identification.
                           Can be an IPv4 or an IPv6 address.
                           If both `local_id` and `local_id_fqdn`
                           are set, `local_id_fqdn` takes precedence.
                        local_id_fqdn:
                           Local FQDN or UFQDN IKE identification.
                           If both `local_id` and `local_id_fqdn` are set,
                           `local_id_fqdn` takes precedence.
                        ike_lifetime: IKE lifetime in hours.
                        encryption: IKE encryption algorithm.
                        dh_group: Diffie-Hellman group for the key exchange.
                        integrity: Integrity algorithm.
                        _custom_data: _custom_data

                    """

        class IkePolicies(AvdIndexedList[str, IkePoliciesItem]):
            """Subclass of AvdIndexedList with `IkePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        IkePolicies._item_type = IkePoliciesItem

        class SaPoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class SaLifetime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"value": {"type": int}, "unit": {"type": str, "default": "hours"}, "_custom_data": {"type": dict}}
                value: int | None
                """
                Lifetime value for this SA.
                Valid range depends on the unit.
                <1-24>       Lifetime in hours (
                default )
                <1-4000000>  Packet limit in thousands
                <1-6000>     Byte limit in GB ( 1024 MB )
                <1-6144000>  Byte limit in MB ( 1024 KB )
                """
                unit: Literal["gigabytes", "hours", "megabytes", "thousand-packets"]
                """Default value: `"hours"`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        value: int | None | UndefinedType = Undefined,
                        unit: Literal["gigabytes", "hours", "megabytes", "thousand-packets"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SaLifetime.


                        Subclass of AvdModel.

                        Args:
                            value:
                               Lifetime value for this SA.
                               Valid range depends on the unit.
                               <1-24>       Lifetime in hours (
                               default )
                               <1-4000000>  Packet limit in thousands
                               <1-6000>     Byte limit in GB ( 1024 MB )
                               <1-6144000>  Byte limit in MB ( 1024 KB )
                            unit: unit
                            _custom_data: _custom_data

                        """

            class Esp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"integrity": {"type": str}, "encryption": {"type": str}, "_custom_data": {"type": dict}}
                integrity: Literal["disabled", "sha1", "sha256", "sha384", "sha512", "md5"] | None
                encryption: Literal["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        integrity: Literal["disabled", "sha1", "sha256", "sha384", "sha512", "md5"] | None | UndefinedType = Undefined,
                        encryption: Literal["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Esp.


                        Subclass of AvdModel.

                        Args:
                            integrity: integrity
                            encryption: encryption
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "sa_lifetime": {"type": SaLifetime},
                "esp": {"type": Esp},
                "pfs_dh_group": {"type": int},
                "_custom_data": {"type": dict},
            }
            name: str
            """Name of the SA policy."""
            sa_lifetime: SaLifetime
            """Subclass of AvdModel."""
            esp: Esp
            """Subclass of AvdModel."""
            pfs_dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 20, 21, 24] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    sa_lifetime: SaLifetime | UndefinedType = Undefined,
                    esp: Esp | UndefinedType = Undefined,
                    pfs_dh_group: Literal[1, 2, 5, 14, 15, 16, 17, 20, 21, 24] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SaPoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of the SA policy.
                        sa_lifetime: Subclass of AvdModel.
                        esp: Subclass of AvdModel.
                        pfs_dh_group: pfs_dh_group
                        _custom_data: _custom_data

                    """

        class SaPolicies(AvdIndexedList[str, SaPoliciesItem]):
            """Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SaPolicies._item_type = SaPoliciesItem

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Dpd(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "time": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
                interval: int
                """Interval (in seconds) between keep-alive messages."""
                time: int
                """Time (in seconds) after which the action is applied."""
                action: Literal["clear", "hold", "restart"]
                """
                Action to apply.

                * 'clear': Delete all connections
                * 'hold': Re-negotiate connection on demand
                *
                'restart': Restart connection immediately
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | UndefinedType = Undefined,
                        time: int | UndefinedType = Undefined,
                        action: Literal["clear", "hold", "restart"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dpd.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval (in seconds) between keep-alive messages.
                            time: Time (in seconds) after which the action is applied.
                            action:
                               Action to apply.

                               * 'clear': Delete all connections
                               * 'hold': Re-negotiate connection on demand
                               *
                               'restart': Restart connection immediately
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "ike_policy": {"type": str},
                "sa_policy": {"type": str},
                "connection": {"type": str},
                "shared_key": {"type": str},
                "dpd": {"type": Dpd},
                "mode": {"type": str},
                "flow_parallelization_encapsulation_udp": {"type": bool},
                "_custom_data": {"type": dict},
            }
            name: str
            """Name of the IPsec profile."""
            ike_policy: str | None
            """Name of the IKE policy to use in this profile."""
            sa_policy: str | None
            """Name of the Security Association to use in this profile."""
            connection: Literal["add", "start", "route"] | None
            """IPsec connection (Initiator/Responder/Dynamic)."""
            shared_key: str | None
            """Encrypted password - only type 7 supported."""
            dpd: Dpd
            """
            Dead Peer Detection.

            Subclass of AvdModel.
            """
            mode: Literal["transport", "tunnel"] | None
            """Ipsec mode type."""
            flow_parallelization_encapsulation_udp: bool | None
            """
            Enable flow parallelization.
            When enabled, multiple cores are used to parallelize the IPsec
            encryption and decryption processing.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ike_policy: str | None | UndefinedType = Undefined,
                    sa_policy: str | None | UndefinedType = Undefined,
                    connection: Literal["add", "start", "route"] | None | UndefinedType = Undefined,
                    shared_key: str | None | UndefinedType = Undefined,
                    dpd: Dpd | UndefinedType = Undefined,
                    mode: Literal["transport", "tunnel"] | None | UndefinedType = Undefined,
                    flow_parallelization_encapsulation_udp: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of the IPsec profile.
                        ike_policy: Name of the IKE policy to use in this profile.
                        sa_policy: Name of the Security Association to use in this profile.
                        connection: IPsec connection (Initiator/Responder/Dynamic).
                        shared_key: Encrypted password - only type 7 supported.
                        dpd:
                           Dead Peer Detection.

                           Subclass of AvdModel.
                        mode: Ipsec mode type.
                        flow_parallelization_encapsulation_udp:
                           Enable flow parallelization.
                           When enabled, multiple cores are used to parallelize the IPsec
                           encryption and decryption processing.
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class KeyController(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"profile": {"type": str}, "_custom_data": {"type": dict}}
            profile: str | None
            """IPsec profile name to use."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, profile: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    KeyController.


                    Subclass of AvdModel.

                    Args:
                        profile: IPsec profile name to use.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "ike_policies": {"type": IkePolicies},
            "sa_policies": {"type": SaPolicies},
            "profiles": {"type": Profiles},
            "key_controller": {"type": KeyController},
            "hardware_encryption_disabled": {"type": bool, "default": False},
            "_custom_data": {"type": dict},
        }
        ike_policies: IkePolicies
        """
        Internet Security Association and Key Mgmt Protocol.

        Subclass of AvdIndexedList with
        `IkePoliciesItem` items. Primary key is `name` (`str`).
        """
        sa_policies: SaPolicies
        """
        Security Association policies.

        Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key
        is `name` (`str`).
        """
        profiles: Profiles
        """
        IPSec profiles.

        Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name`
        (`str`).
        """
        key_controller: KeyController
        """Subclass of AvdModel."""
        hardware_encryption_disabled: bool
        """
        Disable hardware encryption.
        An SFE restart is needed for this change to take effect.

        Default value: `False`
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ike_policies: IkePolicies | UndefinedType = Undefined,
                sa_policies: SaPolicies | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                key_controller: KeyController | UndefinedType = Undefined,
                hardware_encryption_disabled: bool | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpSecurity.


                Subclass of AvdModel.

                Args:
                    ike_policies:
                       Internet Security Association and Key Mgmt Protocol.

                       Subclass of AvdIndexedList with
                       `IkePoliciesItem` items. Primary key is `name` (`str`).
                    sa_policies:
                       Security Association policies.

                       Subclass of AvdIndexedList with `SaPoliciesItem` items. Primary key
                       is `name` (`str`).
                    profiles:
                       IPSec profiles.

                       Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name`
                       (`str`).
                    key_controller: Subclass of AvdModel.
                    hardware_encryption_disabled:
                       Disable hardware encryption.
                       An SFE restart is needed for this change to take effect.
                    _custom_data: _custom_data

                """

    class IpSshClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str, "default": "default"}, "_custom_data": {"type": dict}}
        name: str | None
        """Interface Name."""
        vrf: str
        """Default value: `"default"`"""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                vrf: str | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpSshClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: vrf
                    _custom_data: _custom_data

                """

    class IpSshClientSourceInterfaces(AvdList[IpSshClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpSshClientSourceInterfacesItem` items."""

    IpSshClientSourceInterfaces._item_type = IpSshClientSourceInterfacesItem

    class IpTacacsSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str | None
        """Interface name."""
        vrf: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpTacacsSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface name.
                    vrf: vrf
                    _custom_data: _custom_data

                """

    class IpTacacsSourceInterfaces(AvdList[IpTacacsSourceInterfacesItem]):
        """Subclass of AvdList with `IpTacacsSourceInterfacesItem` items."""

    IpTacacsSourceInterfaces._item_type = IpTacacsSourceInterfacesItem

    class IpTelnetClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpTelnetClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.
                    _custom_data: _custom_data

                """

    class IpTelnetClientSourceInterfaces(AvdList[IpTelnetClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items."""

    IpTelnetClientSourceInterfaces._item_type = IpTelnetClientSourceInterfacesItem

    class IpTftpClientSourceInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                IpTftpClientSourceInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Interface Name.
                    vrf: VRF Name.
                    _custom_data: _custom_data

                """

    class IpTftpClientSourceInterfaces(AvdList[IpTftpClientSourceInterfacesItem]):
        """Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items."""

    IpTftpClientSourceInterfaces._item_type = IpTftpClientSourceInterfacesItem

    class Ipv6AccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ipv6 any any"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
            "_custom_data": {"type": dict},
        }
        name: str
        """IPv6 Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: IPv6 Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class Ipv6AccessLists(AvdIndexedList[str, Ipv6AccessListsItem]):
        """Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6AccessLists._item_type = Ipv6AccessListsItem

    class Ipv6DhcpRelay(AvdModel):
        """Subclass of AvdModel."""

        class Option(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"link_layer_address": {"type": bool}, "remote_id_format": {"type": str}, "_custom_data": {"type": dict}}
            link_layer_address: bool | None
            """Add Option 79 (Link Layer Address Option)."""
            remote_id_format: Literal["%m:%i", "%m:%p"] | None
            """
            Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
            name (`%m:%p`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    link_layer_address: bool | None | UndefinedType = Undefined,
                    remote_id_format: Literal["%m:%i", "%m:%p"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Option.


                    Subclass of AvdModel.

                    Args:
                        link_layer_address: Add Option 79 (Link Layer Address Option).
                        remote_id_format:
                           Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
                           name (`%m:%p`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"always_on": {"type": bool}, "all_subnets": {"type": bool}, "option": {"type": Option}, "_custom_data": {"type": dict}}
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode, off by default."""
        all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        option: Option
        """
        Insert DHCP Option.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                always_on: bool | None | UndefinedType = Undefined,
                all_subnets: bool | None | UndefinedType = Undefined,
                option: Option | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6DhcpRelay.


                Subclass of AvdModel.

                Args:
                    always_on: DhcpRelay Agent will be in always-on mode, off by default.
                    all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                    option:
                       Insert DHCP Option.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Ipv6Hardware(AvdModel):
        """Subclass of AvdModel."""

        class Fib(AvdModel):
            """Subclass of AvdModel."""

            class Optimize(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str | None
                    """Pre-defined profile 'internet' or user-defined profile name."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, profile: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Prefixes.


                            Subclass of AvdModel.

                            Args:
                                profile: Pre-defined profile 'internet' or user-defined profile name.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
                prefixes: Prefixes
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, prefixes: Prefixes | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Optimize.


                        Subclass of AvdModel.

                        Args:
                            prefixes: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"optimize": {"type": Optimize}, "_custom_data": {"type": dict}}
            optimize: Optimize
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, optimize: Optimize | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Fib.


                    Subclass of AvdModel.

                    Args:
                        optimize: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"fib": {"type": Fib}, "_custom_data": {"type": dict}}
        fib: Fib
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, fib: Fib | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                Ipv6Hardware.


                Subclass of AvdModel.

                Args:
                    fib: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Ipv6Neighbor(AvdModel):
        """Subclass of AvdModel."""

        class StaticEntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_address": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "mac_address": {"type": str},
                "_custom_data": {"type": dict},
            }
            ipv6_address: str
            """IPv6 address of neighbor."""
            vrf: str | None
            interface: str
            """Interface name."""
            mac_address: str
            """MAC address of neighbor like 'aa:af:12:34:bc:bf'"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    interface: str | UndefinedType = Undefined,
                    mac_address: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticEntriesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_address: IPv6 address of neighbor.
                        vrf: vrf
                        interface: Interface name.
                        mac_address: MAC address of neighbor like 'aa:af:12:34:bc:bf'
                        _custom_data: _custom_data

                    """

        class StaticEntries(AvdList[StaticEntriesItem]):
            """Subclass of AvdList with `StaticEntriesItem` items."""

        StaticEntries._item_type = StaticEntriesItem

        class Persistent(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "refresh_delay": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool
            """Restore the IPv6 neighbor cache after reboot."""
            refresh_delay: int | None
            """
            Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
            It
            will require setting the `enabled` key to true.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    refresh_delay: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Persistent.


                    Subclass of AvdModel.

                    Args:
                        enabled: Restore the IPv6 neighbor cache after reboot.
                        refresh_delay:
                           Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
                           It
                           will require setting the `enabled` key to true.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"static_entries": {"type": StaticEntries}, "persistent": {"type": Persistent}, "_custom_data": {"type": dict}}
        static_entries: StaticEntries
        """
        Static IPv6 neighbor entries.

        Subclass of AvdList with `StaticEntriesItem` items.
        """
        persistent: Persistent
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                static_entries: StaticEntries | UndefinedType = Undefined,
                persistent: Persistent | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6Neighbor.


                Subclass of AvdModel.

                Args:
                    static_entries:
                       Static IPv6 neighbor entries.

                       Subclass of AvdList with `StaticEntriesItem` items.
                    persistent: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Ipv6PrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6PrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Prefix-list Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class Ipv6PrefixLists(AvdIndexedList[str, Ipv6PrefixListsItem]):
        """Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6PrefixLists._item_type = Ipv6PrefixListsItem

    class Ipv6StandardAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ipv6 any any"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
            "_custom_data": {"type": dict},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6StandardAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class Ipv6StandardAccessLists(AvdIndexedList[str, Ipv6StandardAccessListsItem]):
        """Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Ipv6StandardAccessLists._item_type = Ipv6StandardAccessListsItem

    class Ipv6StaticRoutesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
            "_custom_data": {"type": dict},
        }
        vrf: str | None
        destination_address_prefix: str | None
        """IPv6 Network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv6 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destination_address_prefix: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                track_bfd: bool | None | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
                tag: int | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                metric: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6StaticRoutesItem.


                Subclass of AvdModel.

                Args:
                    vrf: vrf
                    destination_address_prefix: IPv6 Network/Mask.
                    interface: interface
                    gateway: IPv6 Address.
                    track_bfd: Track next-hop using BFD.
                    distance: distance
                    tag: tag
                    name: Description.
                    metric: metric
                    _custom_data: _custom_data

                """

    class Ipv6StaticRoutes(AvdList[Ipv6StaticRoutesItem]):
        """Subclass of AvdList with `Ipv6StaticRoutesItem` items."""

    Ipv6StaticRoutes._item_type = Ipv6StaticRoutesItem

    class L2Protocol(AvdModel):
        """Subclass of AvdModel."""

        class ForwardingProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ProtocolsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "forward": {"type": bool},
                    "tagged_forward": {"type": bool},
                    "untagged_forward": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                name: Literal["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"]
                forward: bool | None
                tagged_forward: bool | None
                untagged_forward: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: Literal["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"] | UndefinedType = Undefined,
                        forward: bool | None | UndefinedType = Undefined,
                        tagged_forward: bool | None | UndefinedType = Undefined,
                        untagged_forward: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProtocolsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            forward: forward
                            tagged_forward: tagged_forward
                            untagged_forward: untagged_forward
                            _custom_data: _custom_data

                        """

            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Protocols._item_type = ProtocolsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "protocols": {"type": Protocols}, "_custom_data": {"type": dict}}
            name: str
            protocols: Protocols
            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ForwardingProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class ForwardingProfiles(AvdIndexedList[str, ForwardingProfilesItem]):
            """Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ForwardingProfiles._item_type = ForwardingProfilesItem

        _fields: ClassVar[dict] = {"forwarding_profiles": {"type": ForwardingProfiles}, "_custom_data": {"type": dict}}
        forwarding_profiles: ForwardingProfiles
        """Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self, *, forwarding_profiles: ForwardingProfiles | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
            ) -> None:
                """
                L2Protocol.


                Subclass of AvdModel.

                Args:
                    forwarding_profiles: Subclass of AvdIndexedList with `ForwardingProfilesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Lacp(AvdModel):
        """Subclass of AvdModel."""

        class PortId(AvdModel):
            """Subclass of AvdModel."""

            class Range(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"begin": {"type": int}, "end": {"type": int}, "_custom_data": {"type": dict}}
                begin: int | None
                """Minimum LACP port-ID range."""
                end: int | None
                """Maximum LACP port-ID range."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        begin: int | None | UndefinedType = Undefined,
                        end: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Range.


                        Subclass of AvdModel.

                        Args:
                            begin: Minimum LACP port-ID range.
                            end: Maximum LACP port-ID range.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"range": {"type": Range}, "_custom_data": {"type": dict}}
            range: Range
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, range: Range | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    PortId.


                    Subclass of AvdModel.

                    Args:
                        range: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class RateLimit(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": bool}, "_custom_data": {"type": dict}}
            default: bool | None
            """Enable LACPDU rate limiting by default on all ports."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, default: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    RateLimit.


                    Subclass of AvdModel.

                    Args:
                        default: Enable LACPDU rate limiting by default on all ports.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "port_id": {"type": PortId},
            "rate_limit": {"type": RateLimit},
            "system_priority": {"type": int},
            "_custom_data": {"type": dict},
        }
        port_id: PortId
        """
        LACP port-ID range configuration.

        Subclass of AvdModel.
        """
        rate_limit: RateLimit
        """
        Set LACPDU rate limit options.

        Subclass of AvdModel.
        """
        system_priority: int | None
        """Set local system LACP priority."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                port_id: PortId | UndefinedType = Undefined,
                rate_limit: RateLimit | UndefinedType = Undefined,
                system_priority: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Lacp.


                Subclass of AvdModel.

                Args:
                    port_id:
                       LACP port-ID range configuration.

                       Subclass of AvdModel.
                    rate_limit:
                       Set LACPDU rate limit options.

                       Subclass of AvdModel.
                    system_priority: Set local system LACP priority.
                    _custom_data: _custom_data

                """

    class LinkTrackingGroupsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "links_minimum": {"type": int}, "recovery_delay": {"type": int}, "_custom_data": {"type": dict}}
        name: str
        links_minimum: int | None
        recovery_delay: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                links_minimum: int | None | UndefinedType = Undefined,
                recovery_delay: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTrackingGroupsItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    links_minimum: links_minimum
                    recovery_delay: recovery_delay
                    _custom_data: _custom_data

                """

    class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LinkTrackingGroups._item_type = LinkTrackingGroupsItem

    class Lldp(AvdModel):
        """Subclass of AvdModel."""

        class TlvsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "transmit": {"type": bool}, "_custom_data": {"type": dict}}
            name: Literal[
                "link-aggregation",
                "management-address",
                "max-frame-size",
                "med",
                "port-description",
                "port-vlan",
                "power-via-mdi",
                "system-capabilities",
                "system-description",
                "system-name",
                "vlan-name",
            ]
            transmit: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: Literal[
                        "link-aggregation",
                        "management-address",
                        "max-frame-size",
                        "med",
                        "port-description",
                        "port-vlan",
                        "power-via-mdi",
                        "system-capabilities",
                        "system-description",
                        "system-name",
                        "vlan-name",
                    ]
                    | UndefinedType = Undefined,
                    transmit: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TlvsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        transmit: transmit
                        _custom_data: _custom_data

                    """

        class Tlvs(AvdIndexedList[str, TlvsItem]):
            """Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Tlvs._item_type = TlvsItem

        _fields: ClassVar[dict] = {
            "timer": {"type": int},
            "timer_reinitialization": {"type": str},
            "holdtime": {"type": int},
            "management_address": {"type": str},
            "vrf": {"type": str},
            "receive_packet_tagged_drop": {"type": str},
            "tlvs": {"type": Tlvs},
            "run": {"type": bool},
            "_custom_data": {"type": dict},
        }
        timer: int | None
        timer_reinitialization: str | None
        holdtime: int | None
        management_address: str | None
        vrf: str | None
        receive_packet_tagged_drop: str | None
        tlvs: Tlvs
        """Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`)."""
        run: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                timer: int | None | UndefinedType = Undefined,
                timer_reinitialization: str | None | UndefinedType = Undefined,
                holdtime: int | None | UndefinedType = Undefined,
                management_address: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                receive_packet_tagged_drop: str | None | UndefinedType = Undefined,
                tlvs: Tlvs | UndefinedType = Undefined,
                run: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Lldp.


                Subclass of AvdModel.

                Args:
                    timer: timer
                    timer_reinitialization: timer_reinitialization
                    holdtime: holdtime
                    management_address: management_address
                    vrf: vrf
                    receive_packet_tagged_drop: receive_packet_tagged_drop
                    tlvs: Subclass of AvdIndexedList with `TlvsItem` items. Primary key is `name` (`str`).
                    run: run
                    _custom_data: _custom_data

                """

    class LoadInterval(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"default": {"type": int}, "_custom_data": {"type": dict}}
        default: int | None
        """Default load interval in seconds."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, default: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                LoadInterval.


                Subclass of AvdModel.

                Args:
                    default: Default load interval in seconds.
                    _custom_data: _custom_data

                """

    class LocalUsersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "disabled": {"type": bool},
            "privilege": {"type": int},
            "role": {"type": str},
            "sha512_password": {"type": str},
            "no_password": {"type": bool},
            "ssh_key": {"type": str},
            "secondary_ssh_key": {"type": str},
            "shell": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Username."""
        disabled: bool | None
        """
        If true, the user will be removed and all other settings are ignored.
        Useful for removing the
        default "admin" user.
        """
        privilege: int | None
        """Initial privilege level with local EXEC authorization."""
        role: str | None
        """EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator"."""
        sha512_password: str | None
        """
        SHA512 Hash of Password.
        Must be the hash of the password. By default EOS salts the password with
        the username, so the simplest is to generate the hash on an EOS device using the same username.
        """
        no_password: bool | None
        """
        If set a password will not be configured for this user. "sha512_password" MUST not be defined for
        this user.
        """
        ssh_key: str | None
        secondary_ssh_key: str | None
        shell: Literal["/bin/bash", "/bin/sh", "/sbin/nologin"] | None
        """Specify shell for the user."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                privilege: int | None | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                sha512_password: str | None | UndefinedType = Undefined,
                no_password: bool | None | UndefinedType = Undefined,
                ssh_key: str | None | UndefinedType = Undefined,
                secondary_ssh_key: str | None | UndefinedType = Undefined,
                shell: Literal["/bin/bash", "/bin/sh", "/sbin/nologin"] | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                LocalUsersItem.


                Subclass of AvdModel.

                Args:
                    name: Username.
                    disabled:
                       If true, the user will be removed and all other settings are ignored.
                       Useful for removing the
                       default "admin" user.
                    privilege: Initial privilege level with local EXEC authorization.
                    role: EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator".
                    sha512_password:
                       SHA512 Hash of Password.
                       Must be the hash of the password. By default EOS salts the password with
                       the username, so the simplest is to generate the hash on an EOS device using the same username.
                    no_password:
                       If set a password will not be configured for this user. "sha512_password" MUST not be defined for
                       this user.
                    ssh_key: ssh_key
                    secondary_ssh_key: secondary_ssh_key
                    shell: Specify shell for the user.
                    _custom_data: _custom_data

                """

    class LocalUsers(AvdIndexedList[str, LocalUsersItem]):
        """Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LocalUsers._item_type = LocalUsersItem

    class Logging(AvdModel):
        """Subclass of AvdModel."""

        class Buffered(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"size": {"type": int}, "level": {"type": str}, "_custom_data": {"type": dict}}
            size: int | None
            level: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"] | None
            """Buffer logging severity level."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    size: int | None | UndefinedType = Undefined,
                    level: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                    | None
                    | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Buffered.


                    Subclass of AvdModel.

                    Args:
                        size: size
                        level: Buffer logging severity level.
                        _custom_data: _custom_data

                    """

        class Synchronous(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"level": {"type": str, "default": "critical"}, "_custom_data": {"type": dict}}
            level: Literal["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
            """
            Synchronous logging severity level.

            Default value: `"critical"`
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    level: Literal["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                    | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Synchronous.


                    Subclass of AvdModel.

                    Args:
                        level: Synchronous logging severity level.
                        _custom_data: _custom_data

                    """

        class Format(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "timestamp": {"type": str},
                "hostname": {"type": str},
                "sequence_numbers": {"type": bool},
                "rfc5424": {"type": bool},
                "_custom_data": {"type": dict},
            }
            timestamp: (
                Literal["high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"]
                | None
            )
            """Timestamp format."""
            hostname: Literal["fqdn", "ipv4"] | None
            """Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour)."""
            sequence_numbers: bool | None
            """Add sequence numbers to log messages."""
            rfc5424: bool | None
            """Forward logs in RFC5424 format."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    timestamp: Literal[
                        "high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"
                    ]
                    | None
                    | UndefinedType = Undefined,
                    hostname: Literal["fqdn", "ipv4"] | None | UndefinedType = Undefined,
                    sequence_numbers: bool | None | UndefinedType = Undefined,
                    rfc5424: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Format.


                    Subclass of AvdModel.

                    Args:
                        timestamp: Timestamp format.
                        hostname: Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour).
                        sequence_numbers: Add sequence numbers to log messages.
                        rfc5424: Forward logs in RFC5424 format.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class HostsItem(AvdModel):
                """Subclass of AvdModel."""

                class Ports(AvdList[int]):
                    """Subclass of AvdList with `int` items."""

                Ports._item_type = int

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "protocol": {"type": str, "default": "udp"},
                    "ports": {"type": Ports},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Syslog server name."""
                protocol: Literal["tcp", "udp"]
                """Default value: `"udp"`"""
                ports: Ports
                """Subclass of AvdList with `int` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        protocol: Literal["tcp", "udp"] | UndefinedType = Undefined,
                        ports: Ports | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Syslog server name.
                            protocol: protocol
                            ports: Subclass of AvdList with `int` items.
                            _custom_data: _custom_data

                        """

            class Hosts(AvdIndexedList[str, HostsItem]):
                """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "source_interface": {"type": str}, "hosts": {"type": Hosts}, "_custom_data": {"type": dict}}
            name: str
            """VRF name."""
            source_interface: str | None
            """Source interface name."""
            hosts: Hosts
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    hosts: Hosts | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        source_interface: Source interface name.
                        hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class Policy(AvdModel):
            """Subclass of AvdModel."""

            class Match(AvdModel):
                """Subclass of AvdModel."""

                class MatchListsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "action": {"type": str}, "_custom_data": {"type": dict}}
                    name: str
                    """Match list."""
                    action: Literal["discard"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            action: Literal["discard"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchListsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Match list.
                                action: action
                                _custom_data: _custom_data

                            """

                class MatchLists(AvdIndexedList[str, MatchListsItem]):
                    """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                MatchLists._item_type = MatchListsItem

                _fields: ClassVar[dict] = {"match_lists": {"type": MatchLists}, "_custom_data": {"type": dict}}
                match_lists: MatchLists
                """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, match_lists: MatchLists | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Match.


                        Subclass of AvdModel.

                        Args:
                            match_lists: Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `name` (`str`).
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"match": {"type": Match}, "_custom_data": {"type": dict}}
            match: Match
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, match: Match | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Policy.


                    Subclass of AvdModel.

                    Args:
                        match: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Event(AvdModel):
            """Subclass of AvdModel."""

            class StormControl(AvdModel):
                """Subclass of AvdModel."""

                class Discards(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"field_global": {"type": bool}, "interval": {"type": int}, "_custom_data": {"type": dict}}
                    _field_to_key_map: ClassVar[dict] = {"field_global": "global"}
                    _key_to_field_map: ClassVar[dict] = {"global": "field_global"}
                    field_global: bool | None
                    interval: int | None
                    """Logging interval in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_global: bool | None | UndefinedType = Undefined,
                            interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Discards.


                            Subclass of AvdModel.

                            Args:
                                field_global: field_global
                                interval: Logging interval in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"discards": {"type": Discards}, "_custom_data": {"type": dict}}
                discards: Discards
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, discards: Discards | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        StormControl.


                        Subclass of AvdModel.

                        Args:
                            discards: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "congestion_drops_interval": {"type": int},
                "global_link_status": {"type": bool},
                "storm_control": {"type": StormControl},
                "_custom_data": {"type": dict},
            }
            congestion_drops_interval: int | None
            """Logging interval in seconds."""
            global_link_status: bool | None
            storm_control: StormControl
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    congestion_drops_interval: int | None | UndefinedType = Undefined,
                    global_link_status: bool | None | UndefinedType = Undefined,
                    storm_control: StormControl | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Event.


                    Subclass of AvdModel.

                    Args:
                        congestion_drops_interval: Logging interval in seconds.
                        global_link_status: global_link_status
                        storm_control: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class LevelItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"facility": {"type": str}, "severity": {"type": str}, "_custom_data": {"type": dict}}
            facility: str
            severity: (
                Literal[
                    "alerts",
                    "critical",
                    "debugging",
                    "emergencies",
                    "errors",
                    "informational",
                    "notifications",
                    "warnings",
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                ]
                | None
            )
            """
            Severity of facility. Below are the supported severities.
            emergencies    System is unusable
            (severity=0)
            alerts         Immediate action needed           (severity=1)
            critical       Critical
            conditions               (severity=2)
            errors         Error conditions                  (severity=3)
            warnings       Warning conditions                (severity=4)
            notifications  Normal but significant
            conditions (severity=5)
            informational  Informational messages            (severity=6)
            debugging
            Debugging messages                (severity=7)
            <0-7>          Severity level value
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    facility: str | UndefinedType = Undefined,
                    severity: Literal[
                        "alerts",
                        "critical",
                        "debugging",
                        "emergencies",
                        "errors",
                        "informational",
                        "notifications",
                        "warnings",
                        "0",
                        "1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                    ]
                    | None
                    | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LevelItem.


                    Subclass of AvdModel.

                    Args:
                        facility: facility
                        severity:
                           Severity of facility. Below are the supported severities.
                           emergencies    System is unusable
                           (severity=0)
                           alerts         Immediate action needed           (severity=1)
                           critical       Critical
                           conditions               (severity=2)
                           errors         Error conditions                  (severity=3)
                           warnings       Warning conditions                (severity=4)
                           notifications  Normal but significant
                           conditions (severity=5)
                           informational  Informational messages            (severity=6)
                           debugging
                           Debugging messages                (severity=7)
                           <0-7>          Severity level value
                        _custom_data: _custom_data

                    """

        class Level(AvdIndexedList[str, LevelItem]):
            """Subclass of AvdIndexedList with `LevelItem` items. Primary key is `facility` (`str`)."""

            _primary_key: ClassVar[str] = "facility"

        Level._item_type = LevelItem

        _fields: ClassVar[dict] = {
            "console": {"type": str},
            "monitor": {"type": str},
            "buffered": {"type": Buffered},
            "repeat_messages": {"type": bool},
            "trap": {"type": str},
            "synchronous": {"type": Synchronous},
            "format": {"type": Format},
            "facility": {"type": str},
            "source_interface": {"type": str},
            "vrfs": {"type": Vrfs},
            "policy": {"type": Policy},
            "event": {"type": Event},
            "level": {"type": Level},
            "_custom_data": {"type": dict},
        }
        console: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"] | None
        """Console logging severity level."""
        monitor: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"] | None
        """Monitor logging severity level."""
        buffered: Buffered
        """Subclass of AvdModel."""
        repeat_messages: bool | None
        """Summarize concurrent repeat messages."""
        trap: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"] | None
        """Trap logging severity level."""
        synchronous: Synchronous
        """Subclass of AvdModel."""
        format: Format
        """Subclass of AvdModel."""
        facility: (
            Literal[
                "auth",
                "cron",
                "daemon",
                "kern",
                "local0",
                "local1",
                "local2",
                "local3",
                "local4",
                "local5",
                "local6",
                "local7",
                "lpr",
                "mail",
                "news",
                "sys9",
                "sys10",
                "sys11",
                "sys12",
                "sys13",
                "sys14",
                "syslog",
                "user",
                "uucp",
            ]
            | None
        )
        source_interface: str | None
        """Source Interface Name."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        policy: Policy
        """Subclass of AvdModel."""
        event: Event
        """Subclass of AvdModel."""
        level: Level
        """
        Configure logging severity.

        Subclass of AvdIndexedList with `LevelItem` items. Primary key is
        `facility` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                console: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
                | None
                | UndefinedType = Undefined,
                monitor: Literal["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
                | None
                | UndefinedType = Undefined,
                buffered: Buffered | UndefinedType = Undefined,
                repeat_messages: bool | None | UndefinedType = Undefined,
                trap: Literal["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"]
                | None
                | UndefinedType = Undefined,
                synchronous: Synchronous | UndefinedType = Undefined,
                format: Format | UndefinedType = Undefined,
                facility: Literal[
                    "auth",
                    "cron",
                    "daemon",
                    "kern",
                    "local0",
                    "local1",
                    "local2",
                    "local3",
                    "local4",
                    "local5",
                    "local6",
                    "local7",
                    "lpr",
                    "mail",
                    "news",
                    "sys9",
                    "sys10",
                    "sys11",
                    "sys12",
                    "sys13",
                    "sys14",
                    "syslog",
                    "user",
                    "uucp",
                ]
                | None
                | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                policy: Policy | UndefinedType = Undefined,
                event: Event | UndefinedType = Undefined,
                level: Level | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Logging.


                Subclass of AvdModel.

                Args:
                    console: Console logging severity level.
                    monitor: Monitor logging severity level.
                    buffered: Subclass of AvdModel.
                    repeat_messages: Summarize concurrent repeat messages.
                    trap: Trap logging severity level.
                    synchronous: Subclass of AvdModel.
                    format: Subclass of AvdModel.
                    facility: facility
                    source_interface: Source Interface Name.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    policy: Subclass of AvdModel.
                    event: Subclass of AvdModel.
                    level:
                       Configure logging severity.

                       Subclass of AvdIndexedList with `LevelItem` items. Primary key is
                       `facility` (`str`).
                    _custom_data: _custom_data

                """

    class LoopbackInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}, "_custom_data": {"type": dict}}
                interface: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, interface: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ldp": {"type": Ldp}, "_custom_data": {"type": dict}}
            ldp: Ldp
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ldp: Ldp | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ldp: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class NodeSegment(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_index": {"type": int}, "ipv6_index": {"type": int}, "_custom_data": {"type": dict}}
            ipv4_index: int | None
            ipv6_index: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_index: int | None | UndefinedType = Undefined,
                    ipv6_index: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    NodeSegment.


                    Subclass of AvdModel.

                    Args:
                        ipv4_index: ipv4_index
                        ipv6_index: ipv6_index
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ip_proxy_arp": {"type": bool},
            "ospf_area": {"type": str},
            "mpls": {"type": Mpls},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "node_segment": {"type": NodeSegment},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Loopback interface name e.g. "Loopback0"."""
        description: str | None
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ip_proxy_arp: bool | None
        ospf_area: str | None
        mpls: Mpls
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        node_segment: NodeSegment
        """Subclass of AvdModel."""
        eos_cli: str | None
        """EOS CLI rendered directly on the loopback interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                node_segment: NodeSegment | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                LoopbackInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Loopback interface name e.g. "Loopback0".
                    description: description
                    shutdown: shutdown
                    vrf: VRF name.
                    ip_address: IPv4_address/Mask.
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    ip_proxy_arp: ip_proxy_arp
                    ospf_area: ospf_area
                    mpls: Subclass of AvdModel.
                    isis_enable: ISIS instance name.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    node_segment: Subclass of AvdModel.
                    eos_cli: EOS CLI rendered directly on the loopback interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class LoopbackInterfaces(AvdIndexedList[str, LoopbackInterfacesItem]):
        """Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    LoopbackInterfaces._item_type = LoopbackInterfacesItem

    class MacAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class EntriesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int | None
            action: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | None | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: sequence
                        action: action
                        _custom_data: _custom_data

                    """

        class Entries(AvdList[EntriesItem]):
            """Subclass of AvdList with `EntriesItem` items."""

        Entries._item_type = EntriesItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "counters_per_entry": {"type": bool}, "entries": {"type": Entries}, "_custom_data": {"type": dict}}
        name: str
        """MAC Access-list Name."""
        counters_per_entry: bool | None
        entries: Entries
        """Subclass of AvdList with `EntriesItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                entries: Entries | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MacAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: MAC Access-list Name.
                    counters_per_entry: counters_per_entry
                    entries: Subclass of AvdList with `EntriesItem` items.
                    _custom_data: _custom_data

                """

    class MacAccessLists(AvdIndexedList[str, MacAccessListsItem]):
        """Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    MacAccessLists._item_type = MacAccessListsItem

    class MacAddressTable(AvdModel):
        """Subclass of AvdModel."""

        class NotificationHostFlap(AvdModel):
            """Subclass of AvdModel."""

            class Detection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"window": {"type": int}, "moves": {"type": int}, "_custom_data": {"type": dict}}
                window: int | None
                moves: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        window: int | None | UndefinedType = Undefined,
                        moves: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Detection.


                        Subclass of AvdModel.

                        Args:
                            window: window
                            moves: moves
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"logging": {"type": bool}, "detection": {"type": Detection}, "_custom_data": {"type": dict}}
            logging: bool | None
            detection: Detection
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    logging: bool | None | UndefinedType = Undefined,
                    detection: Detection | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    NotificationHostFlap.


                    Subclass of AvdModel.

                    Args:
                        logging: logging
                        detection: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"aging_time": {"type": int}, "notification_host_flap": {"type": NotificationHostFlap}, "_custom_data": {"type": dict}}
        aging_time: int | None
        """Aging time in seconds."""
        notification_host_flap: NotificationHostFlap
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                aging_time: int | None | UndefinedType = Undefined,
                notification_host_flap: NotificationHostFlap | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MacAddressTable.


                Subclass of AvdModel.

                Args:
                    aging_time: Aging time in seconds.
                    notification_host_flap: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MacSecurity(AvdModel):
        """Subclass of AvdModel."""

        class License(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"license_name": {"type": str}, "license_key": {"type": str}, "_custom_data": {"type": dict}}
            license_name: str
            license_key: str
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    license_name: str | UndefinedType = Undefined,
                    license_key: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    License.


                    Subclass of AvdModel.

                    Args:
                        license_name: license_name
                        license_key: license_key
                        _custom_data: _custom_data

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class ConnectionKeysItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "encrypted_key": {"type": str}, "fallback": {"type": bool}, "_custom_data": {"type": dict}}
                id: str
                encrypted_key: str | None
                fallback: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        encrypted_key: str | None | UndefinedType = Undefined,
                        fallback: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConnectionKeysItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            encrypted_key: encrypted_key
                            fallback: fallback
                            _custom_data: _custom_data

                        """

            class ConnectionKeys(AvdIndexedList[str, ConnectionKeysItem]):
                """Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            ConnectionKeys._item_type = ConnectionKeysItem

            class Mka(AvdModel):
                """Subclass of AvdModel."""

                class Session(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"rekey_period": {"type": int}, "_custom_data": {"type": dict}}
                    rekey_period: int | None
                    """Rekey period in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, rekey_period: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Session.


                            Subclass of AvdModel.

                            Args:
                                rekey_period: Rekey period in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"key_server_priority": {"type": int}, "session": {"type": Session}, "_custom_data": {"type": dict}}
                key_server_priority: int | None
                session: Session
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_server_priority: int | None | UndefinedType = Undefined,
                        session: Session | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mka.


                        Subclass of AvdModel.

                        Args:
                            key_server_priority: key_server_priority
                            session: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class L2Protocols(AvdModel):
                """Subclass of AvdModel."""

                class EthernetFlowControl(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "_custom_data": {"type": dict}}
                    mode: Literal["encrypt", "bypass"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, mode: Literal["encrypt", "bypass"] | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            EthernetFlowControl.


                            Subclass of AvdModel.

                            Args:
                                mode: mode
                                _custom_data: _custom_data

                            """

                class Lldp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "_custom_data": {"type": dict}}
                    mode: Literal["bypass", "bypass unauthorized"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mode: Literal["bypass", "bypass unauthorized"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Lldp.


                            Subclass of AvdModel.

                            Args:
                                mode: mode
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ethernet_flow_control": {"type": EthernetFlowControl}, "lldp": {"type": Lldp}, "_custom_data": {"type": dict}}
                ethernet_flow_control: EthernetFlowControl
                """Subclass of AvdModel."""
                lldp: Lldp
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ethernet_flow_control: EthernetFlowControl | UndefinedType = Undefined,
                        lldp: Lldp | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        L2Protocols.


                        Subclass of AvdModel.

                        Args:
                            ethernet_flow_control: Subclass of AvdModel.
                            lldp: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class TrafficUnprotected(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"action": {"type": str}, "allow_active_sak": {"type": bool}, "_custom_data": {"type": dict}}
                action: Literal["allow", "drop"]
                """Allow/drop the transmit/receive of unprotected traffic."""
                allow_active_sak: bool | None
                """Allow transmit/receive of encrypted traffic using operational SAK and block otherwise."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        action: Literal["allow", "drop"] | UndefinedType = Undefined,
                        allow_active_sak: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrafficUnprotected.


                        Subclass of AvdModel.

                        Args:
                            action: Allow/drop the transmit/receive of unprotected traffic.
                            allow_active_sak: Allow transmit/receive of encrypted traffic using operational SAK and block otherwise.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "cipher": {"type": str},
                "connection_keys": {"type": ConnectionKeys},
                "mka": {"type": Mka},
                "sci": {"type": bool},
                "l2_protocols": {"type": L2Protocols},
                "traffic_unprotected": {"type": TrafficUnprotected},
                "_custom_data": {"type": dict},
            }
            name: str
            """Profile-Name."""
            cipher: Literal["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"] | None
            connection_keys: ConnectionKeys
            """Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`)."""
            mka: Mka
            """Subclass of AvdModel."""
            sci: bool | None
            l2_protocols: L2Protocols
            """Subclass of AvdModel."""
            traffic_unprotected: TrafficUnprotected
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    cipher: Literal["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"] | None | UndefinedType = Undefined,
                    connection_keys: ConnectionKeys | UndefinedType = Undefined,
                    mka: Mka | UndefinedType = Undefined,
                    sci: bool | None | UndefinedType = Undefined,
                    l2_protocols: L2Protocols | UndefinedType = Undefined,
                    traffic_unprotected: TrafficUnprotected | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Profile-Name.
                        cipher: cipher
                        connection_keys: Subclass of AvdIndexedList with `ConnectionKeysItem` items. Primary key is `id` (`str`).
                        mka: Subclass of AvdModel.
                        sci: sci
                        l2_protocols: Subclass of AvdModel.
                        traffic_unprotected: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {
            "license": {"type": License},
            "fips_restrictions": {"type": bool},
            "profiles": {"type": Profiles},
            "_custom_data": {"type": dict},
        }
        license: License
        """Subclass of AvdModel."""
        fips_restrictions: bool | None
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                license: License | UndefinedType = Undefined,
                fips_restrictions: bool | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MacSecurity.


                Subclass of AvdModel.

                Args:
                    license: Subclass of AvdModel.
                    fips_restrictions: fips_restrictions
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Maintenance(AvdModel):
        """Subclass of AvdModel."""

        class InterfaceProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class RateMonitoring(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"load_interval": {"type": int}, "threshold": {"type": int}, "_custom_data": {"type": dict}}
                load_interval: int | None
                """Load Interval in Seconds."""
                threshold: int | None
                """Threshold in kbps."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        load_interval: int | None | UndefinedType = Undefined,
                        threshold: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RateMonitoring.


                        Subclass of AvdModel.

                        Args:
                            load_interval: Load Interval in Seconds.
                            threshold: Threshold in kbps.
                            _custom_data: _custom_data

                        """

            class Shutdown(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"max_delay": {"type": int}, "_custom_data": {"type": dict}}
                max_delay: int | None
                """Max delay in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, max_delay: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Shutdown.


                        Subclass of AvdModel.

                        Args:
                            max_delay: Max delay in seconds.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "rate_monitoring": {"type": RateMonitoring},
                "shutdown": {"type": Shutdown},
                "_custom_data": {"type": dict},
            }
            name: str
            rate_monitoring: RateMonitoring
            """Subclass of AvdModel."""
            shutdown: Shutdown
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    rate_monitoring: RateMonitoring | UndefinedType = Undefined,
                    shutdown: Shutdown | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        rate_monitoring: Subclass of AvdModel.
                        shutdown: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class InterfaceProfiles(AvdIndexedList[str, InterfaceProfilesItem]):
            """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        InterfaceProfiles._item_type = InterfaceProfilesItem

        class BgpProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Initiator(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"route_map_inout": {"type": str}, "_custom_data": {"type": dict}}
                route_map_inout: str | None
                """Route Map."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, route_map_inout: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Initiator.


                        Subclass of AvdModel.

                        Args:
                            route_map_inout: Route Map.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "initiator": {"type": Initiator}, "_custom_data": {"type": dict}}
            name: str
            """BGP Profile Name."""
            initiator: Initiator
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    initiator: Initiator | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    BgpProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: BGP Profile Name.
                        initiator: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class BgpProfiles(AvdIndexedList[str, BgpProfilesItem]):
            """Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        BgpProfiles._item_type = BgpProfilesItem

        class UnitProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class OnBoot(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"duration": {"type": int}, "_custom_data": {"type": dict}}
                duration: int | None
                """On-boot in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, duration: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        OnBoot.


                        Subclass of AvdModel.

                        Args:
                            duration: On-boot in seconds.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "on_boot": {"type": OnBoot}, "_custom_data": {"type": dict}}
            name: str
            """Unit Profile Name."""
            on_boot: OnBoot
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    on_boot: OnBoot | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnitProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Unit Profile Name.
                        on_boot: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class UnitProfiles(AvdIndexedList[str, UnitProfilesItem]):
            """Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        UnitProfiles._item_type = UnitProfilesItem

        class UnitsItem(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdModel):
                """Subclass of AvdModel."""

                class BgpGroups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                BgpGroups._item_type = str

                class InterfaceGroups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                InterfaceGroups._item_type = str

                _fields: ClassVar[dict] = {"bgp_groups": {"type": BgpGroups}, "interface_groups": {"type": InterfaceGroups}, "_custom_data": {"type": dict}}
                bgp_groups: BgpGroups
                """Subclass of AvdList with `str` items."""
                interface_groups: InterfaceGroups
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp_groups: BgpGroups | UndefinedType = Undefined,
                        interface_groups: InterfaceGroups | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Groups.


                        Subclass of AvdModel.

                        Args:
                            bgp_groups: Subclass of AvdList with `str` items.
                            interface_groups: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "quiesce": {"type": bool},
                "profile": {"type": str},
                "groups": {"type": Groups},
                "_custom_data": {"type": dict},
            }
            name: str
            """Unit Name."""
            quiesce: bool | None
            profile: str | None
            """Name of Unit Profile."""
            groups: Groups
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    quiesce: bool | None | UndefinedType = Undefined,
                    profile: str | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnitsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Unit Name.
                        quiesce: quiesce
                        profile: Name of Unit Profile.
                        groups: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Units(AvdIndexedList[str, UnitsItem]):
            """Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Units._item_type = UnitsItem

        _fields: ClassVar[dict] = {
            "default_interface_profile": {"type": str},
            "default_bgp_profile": {"type": str},
            "default_unit_profile": {"type": str},
            "interface_profiles": {"type": InterfaceProfiles},
            "bgp_profiles": {"type": BgpProfiles},
            "unit_profiles": {"type": UnitProfiles},
            "units": {"type": Units},
            "_custom_data": {"type": dict},
        }
        default_interface_profile: str | None
        """Name of default Interface Profile."""
        default_bgp_profile: str | None
        """Name of default BGP Profile."""
        default_unit_profile: str | None
        """Name of default Unit Profile."""
        interface_profiles: InterfaceProfiles
        """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""
        bgp_profiles: BgpProfiles
        """Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`)."""
        unit_profiles: UnitProfiles
        """Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`)."""
        units: Units
        """Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                default_interface_profile: str | None | UndefinedType = Undefined,
                default_bgp_profile: str | None | UndefinedType = Undefined,
                default_unit_profile: str | None | UndefinedType = Undefined,
                interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
                bgp_profiles: BgpProfiles | UndefinedType = Undefined,
                unit_profiles: UnitProfiles | UndefinedType = Undefined,
                units: Units | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Maintenance.


                Subclass of AvdModel.

                Args:
                    default_interface_profile: Name of default Interface Profile.
                    default_bgp_profile: Name of default BGP Profile.
                    default_unit_profile: Name of default Unit Profile.
                    interface_profiles: Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`).
                    bgp_profiles: Subclass of AvdIndexedList with `BgpProfilesItem` items. Primary key is `name` (`str`).
                    unit_profiles: Subclass of AvdIndexedList with `UnitProfilesItem` items. Primary key is `name` (`str`).
                    units: Subclass of AvdIndexedList with `UnitsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class ManagementAccounts(AvdModel):
        """Subclass of AvdModel."""

        class Password(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"policy": {"type": str}, "_custom_data": {"type": dict}}
            policy: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, policy: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Password.


                    Subclass of AvdModel.

                    Args:
                        policy: policy
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"password": {"type": Password}, "_custom_data": {"type": dict}}
        password: Password
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, password: Password | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                ManagementAccounts.


                Subclass of AvdModel.

                Args:
                    password: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ManagementApiGnmi(AvdModel):
        """Subclass of AvdModel."""

        class Transport(AvdModel):
            """Subclass of AvdModel."""

            class GrpcItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "notification_timestamp": {"type": str},
                    "ip_access_group": {"type": str},
                    "port": {"type": int},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Transport name."""
                ssl_profile: str | None
                """SSL profile name."""
                vrf: str | None
                """VRF name is optional."""
                notification_timestamp: Literal["send-time", "last-change-time"] | None
                """
                Per the gNMI specification, the default timestamp field of a notification message is set to be
                the
                time at which the value of the underlying data source changes or when the reported event takes
                place.
                In order to facilitate integration in legacy environments oriented around polling style
                operations,
                an option to support overriding the timestamp field to the send-time is available from
                EOS 4.27.0F.
                """
                ip_access_group: str | None
                """ACL name."""
                port: int | None
                """
                GNMI port.
                Make sure to update the control-plane ACL accordingly in order for the service to be
                reachable by external applications.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        notification_timestamp: Literal["send-time", "last-change-time"] | None | UndefinedType = Undefined,
                        ip_access_group: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GrpcItem.


                        Subclass of AvdModel.

                        Args:
                            name: Transport name.
                            ssl_profile: SSL profile name.
                            vrf: VRF name is optional.
                            notification_timestamp:
                               Per the gNMI specification, the default timestamp field of a notification message is set to be
                               the
                               time at which the value of the underlying data source changes or when the reported event takes
                               place.
                               In order to facilitate integration in legacy environments oriented around polling style
                               operations,
                               an option to support overriding the timestamp field to the send-time is available from
                               EOS 4.27.0F.
                            ip_access_group: ACL name.
                            port:
                               GNMI port.
                               Make sure to update the control-plane ACL accordingly in order for the service to be
                               reachable by external applications.
                            _custom_data: _custom_data

                        """

            class Grpc(AvdIndexedList[str, GrpcItem]):
                """Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Grpc._item_type = GrpcItem

            class GrpcTunnelsItem(AvdModel):
                """Subclass of AvdModel."""

                class Destination(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                    address: str
                    """IP address or hostname."""
                    port: int
                    """TCP Port."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address: str | UndefinedType = Undefined,
                            port: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Destination.


                            Subclass of AvdModel.

                            Args:
                                address: IP address or hostname.
                                port: TCP Port.
                                _custom_data: _custom_data

                            """

                class LocalInterface(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                    name: str
                    """Interface name."""
                    port: int
                    """TCP Port."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            port: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LocalInterface.


                            Subclass of AvdModel.

                            Args:
                                name: Interface name.
                                port: TCP Port.
                                _custom_data: _custom_data

                            """

                class Target(AvdModel):
                    """Subclass of AvdModel."""

                    class TargetIds(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    TargetIds._item_type = str

                    _fields: ClassVar[dict] = {"use_serial_number": {"type": bool}, "target_ids": {"type": TargetIds}, "_custom_data": {"type": dict}}
                    use_serial_number: bool | None
                    """Use serial number as the Target ID."""
                    target_ids: TargetIds
                    """
                    Target IDs as a list.


                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            use_serial_number: bool | None | UndefinedType = Undefined,
                            target_ids: TargetIds | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Target.


                            Subclass of AvdModel.

                            Args:
                                use_serial_number: Use serial number as the Target ID.
                                target_ids:
                                   Target IDs as a list.


                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "shutdown": {"type": bool},
                    "tunnel_ssl_profile": {"type": str},
                    "gnmi_ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "destination": {"type": Destination},
                    "local_interface": {"type": LocalInterface},
                    "target": {"type": Target},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Transport name."""
                shutdown: bool | None
                """Operational status of the gRPC tunnel."""
                tunnel_ssl_profile: str | None
                """Tunnel SSL profile name."""
                gnmi_ssl_profile: str | None
                """gNMI SSL profile name."""
                vrf: str | None
                """VRF name."""
                destination: Destination
                """Subclass of AvdModel."""
                local_interface: LocalInterface
                """Subclass of AvdModel."""
                target: Target
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        tunnel_ssl_profile: str | None | UndefinedType = Undefined,
                        gnmi_ssl_profile: str | None | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        destination: Destination | UndefinedType = Undefined,
                        local_interface: LocalInterface | UndefinedType = Undefined,
                        target: Target | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GrpcTunnelsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Transport name.
                            shutdown: Operational status of the gRPC tunnel.
                            tunnel_ssl_profile: Tunnel SSL profile name.
                            gnmi_ssl_profile: gNMI SSL profile name.
                            vrf: VRF name.
                            destination: Subclass of AvdModel.
                            local_interface: Subclass of AvdModel.
                            target: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class GrpcTunnels(AvdIndexedList[str, GrpcTunnelsItem]):
                """Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            GrpcTunnels._item_type = GrpcTunnelsItem

            _fields: ClassVar[dict] = {"grpc": {"type": Grpc}, "grpc_tunnels": {"type": GrpcTunnels}, "_custom_data": {"type": dict}}
            grpc: Grpc
            """Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`)."""
            grpc_tunnels: GrpcTunnels
            """Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    grpc: Grpc | UndefinedType = Undefined,
                    grpc_tunnels: GrpcTunnels | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Transport.


                    Subclass of AvdModel.

                    Args:
                        grpc: Subclass of AvdIndexedList with `GrpcItem` items. Primary key is `name` (`str`).
                        grpc_tunnels: Subclass of AvdIndexedList with `GrpcTunnelsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"provider": {"type": str, "default": "eos-native"}, "transport": {"type": Transport}, "_custom_data": {"type": dict}}
        provider: str
        """Default value: `"eos-native"`"""
        transport: Transport
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                provider: str | UndefinedType = Undefined,
                transport: Transport | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementApiGnmi.


                Subclass of AvdModel.

                Args:
                    provider: provider
                    transport: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ManagementApiHttp(AvdModel):
        """Subclass of AvdModel."""

        class EnableVrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "access_group": {"type": str}, "ipv6_access_group": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """VRF Name."""
            access_group: str | None
            """Standard IPv4 ACL name."""
            ipv6_access_group: str | None
            """Standard IPv6 ACL name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    access_group: str | None | UndefinedType = Undefined,
                    ipv6_access_group: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EnableVrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        access_group: Standard IPv4 ACL name.
                        ipv6_access_group: Standard IPv6 ACL name.
                        _custom_data: _custom_data

                    """

        class EnableVrfs(AvdIndexedList[str, EnableVrfsItem]):
            """Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        EnableVrfs._item_type = EnableVrfsItem

        class ProtocolHttpsCertificate(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"certificate": {"type": str}, "private_key": {"type": str}, "_custom_data": {"type": dict}}
            certificate: str | None
            """Name of certificate; private key must also be specified."""
            private_key: str | None
            """Name of private key; certificate must also be specified."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    certificate: str | None | UndefinedType = Undefined,
                    private_key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProtocolHttpsCertificate.


                    Subclass of AvdModel.

                    Args:
                        certificate: Name of certificate; private key must also be specified.
                        private_key: Name of private key; certificate must also be specified.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "enable_http": {"type": bool},
            "enable_https": {"type": bool},
            "https_ssl_profile": {"type": str},
            "default_services": {"type": bool},
            "enable_vrfs": {"type": EnableVrfs},
            "protocol_https_certificate": {"type": ProtocolHttpsCertificate},
            "_custom_data": {"type": dict},
        }
        enable_http: bool | None
        enable_https: bool | None
        https_ssl_profile: str | None
        """SSL Profile Name."""
        default_services: bool | None
        """Enable default services: capi-doc and tapagg."""
        enable_vrfs: EnableVrfs
        """Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`)."""
        protocol_https_certificate: ProtocolHttpsCertificate
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable_http: bool | None | UndefinedType = Undefined,
                enable_https: bool | None | UndefinedType = Undefined,
                https_ssl_profile: str | None | UndefinedType = Undefined,
                default_services: bool | None | UndefinedType = Undefined,
                enable_vrfs: EnableVrfs | UndefinedType = Undefined,
                protocol_https_certificate: ProtocolHttpsCertificate | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementApiHttp.


                Subclass of AvdModel.

                Args:
                    enable_http: enable_http
                    enable_https: enable_https
                    https_ssl_profile: SSL Profile Name.
                    default_services: Enable default services: capi-doc and tapagg.
                    enable_vrfs: Subclass of AvdIndexedList with `EnableVrfsItem` items. Primary key is `name` (`str`).
                    protocol_https_certificate: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ManagementApiModels(AvdModel):
        """Subclass of AvdModel."""

        class ProvidersItem(AvdModel):
            """Subclass of AvdModel."""

            class PathsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"path": {"type": str}, "disabled": {"type": bool, "default": False}, "_custom_data": {"type": dict}}
                path: str | None
                disabled: bool
                """Default value: `False`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        path: str | None | UndefinedType = Undefined,
                        disabled: bool | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathsItem.


                        Subclass of AvdModel.

                        Args:
                            path: path
                            disabled: disabled
                            _custom_data: _custom_data

                        """

            class Paths(AvdList[PathsItem]):
                """Subclass of AvdList with `PathsItem` items."""

            Paths._item_type = PathsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "paths": {"type": Paths}, "_custom_data": {"type": dict}}
            name: Literal["sysdb", "smash"] | None
            paths: Paths
            """Subclass of AvdList with `PathsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: Literal["sysdb", "smash"] | None | UndefinedType = Undefined,
                    paths: Paths | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProvidersItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        paths: Subclass of AvdList with `PathsItem` items.
                        _custom_data: _custom_data

                    """

        class Providers(AvdList[ProvidersItem]):
            """Subclass of AvdList with `ProvidersItem` items."""

        Providers._item_type = ProvidersItem

        _fields: ClassVar[dict] = {"providers": {"type": Providers}, "_custom_data": {"type": dict}}
        providers: Providers
        """Subclass of AvdList with `ProvidersItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, providers: Providers | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                ManagementApiModels.


                Subclass of AvdModel.

                Args:
                    providers: Subclass of AvdList with `ProvidersItem` items.
                    _custom_data: _custom_data

                """

    class ManagementConsole(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"idle_timeout": {"type": int}, "_custom_data": {"type": dict}}
        idle_timeout: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, idle_timeout: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                ManagementConsole.


                Subclass of AvdModel.

                Args:
                    idle_timeout: idle_timeout
                    _custom_data: _custom_data

                """

    class ManagementCvx(AvdModel):
        """Subclass of AvdModel."""

        class ServerHosts(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        ServerHosts._item_type = str

        _fields: ClassVar[dict] = {
            "shutdown": {"type": bool},
            "server_hosts": {"type": ServerHosts},
            "source_interface": {"type": str},
            "vrf": {"type": str},
            "_custom_data": {"type": dict},
        }
        shutdown: bool | None
        server_hosts: ServerHosts
        """Subclass of AvdList with `str` items."""
        source_interface: str | None
        """Interface name."""
        vrf: str | None
        """VRF Name."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                server_hosts: ServerHosts | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementCvx.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    server_hosts: Subclass of AvdList with `str` items.
                    source_interface: Interface name.
                    vrf: VRF Name.
                    _custom_data: _custom_data

                """

    class ManagementDefaults(AvdModel):
        """Subclass of AvdModel."""

        class Secret(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hash": {"type": str}, "_custom_data": {"type": dict}}
            hash: Literal["md5", "sha512"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, hash: Literal["md5", "sha512"] | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Secret.


                    Subclass of AvdModel.

                    Args:
                        hash: hash
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"secret": {"type": Secret}, "_custom_data": {"type": dict}}
        secret: Secret
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, secret: Secret | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                ManagementDefaults.


                Subclass of AvdModel.

                Args:
                    secret: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ManagementInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Lldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}, "_custom_data": {"type": dict}}
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    transmit: bool | None | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    ztp_vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lldp.


                    Subclass of AvdModel.

                    Args:
                        transmit: transmit
                        receive: receive
                        ztp_vlan: ZTP vlan number.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "speed": {"type": str},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "type": {"type": str, "default": "oob"},
            "gateway": {"type": str},
            "ipv6_gateway": {"type": str},
            "mac_address": {"type": str},
            "lldp": {"type": Lldp},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Management Interface Name."""
        description: str | None
        shutdown: bool | None
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        type: Literal["oob", "inband"]
        """
        For documentation purposes only.

        Default value: `"oob"`
        """
        gateway: str | None
        """IPv4 address of default gateway in management VRF."""
        ipv6_gateway: str | None
        """IPv6 address of default gateway in management VRF."""
        mac_address: str | None
        """MAC address."""
        lldp: Lldp
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the management interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                type: Literal["oob", "inband"] | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                ipv6_gateway: str | None | UndefinedType = Undefined,
                mac_address: str | None | UndefinedType = Undefined,
                lldp: Lldp | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Management Interface Name.
                    description: description
                    shutdown: shutdown
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    mtu: mtu
                    vrf: VRF Name.
                    ip_address: IPv4_address/Mask.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    type: For documentation purposes only.
                    gateway: IPv4 address of default gateway in management VRF.
                    ipv6_gateway: IPv6 address of default gateway in management VRF.
                    mac_address: MAC address.
                    lldp: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the management interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class ManagementInterfaces(AvdIndexedList[str, ManagementInterfacesItem]):
        """Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    ManagementInterfaces._item_type = ManagementInterfacesItem

    class ManagementSecurity(AvdModel):
        """Subclass of AvdModel."""

        class EntropySources(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "hardware": {"type": bool},
                "haveged": {"type": bool},
                "cpu_jitter": {"type": bool},
                "hardware_exclusive": {"type": bool},
                "_custom_data": {"type": dict},
            }
            hardware: bool | None
            """Use a hardware based source."""
            haveged: bool | None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None
            """Only use entropy from the hardware source."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    hardware: bool | None | UndefinedType = Undefined,
                    haveged: bool | None | UndefinedType = Undefined,
                    cpu_jitter: bool | None | UndefinedType = Undefined,
                    hardware_exclusive: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntropySources.


                    Subclass of AvdModel.

                    Args:
                        hardware: Use a hardware based source.
                        haveged: Use the HAVEGE algorithm.
                        cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                        hardware_exclusive: Only use entropy from the hardware source.
                        _custom_data: _custom_data

                    """

        class Password(AvdModel):
            """Subclass of AvdModel."""

            class PoliciesItem(AvdModel):
                """Subclass of AvdModel."""

                class Minimum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "digits": {"type": int},
                        "length": {"type": int},
                        "lower": {"type": int},
                        "special": {"type": int},
                        "upper": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    digits: int | None
                    length: int | None
                    lower: int | None
                    special: int | None
                    upper: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            digits: int | None | UndefinedType = Undefined,
                            length: int | None | UndefinedType = Undefined,
                            lower: int | None | UndefinedType = Undefined,
                            special: int | None | UndefinedType = Undefined,
                            upper: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Minimum.


                            Subclass of AvdModel.

                            Args:
                                digits: digits
                                length: length
                                lower: lower
                                special: special
                                upper: upper
                                _custom_data: _custom_data

                            """

                class Maximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"repetitive": {"type": int}, "sequential": {"type": int}, "_custom_data": {"type": dict}}
                    repetitive: int | None
                    sequential: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            repetitive: int | None | UndefinedType = Undefined,
                            sequential: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Maximum.


                            Subclass of AvdModel.

                            Args:
                                repetitive: repetitive
                                sequential: sequential
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "minimum": {"type": Minimum}, "maximum": {"type": Maximum}, "_custom_data": {"type": dict}}
                name: str
                minimum: Minimum
                """Subclass of AvdModel."""
                maximum: Maximum
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        minimum: Minimum | UndefinedType = Undefined,
                        maximum: Maximum | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PoliciesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            minimum: Subclass of AvdModel.
                            maximum: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Policies(AvdIndexedList[str, PoliciesItem]):
                """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Policies._item_type = PoliciesItem

            _fields: ClassVar[dict] = {
                "minimum_length": {"type": int},
                "encryption_key_common": {"type": bool},
                "encryption_reversible": {"type": str},
                "policies": {"type": Policies},
                "_custom_data": {"type": dict},
            }
            minimum_length: int | None
            encryption_key_common: bool | None
            encryption_reversible: str | None
            policies: Policies
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    minimum_length: int | None | UndefinedType = Undefined,
                    encryption_key_common: bool | None | UndefinedType = Undefined,
                    encryption_reversible: str | None | UndefinedType = Undefined,
                    policies: Policies | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Password.


                    Subclass of AvdModel.

                    Args:
                        minimum_length: minimum_length
                        encryption_key_common: encryption_key_common
                        encryption_reversible: encryption_reversible
                        policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class SslProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class Ciphers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"v1_0": {"type": str}, "v1_3": {"type": str}, "_custom_data": {"type": dict}}
                v1_0: str | None
                """
                The cipher suites for TLS version 1.0, 1.1 and 1.2.
                Colon (:) separated list of allowed ciphers as a
                string.
                """
                v1_3: str | None
                """
                The cipher suites for TLS version 1.3.
                Colon (:) separated list of allowed ciphers as a string.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        v1_0: str | None | UndefinedType = Undefined,
                        v1_3: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ciphers.


                        Subclass of AvdModel.

                        Args:
                            v1_0:
                               The cipher suites for TLS version 1.0, 1.1 and 1.2.
                               Colon (:) separated list of allowed ciphers as a
                               string.
                            v1_3:
                               The cipher suites for TLS version 1.3.
                               Colon (:) separated list of allowed ciphers as a string.
                            _custom_data: _custom_data

                        """

            class TrustCertificate(AvdModel):
                """Subclass of AvdModel."""

                class Certificates(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Certificates._item_type = str

                class Requirement(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"basic_constraint_ca": {"type": bool}, "hostname_fqdn": {"type": bool}, "_custom_data": {"type": dict}}
                    basic_constraint_ca: bool | None
                    hostname_fqdn: bool | None
                    """Enforce hostname to be FQDN without wildcard."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            basic_constraint_ca: bool | None | UndefinedType = Undefined,
                            hostname_fqdn: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Requirement.


                            Subclass of AvdModel.

                            Args:
                                basic_constraint_ca: basic_constraint_ca
                                hostname_fqdn: Enforce hostname to be FQDN without wildcard.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "certificates": {"type": Certificates},
                    "requirement": {"type": Requirement},
                    "policy_expiry_date_ignore": {"type": bool},
                    "system": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                certificates: Certificates
                """
                List of trust certificate names.
                Examples:
                  - test1.crt
                  - test2.crt


                Subclass of AvdList with
                `str` items.
                """
                requirement: Requirement
                """Subclass of AvdModel."""
                policy_expiry_date_ignore: bool | None
                system: bool | None
                """Use system-supplied trust certificates."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        certificates: Certificates | UndefinedType = Undefined,
                        requirement: Requirement | UndefinedType = Undefined,
                        policy_expiry_date_ignore: bool | None | UndefinedType = Undefined,
                        system: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrustCertificate.


                        Subclass of AvdModel.

                        Args:
                            certificates:
                               List of trust certificate names.
                               Examples:  # fmt: skip
                                 - test1.crt
                                 - test2.crt


                               Subclass of AvdList with
                               `str` items.
                            requirement: Subclass of AvdModel.
                            policy_expiry_date_ignore: policy_expiry_date_ignore
                            system: Use system-supplied trust certificates.
                            _custom_data: _custom_data

                        """

            class ChainCertificate(AvdModel):
                """Subclass of AvdModel."""

                class Certificates(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Certificates._item_type = str

                class Requirement(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"basic_constraint_ca": {"type": bool}, "include_root_ca": {"type": bool}, "_custom_data": {"type": dict}}
                    basic_constraint_ca: bool | None
                    include_root_ca: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            basic_constraint_ca: bool | None | UndefinedType = Undefined,
                            include_root_ca: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Requirement.


                            Subclass of AvdModel.

                            Args:
                                basic_constraint_ca: basic_constraint_ca
                                include_root_ca: include_root_ca
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"certificates": {"type": Certificates}, "requirement": {"type": Requirement}, "_custom_data": {"type": dict}}
                certificates: Certificates
                """
                List of chain certificate names.
                Examples:
                  - chain1.crt
                  - chain2.crt


                Subclass of AvdList with
                `str` items.
                """
                requirement: Requirement
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        certificates: Certificates | UndefinedType = Undefined,
                        requirement: Requirement | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ChainCertificate.


                        Subclass of AvdModel.

                        Args:
                            certificates:
                               List of chain certificate names.
                               Examples:  # fmt: skip
                                 - chain1.crt
                                 - chain2.crt


                               Subclass of AvdList with
                               `str` items.
                            requirement: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Certificate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"file": {"type": str}, "key": {"type": str}, "_custom_data": {"type": dict}}
                file: str | None
                key: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        file: str | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Certificate.


                        Subclass of AvdModel.

                        Args:
                            file: file
                            key: key
                            _custom_data: _custom_data

                        """

            class CertificateRevocationLists(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            CertificateRevocationLists._item_type = str

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "tls_versions": {"type": str},
                "cipher_list": {"type": str},
                "ciphers": {"type": Ciphers},
                "trust_certificate": {"type": TrustCertificate},
                "chain_certificate": {"type": ChainCertificate},
                "certificate": {"type": Certificate},
                "certificate_revocation_lists": {"type": CertificateRevocationLists},
                "_custom_data": {"type": dict},
            }
            name: str | None
            tls_versions: str | None
            """
            List of allowed TLS versions as string.
            Examples:
              - "1.0"
              - "1.0 1.1"
            """
            cipher_list: str | None
            """
            cipher_list syntax follows the openssl cipher strings format.
            Colon (:) separated list of allowed
            ciphers as a string.
            Not supported on EOS version starting 4.32.0F, use the `ciphers` setting
            instead.
            """
            ciphers: Ciphers
            """
            This setting is applicable to EOS versions 4.32.0F and later.

            Subclass of AvdModel.
            """
            trust_certificate: TrustCertificate
            """Subclass of AvdModel."""
            chain_certificate: ChainCertificate
            """Subclass of AvdModel."""
            certificate: Certificate
            """Subclass of AvdModel."""
            certificate_revocation_lists: CertificateRevocationLists
            """
            List of CRLs (Certificate Revocation List).
            If specified, one CRL needs to be provided for every
            certificate in the chain, even if the revocation list in the CRL is empty.


            Subclass of AvdList
            with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    tls_versions: str | None | UndefinedType = Undefined,
                    cipher_list: str | None | UndefinedType = Undefined,
                    ciphers: Ciphers | UndefinedType = Undefined,
                    trust_certificate: TrustCertificate | UndefinedType = Undefined,
                    chain_certificate: ChainCertificate | UndefinedType = Undefined,
                    certificate: Certificate | UndefinedType = Undefined,
                    certificate_revocation_lists: CertificateRevocationLists | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SslProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        tls_versions:
                           List of allowed TLS versions as string.
                           Examples:  # fmt: skip
                             - "1.0"
                             - "1.0 1.1"
                        cipher_list:
                           cipher_list syntax follows the openssl cipher strings format.
                           Colon (:) separated list of allowed
                           ciphers as a string.
                           Not supported on EOS version starting 4.32.0F, use the `ciphers` setting
                           instead.
                        ciphers:
                           This setting is applicable to EOS versions 4.32.0F and later.

                           Subclass of AvdModel.
                        trust_certificate: Subclass of AvdModel.
                        chain_certificate: Subclass of AvdModel.
                        certificate: Subclass of AvdModel.
                        certificate_revocation_lists:
                           List of CRLs (Certificate Revocation List).
                           If specified, one CRL needs to be provided for every
                           certificate in the chain, even if the revocation list in the CRL is empty.


                           Subclass of AvdList
                           with `str` items.
                        _custom_data: _custom_data

                    """

        class SslProfiles(AvdList[SslProfilesItem]):
            """Subclass of AvdList with `SslProfilesItem` items."""

        SslProfiles._item_type = SslProfilesItem

        class SharedSecretProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class SecretsItem(AvdModel):
                """Subclass of AvdModel."""

                class ReceiveLifetime(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "infinite": {"type": bool},
                        "start_date_time": {"type": str},
                        "end_date_time": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            infinite: bool | None | UndefinedType = Undefined,
                            start_date_time: str | None | UndefinedType = Undefined,
                            end_date_time: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ReceiveLifetime.


                            Subclass of AvdModel.

                            Args:
                                infinite: infinite
                                start_date_time:
                                   Start date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                end_date_time:
                                   End date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                _custom_data: _custom_data

                            """

                class TransmitLifetime(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "infinite": {"type": bool},
                        "start_date_time": {"type": str},
                        "end_date_time": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            infinite: bool | None | UndefinedType = Undefined,
                            start_date_time: str | None | UndefinedType = Undefined,
                            end_date_time: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TransmitLifetime.


                            Subclass of AvdModel.

                            Args:
                                infinite: infinite
                                start_date_time:
                                   Start date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                end_date_time:
                                   End date and time of lifetime of the secret. End date should be greater than start date.
                                   Formats
                                   supported:
                                   1. mm/dd/yyyy hh:mm:ss
                                   2. yyyy-mm-dd hh:mm:ss
                                   e.g 2024-12-20 10:00:00
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "secret": {"type": str},
                    "secret_type": {"type": str, "default": "7"},
                    "receive_lifetime": {"type": ReceiveLifetime},
                    "transmit_lifetime": {"type": TransmitLifetime},
                    "local_time": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                name: str
                secret: str
                secret_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""
                receive_lifetime: ReceiveLifetime
                """Subclass of AvdModel."""
                transmit_lifetime: TransmitLifetime
                """Subclass of AvdModel."""
                local_time: bool | None
                """Configuring secret using the local timezone from system clock. Default is UTC."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        secret: str | UndefinedType = Undefined,
                        secret_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                        receive_lifetime: ReceiveLifetime | UndefinedType = Undefined,
                        transmit_lifetime: TransmitLifetime | UndefinedType = Undefined,
                        local_time: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SecretsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            secret: secret
                            secret_type: secret_type
                            receive_lifetime: Subclass of AvdModel.
                            transmit_lifetime: Subclass of AvdModel.
                            local_time: Configuring secret using the local timezone from system clock. Default is UTC.
                            _custom_data: _custom_data

                        """

            class Secrets(AvdIndexedList[str, SecretsItem]):
                """Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Secrets._item_type = SecretsItem

            _fields: ClassVar[dict] = {"profile": {"type": str}, "secrets": {"type": Secrets}, "_custom_data": {"type": dict}}
            profile: str
            secrets: Secrets
            """Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    profile: str | UndefinedType = Undefined,
                    secrets: Secrets | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SharedSecretProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        profile: profile
                        secrets: Subclass of AvdIndexedList with `SecretsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class SharedSecretProfiles(AvdIndexedList[str, SharedSecretProfilesItem]):
            """Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`)."""

            _primary_key: ClassVar[str] = "profile"

        SharedSecretProfiles._item_type = SharedSecretProfilesItem

        _fields: ClassVar[dict] = {
            "entropy_sources": {"type": EntropySources},
            "password": {"type": Password},
            "ssl_profiles": {"type": SslProfiles},
            "shared_secret_profiles": {"type": SharedSecretProfiles},
            "_custom_data": {"type": dict},
        }
        entropy_sources: EntropySources
        """
        Source of entropy.

        Subclass of AvdModel.
        """
        password: Password
        """Subclass of AvdModel."""
        ssl_profiles: SslProfiles
        """Subclass of AvdList with `SslProfilesItem` items."""
        shared_secret_profiles: SharedSecretProfiles
        """Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                entropy_sources: EntropySources | UndefinedType = Undefined,
                password: Password | UndefinedType = Undefined,
                ssl_profiles: SslProfiles | UndefinedType = Undefined,
                shared_secret_profiles: SharedSecretProfiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementSecurity.


                Subclass of AvdModel.

                Args:
                    entropy_sources:
                       Source of entropy.

                       Subclass of AvdModel.
                    password: Subclass of AvdModel.
                    ssl_profiles: Subclass of AvdList with `SslProfilesItem` items.
                    shared_secret_profiles: Subclass of AvdIndexedList with `SharedSecretProfilesItem` items. Primary key is `profile` (`str`).
                    _custom_data: _custom_data

                """

    class ManagementSsh(AvdModel):
        """Subclass of AvdModel."""

        class Authentication(AvdModel):
            """Subclass of AvdModel."""

            class Protocols(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Protocols._item_type = str

            _fields: ClassVar[dict] = {"empty_passwords": {"type": str}, "protocols": {"type": Protocols}, "_custom_data": {"type": dict}}
            empty_passwords: Literal["auto", "deny", "permit"] | None
            """Permit or deny empty passwords for SSH authentication."""
            protocols: Protocols
            """
            Allowed SSH authentication methods.

            Subclass of AvdList with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    empty_passwords: Literal["auto", "deny", "permit"] | None | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Authentication.


                    Subclass of AvdModel.

                    Args:
                        empty_passwords: Permit or deny empty passwords for SSH authentication.
                        protocols:
                           Allowed SSH authentication methods.

                           Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class AccessGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Standard ACL Name.
                        vrf: VRF Name.
                        _custom_data: _custom_data

                    """

        class AccessGroups(AvdList[AccessGroupsItem]):
            """Subclass of AvdList with `AccessGroupsItem` items."""

        AccessGroups._item_type = AccessGroupsItem

        class Ipv6AccessGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6AccessGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Standard ACL Name.
                        vrf: VRF Name.
                        _custom_data: _custom_data

                    """

        class Ipv6AccessGroups(AvdList[Ipv6AccessGroupsItem]):
            """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""

        Ipv6AccessGroups._item_type = Ipv6AccessGroupsItem

        class Cipher(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Cipher._item_type = str

        class KeyExchange(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        KeyExchange._item_type = str

        class Mac(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Mac._item_type = str

        class Hostkey(AvdModel):
            """Subclass of AvdModel."""

            class Server(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Server._item_type = str

            _fields: ClassVar[dict] = {
                "server": {"type": Server},
                "server_cert": {"type": str},
                "client_strict_checking": {"type": bool},
                "_custom_data": {"type": dict},
            }
            server: Server
            """
            SSH host key settings.

            Subclass of AvdList with `str` items.
            """
            server_cert: str | None
            """Configure switch's hostkey cert file."""
            client_strict_checking: bool | None
            """Enforce strict host key checking."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    server: Server | UndefinedType = Undefined,
                    server_cert: str | None | UndefinedType = Undefined,
                    client_strict_checking: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Hostkey.


                    Subclass of AvdModel.

                    Args:
                        server:
                           SSH host key settings.

                           Subclass of AvdList with `str` items.
                        server_cert: Configure switch's hostkey cert file.
                        client_strict_checking: Enforce strict host key checking.
                        _custom_data: _custom_data

                    """

        class Connection(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"limit": {"type": int}, "per_host": {"type": int}, "_custom_data": {"type": dict}}
            limit: int | None
            """Maximum total number of SSH sessions to device."""
            per_host: int | None
            """Maximum number of SSH sessions to device from a single host."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    limit: int | None | UndefinedType = Undefined,
                    per_host: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Connection.


                    Subclass of AvdModel.

                    Args:
                        limit: Maximum total number of SSH sessions to device.
                        per_host: Maximum number of SSH sessions to device from a single host.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "enable": {"type": bool}, "_custom_data": {"type": dict}}
            name: str
            """VRF Name."""
            enable: bool | None
            """Enable SSH in VRF."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enable: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        enable: Enable SSH in VRF.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ClientAlive(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"count_max": {"type": int}, "interval": {"type": int}, "_custom_data": {"type": dict}}
            count_max: int | None
            """
            Number of keep-alive packets that can be sent without a response before the connection is assumed
            dead.
            """
            interval: int | None
            """Time period (in seconds) to send SSH keep-alive packets."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    count_max: int | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClientAlive.


                    Subclass of AvdModel.

                    Args:
                        count_max:
                           Number of keep-alive packets that can be sent without a response before the connection is assumed
                           dead.
                        interval: Time period (in seconds) to send SSH keep-alive packets.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "authentication": {"type": Authentication},
            "access_groups": {"type": AccessGroups},
            "ipv6_access_groups": {"type": Ipv6AccessGroups},
            "idle_timeout": {"type": int},
            "cipher": {"type": Cipher},
            "key_exchange": {"type": KeyExchange},
            "mac": {"type": Mac},
            "fips_restrictions": {"type": bool},
            "hostkey": {"type": Hostkey},
            "enable": {"type": bool},
            "connection": {"type": Connection},
            "vrfs": {"type": Vrfs},
            "log_level": {"type": str},
            "client_alive": {"type": ClientAlive},
            "_custom_data": {"type": dict},
        }
        authentication: Authentication
        """Subclass of AvdModel."""
        access_groups: AccessGroups
        """Subclass of AvdList with `AccessGroupsItem` items."""
        ipv6_access_groups: Ipv6AccessGroups
        """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""
        idle_timeout: int | None
        """Idle timeout in minutes."""
        cipher: Cipher
        """
        Cryptographic ciphers for SSH to use.

        Subclass of AvdList with `str` items.
        """
        key_exchange: KeyExchange
        """
        Cryptographic key exchange methods for SSH to use.

        Subclass of AvdList with `str` items.
        """
        mac: Mac
        """
        Cryptographic MAC algorithms for SSH to use.

        Subclass of AvdList with `str` items.
        """
        fips_restrictions: bool | None
        """Use FIPS compliant algorithms."""
        hostkey: Hostkey
        """Subclass of AvdModel."""
        enable: bool | None
        """Enable SSH daemon."""
        connection: Connection
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        log_level: str | None
        """SSH daemon log level."""
        client_alive: ClientAlive
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                authentication: Authentication | UndefinedType = Undefined,
                access_groups: AccessGroups | UndefinedType = Undefined,
                ipv6_access_groups: Ipv6AccessGroups | UndefinedType = Undefined,
                idle_timeout: int | None | UndefinedType = Undefined,
                cipher: Cipher | UndefinedType = Undefined,
                key_exchange: KeyExchange | UndefinedType = Undefined,
                mac: Mac | UndefinedType = Undefined,
                fips_restrictions: bool | None | UndefinedType = Undefined,
                hostkey: Hostkey | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                connection: Connection | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                log_level: str | None | UndefinedType = Undefined,
                client_alive: ClientAlive | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ManagementSsh.


                Subclass of AvdModel.

                Args:
                    authentication: Subclass of AvdModel.
                    access_groups: Subclass of AvdList with `AccessGroupsItem` items.
                    ipv6_access_groups: Subclass of AvdList with `Ipv6AccessGroupsItem` items.
                    idle_timeout: Idle timeout in minutes.
                    cipher:
                       Cryptographic ciphers for SSH to use.

                       Subclass of AvdList with `str` items.
                    key_exchange:
                       Cryptographic key exchange methods for SSH to use.

                       Subclass of AvdList with `str` items.
                    mac:
                       Cryptographic MAC algorithms for SSH to use.

                       Subclass of AvdList with `str` items.
                    fips_restrictions: Use FIPS compliant algorithms.
                    hostkey: Subclass of AvdModel.
                    enable: Enable SSH daemon.
                    connection: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    log_level: SSH daemon log level.
                    client_alive: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ManagementTechSupport(AvdModel):
        """Subclass of AvdModel."""

        class PolicyShowTechSupport(AvdModel):
            """Subclass of AvdModel."""

            class ExcludeCommandsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"command": {"type": str}, "type": {"type": str, "default": "text"}, "_custom_data": {"type": dict}}
                command: str | None
                """Command to exclude from tech-support."""
                type: Literal["text", "json"]
                """
                The supported values for type are platform dependent.

                Default value: `"text"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        command: str | None | UndefinedType = Undefined,
                        type: Literal["text", "json"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExcludeCommandsItem.


                        Subclass of AvdModel.

                        Args:
                            command: Command to exclude from tech-support.
                            type: The supported values for type are platform dependent.
                            _custom_data: _custom_data

                        """

            class ExcludeCommands(AvdList[ExcludeCommandsItem]):
                """Subclass of AvdList with `ExcludeCommandsItem` items."""

            ExcludeCommands._item_type = ExcludeCommandsItem

            class IncludeCommandsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"command": {"type": str}, "_custom_data": {"type": dict}}
                command: str | None
                """Command to include in tech-support."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, command: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        IncludeCommandsItem.


                        Subclass of AvdModel.

                        Args:
                            command: Command to include in tech-support.
                            _custom_data: _custom_data

                        """

            class IncludeCommands(AvdList[IncludeCommandsItem]):
                """Subclass of AvdList with `IncludeCommandsItem` items."""

            IncludeCommands._item_type = IncludeCommandsItem

            _fields: ClassVar[dict] = {
                "exclude_commands": {"type": ExcludeCommands},
                "include_commands": {"type": IncludeCommands},
                "_custom_data": {"type": dict},
            }
            exclude_commands: ExcludeCommands
            """Subclass of AvdList with `ExcludeCommandsItem` items."""
            include_commands: IncludeCommands
            """Subclass of AvdList with `IncludeCommandsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    exclude_commands: ExcludeCommands | UndefinedType = Undefined,
                    include_commands: IncludeCommands | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PolicyShowTechSupport.


                    Subclass of AvdModel.

                    Args:
                        exclude_commands: Subclass of AvdList with `ExcludeCommandsItem` items.
                        include_commands: Subclass of AvdList with `IncludeCommandsItem` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"policy_show_tech_support": {"type": PolicyShowTechSupport}, "_custom_data": {"type": dict}}
        policy_show_tech_support: PolicyShowTechSupport
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self, *, policy_show_tech_support: PolicyShowTechSupport | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
            ) -> None:
                """
                ManagementTechSupport.


                Subclass of AvdModel.

                Args:
                    policy_show_tech_support: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MatchListInput(AvdModel):
        """Subclass of AvdModel."""

        class PrefixIpv4Item(AvdModel):
            """Subclass of AvdModel."""

            class Prefixes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Prefixes._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
            name: str
            """Prefix-List Name."""
            prefixes: Prefixes
            """
            List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

            Subclass of AvdList with `str`
            items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    prefixes: Prefixes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrefixIpv4Item.


                    Subclass of AvdModel.

                    Args:
                        name: Prefix-List Name.
                        prefixes:
                           List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

                           Subclass of AvdList with `str`
                           items.
                        _custom_data: _custom_data

                    """

        class PrefixIpv4(AvdIndexedList[str, PrefixIpv4Item]):
            """Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PrefixIpv4._item_type = PrefixIpv4Item

        class PrefixIpv6Item(AvdModel):
            """Subclass of AvdModel."""

            class Prefixes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Prefixes._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
            name: str
            """Prefix-List Name."""
            prefixes: Prefixes
            """
            List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

            Subclass of AvdList with
            `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    prefixes: Prefixes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrefixIpv6Item.


                    Subclass of AvdModel.

                    Args:
                        name: Prefix-List Name.
                        prefixes:
                           List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

                           Subclass of AvdList with
                           `str` items.
                        _custom_data: _custom_data

                    """

        class PrefixIpv6(AvdIndexedList[str, PrefixIpv6Item]):
            """Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PrefixIpv6._item_type = PrefixIpv6Item

        class StringItem(AvdModel):
            """Subclass of AvdModel."""

            class SequenceNumbersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"sequence": {"type": int}, "match_regex": {"type": str}, "_custom_data": {"type": dict}}
                sequence: int
                """Sequence ID."""
                match_regex: str
                """Regular Expression."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        sequence: int | UndefinedType = Undefined,
                        match_regex: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SequenceNumbersItem.


                        Subclass of AvdModel.

                        Args:
                            sequence: Sequence ID.
                            match_regex: Regular Expression.
                            _custom_data: _custom_data

                        """

            class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
                """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
            name: str
            """Match-list Name."""
            sequence_numbers: SequenceNumbers
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StringItem.


                    Subclass of AvdModel.

                    Args:
                        name: Match-list Name.
                        sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                        _custom_data: _custom_data

                    """

        class String(AvdIndexedList[str, StringItem]):
            """Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        String._item_type = StringItem

        _fields: ClassVar[dict] = {
            "prefix_ipv4": {"type": PrefixIpv4},
            "prefix_ipv6": {"type": PrefixIpv6},
            "string": {"type": String},
            "_custom_data": {"type": dict},
        }
        prefix_ipv4: PrefixIpv4
        """Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`)."""
        prefix_ipv6: PrefixIpv6
        """Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`)."""
        string: String
        """Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                prefix_ipv4: PrefixIpv4 | UndefinedType = Undefined,
                prefix_ipv6: PrefixIpv6 | UndefinedType = Undefined,
                string: String | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MatchListInput.


                Subclass of AvdModel.

                Args:
                    prefix_ipv4: Subclass of AvdIndexedList with `PrefixIpv4Item` items. Primary key is `name` (`str`).
                    prefix_ipv6: Subclass of AvdIndexedList with `PrefixIpv6Item` items. Primary key is `name` (`str`).
                    string: Subclass of AvdIndexedList with `StringItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class McsClient(AvdModel):
        """Subclass of AvdModel."""

        class CvxSecondary(AvdModel):
            """Subclass of AvdModel."""

            class ServerHosts(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            ServerHosts._item_type = str

            _fields: ClassVar[dict] = {"name": {"type": str}, "shutdown": {"type": bool}, "server_hosts": {"type": ServerHosts}, "_custom_data": {"type": dict}}
            name: str | None
            shutdown: bool | None
            server_hosts: ServerHosts
            """Subclass of AvdList with `str` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    server_hosts: ServerHosts | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CvxSecondary.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        shutdown: shutdown
                        server_hosts: Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"shutdown": {"type": bool}, "cvx_secondary": {"type": CvxSecondary}, "_custom_data": {"type": dict}}
        shutdown: bool | None
        cvx_secondary: CvxSecondary
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                cvx_secondary: CvxSecondary | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                McsClient.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    cvx_secondary: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Metadata(AvdModel):
        """Subclass of AvdModel."""

        class CvTags(AvdModel):
            """Subclass of AvdModel."""

            class DeviceTagsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                value: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        value: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DeviceTagsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            value: value
                            _custom_data: _custom_data

                        """

            class DeviceTags(AvdList[DeviceTagsItem]):
                """Subclass of AvdList with `DeviceTagsItem` items."""

            DeviceTags._item_type = DeviceTagsItem

            class InterfaceTagsItem(AvdModel):
                """Subclass of AvdModel."""

                class TagsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}, "_custom_data": {"type": dict}}
                    name: str
                    value: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            value: str | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TagsItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                value: value
                                _custom_data: _custom_data

                            """

                class Tags(AvdList[TagsItem]):
                    """Subclass of AvdList with `TagsItem` items."""

                Tags._item_type = TagsItem

                _fields: ClassVar[dict] = {"interface": {"type": str}, "tags": {"type": Tags}, "_custom_data": {"type": dict}}
                interface: str
                tags: Tags
                """Subclass of AvdList with `TagsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interface: str | UndefinedType = Undefined,
                        tags: Tags | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InterfaceTagsItem.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            tags: Subclass of AvdList with `TagsItem` items.
                            _custom_data: _custom_data

                        """

            class InterfaceTags(AvdList[InterfaceTagsItem]):
                """Subclass of AvdList with `InterfaceTagsItem` items."""

            InterfaceTags._item_type = InterfaceTagsItem

            _fields: ClassVar[dict] = {"device_tags": {"type": DeviceTags}, "interface_tags": {"type": InterfaceTags}, "_custom_data": {"type": dict}}
            device_tags: DeviceTags
            """Subclass of AvdList with `DeviceTagsItem` items."""
            interface_tags: InterfaceTags
            """Subclass of AvdList with `InterfaceTagsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    device_tags: DeviceTags | UndefinedType = Undefined,
                    interface_tags: InterfaceTags | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CvTags.


                    Subclass of AvdModel.

                    Args:
                        device_tags: Subclass of AvdList with `DeviceTagsItem` items.
                        interface_tags: Subclass of AvdList with `InterfaceTagsItem` items.
                        _custom_data: _custom_data

                    """

        class CvPathfinder(AvdModel):
            """Subclass of AvdModel."""

            class PathfindersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vtep_ip": {"type": str}, "_custom_data": {"type": dict}}
                vtep_ip: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, vtep_ip: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        PathfindersItem.


                        Subclass of AvdModel.

                        Args:
                            vtep_ip: vtep_ip
                            _custom_data: _custom_data

                        """

            class Pathfinders(AvdList[PathfindersItem]):
                """Subclass of AvdList with `PathfindersItem` items."""

            Pathfinders._item_type = PathfindersItem

            class InterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "carrier": {"type": str},
                    "circuit_id": {"type": str},
                    "pathgroup": {"type": str},
                    "public_ip": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str | None
                carrier: str | None
                circuit_id: str | None
                pathgroup: str | None
                public_ip: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        carrier: str | None | UndefinedType = Undefined,
                        circuit_id: str | None | UndefinedType = Undefined,
                        pathgroup: str | None | UndefinedType = Undefined,
                        public_ip: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            carrier: carrier
                            circuit_id: circuit_id
                            pathgroup: pathgroup
                            public_ip: public_ip
                            _custom_data: _custom_data

                        """

            class Interfaces(AvdList[InterfacesItem]):
                """Subclass of AvdList with `InterfacesItem` items."""

            Interfaces._item_type = InterfacesItem

            class PathgroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class CarriersItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                    name: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            CarriersItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                _custom_data: _custom_data

                            """

                class Carriers(AvdList[CarriersItem]):
                    """Subclass of AvdList with `CarriersItem` items."""

                Carriers._item_type = CarriersItem

                class ImportedCarriersItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                    name: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            ImportedCarriersItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                _custom_data: _custom_data

                            """

                class ImportedCarriers(AvdList[ImportedCarriersItem]):
                    """Subclass of AvdList with `ImportedCarriersItem` items."""

                ImportedCarriers._item_type = ImportedCarriersItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "carriers": {"type": Carriers},
                    "imported_carriers": {"type": ImportedCarriers},
                    "_custom_data": {"type": dict},
                }
                name: str
                carriers: Carriers
                """Subclass of AvdList with `CarriersItem` items."""
                imported_carriers: ImportedCarriers
                """Subclass of AvdList with `ImportedCarriersItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        carriers: Carriers | UndefinedType = Undefined,
                        imported_carriers: ImportedCarriers | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathgroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            carriers: Subclass of AvdList with `CarriersItem` items.
                            imported_carriers: Subclass of AvdList with `ImportedCarriersItem` items.
                            _custom_data: _custom_data

                        """

            class Pathgroups(AvdList[PathgroupsItem]):
                """Subclass of AvdList with `PathgroupsItem` items."""

            Pathgroups._item_type = PathgroupsItem

            class RegionsItem(AvdModel):
                """Subclass of AvdModel."""

                class ZonesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class SitesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Location(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"address": {"type": str}, "_custom_data": {"type": dict}}
                            address: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self, *, address: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Location.


                                    Subclass of AvdModel.

                                    Args:
                                        address: address
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "location": {"type": Location}, "_custom_data": {"type": dict}}
                        id: int | None
                        name: str | None
                        location: Location
                        """Subclass of AvdModel."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                location: Location | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SitesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    name: name
                                    location: Subclass of AvdModel.
                                    _custom_data: _custom_data

                                """

                    class Sites(AvdList[SitesItem]):
                        """Subclass of AvdList with `SitesItem` items."""

                    Sites._item_type = SitesItem

                    _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "sites": {"type": Sites}, "_custom_data": {"type": dict}}
                    id: int | None
                    name: str | None
                    sites: Sites
                    """Subclass of AvdList with `SitesItem` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            sites: Sites | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ZonesItem.


                            Subclass of AvdModel.

                            Args:
                                id: id
                                name: name
                                sites: Subclass of AvdList with `SitesItem` items.
                                _custom_data: _custom_data

                            """

                class Zones(AvdList[ZonesItem]):
                    """Subclass of AvdList with `ZonesItem` items."""

                Zones._item_type = ZonesItem

                _fields: ClassVar[dict] = {"id": {"type": int}, "name": {"type": str}, "zones": {"type": Zones}, "_custom_data": {"type": dict}}
                id: int | None
                name: str | None
                zones: Zones
                """Subclass of AvdList with `ZonesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: int | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        zones: Zones | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RegionsItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            name: name
                            zones: Subclass of AvdList with `ZonesItem` items.
                            _custom_data: _custom_data

                        """

            class Regions(AvdList[RegionsItem]):
                """Subclass of AvdList with `RegionsItem` items."""

            Regions._item_type = RegionsItem

            class VrfsItem(AvdModel):
                """Subclass of AvdModel."""

                class AvtsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Constraints(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "jitter": {"type": int},
                            "latency": {"type": int},
                            "lossrate": {"type": str},
                            "hop_count": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        jitter: int | None
                        latency: int | None
                        lossrate: str | None
                        hop_count: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                jitter: int | None | UndefinedType = Undefined,
                                latency: int | None | UndefinedType = Undefined,
                                lossrate: str | None | UndefinedType = Undefined,
                                hop_count: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Constraints.


                                Subclass of AvdModel.

                                Args:
                                    jitter: jitter
                                    latency: latency
                                    lossrate: lossrate
                                    hop_count: hop_count
                                    _custom_data: _custom_data

                                """

                    class PathgroupsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}, "preference": {"type": str}, "_custom_data": {"type": dict}}
                        name: str | None
                        preference: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                name: str | None | UndefinedType = Undefined,
                                preference: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PathgroupsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    preference: preference
                                    _custom_data: _custom_data

                                """

                    class Pathgroups(AvdList[PathgroupsItem]):
                        """Subclass of AvdList with `PathgroupsItem` items."""

                    Pathgroups._item_type = PathgroupsItem

                    class ApplicationProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ApplicationProfiles._item_type = str

                    _fields: ClassVar[dict] = {
                        "constraints": {"type": Constraints},
                        "description": {"type": str},
                        "id": {"type": int},
                        "name": {"type": str},
                        "pathgroups": {"type": Pathgroups},
                        "application_profiles": {"type": ApplicationProfiles},
                        "_custom_data": {"type": dict},
                    }
                    constraints: Constraints
                    """Subclass of AvdModel."""
                    description: str | None
                    id: int | None
                    name: str | None
                    pathgroups: Pathgroups
                    """Subclass of AvdList with `PathgroupsItem` items."""
                    application_profiles: ApplicationProfiles
                    """Subclass of AvdList with `str` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            constraints: Constraints | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            id: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            pathgroups: Pathgroups | UndefinedType = Undefined,
                            application_profiles: ApplicationProfiles | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AvtsItem.


                            Subclass of AvdModel.

                            Args:
                                constraints: Subclass of AvdModel.
                                description: description
                                id: id
                                name: name
                                pathgroups: Subclass of AvdList with `PathgroupsItem` items.
                                application_profiles: Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Avts(AvdList[AvtsItem]):
                    """Subclass of AvdList with `AvtsItem` items."""

                Avts._item_type = AvtsItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "vni": {"type": int}, "avts": {"type": Avts}, "_custom_data": {"type": dict}}
                name: str | None
                vni: int | None
                avts: Avts
                """Subclass of AvdList with `AvtsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        avts: Avts | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            vni: vni
                            avts: Subclass of AvdList with `AvtsItem` items.
                            _custom_data: _custom_data

                        """

            class Vrfs(AvdList[VrfsItem]):
                """Subclass of AvdList with `VrfsItem` items."""

            Vrfs._item_type = VrfsItem

            class InternetExitPoliciesItem(AvdModel):
                """Subclass of AvdModel."""

                class VpnCredentialsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "fqdn": {"type": str},
                        "vpn_type": {"type": str},
                        "pre_shared_key": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    fqdn: str
                    vpn_type: str
                    pre_shared_key: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            fqdn: str | UndefinedType = Undefined,
                            vpn_type: str | UndefinedType = Undefined,
                            pre_shared_key: str | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VpnCredentialsItem.


                            Subclass of AvdModel.

                            Args:
                                fqdn: fqdn
                                vpn_type: vpn_type
                                pre_shared_key: pre_shared_key
                                _custom_data: _custom_data

                            """

                class VpnCredentials(AvdList[VpnCredentialsItem]):
                    """Subclass of AvdList with `VpnCredentialsItem` items."""

                VpnCredentials._item_type = VpnCredentialsItem

                class TunnelsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Endpoint(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "ip_address": {"type": str},
                            "datacenter": {"type": str},
                            "city": {"type": str},
                            "country": {"type": str},
                            "region": {"type": str},
                            "latitude": {"type": str},
                            "longitude": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        ip_address: str
                        datacenter: str
                        city: str
                        country: str
                        region: str
                        latitude: str
                        longitude: str
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                ip_address: str | UndefinedType = Undefined,
                                datacenter: str | UndefinedType = Undefined,
                                city: str | UndefinedType = Undefined,
                                country: str | UndefinedType = Undefined,
                                region: str | UndefinedType = Undefined,
                                latitude: str | UndefinedType = Undefined,
                                longitude: str | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Endpoint.


                                Subclass of AvdModel.

                                Args:
                                    ip_address: ip_address
                                    datacenter: datacenter
                                    city: city
                                    country: country
                                    region: region
                                    latitude: latitude
                                    longitude: longitude
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "preference": {"type": str},
                        "endpoint": {"type": Endpoint},
                        "_custom_data": {"type": dict},
                    }
                    name: str
                    preference: str
                    endpoint: Endpoint
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            preference: str | UndefinedType = Undefined,
                            endpoint: Endpoint | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TunnelsItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                preference: preference
                                endpoint: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Tunnels(AvdList[TunnelsItem]):
                    """Subclass of AvdList with `TunnelsItem` items."""

                Tunnels._item_type = TunnelsItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "city": {"type": str},
                    "country": {"type": str},
                    "upload_bandwidth": {"type": int},
                    "download_bandwidth": {"type": int},
                    "firewall": {"type": bool},
                    "ips_control": {"type": bool},
                    "acceptable_use_policy": {"type": bool},
                    "vpn_credentials": {"type": VpnCredentials},
                    "tunnels": {"type": Tunnels},
                    "_custom_data": {"type": dict},
                }
                name: str
                type: str
                city: str
                country: str
                upload_bandwidth: int | None
                download_bandwidth: int | None
                firewall: bool
                ips_control: bool
                acceptable_use_policy: bool
                vpn_credentials: VpnCredentials
                """Subclass of AvdList with `VpnCredentialsItem` items."""
                tunnels: Tunnels
                """Subclass of AvdList with `TunnelsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: str | UndefinedType = Undefined,
                        city: str | UndefinedType = Undefined,
                        country: str | UndefinedType = Undefined,
                        upload_bandwidth: int | None | UndefinedType = Undefined,
                        download_bandwidth: int | None | UndefinedType = Undefined,
                        firewall: bool | UndefinedType = Undefined,
                        ips_control: bool | UndefinedType = Undefined,
                        acceptable_use_policy: bool | UndefinedType = Undefined,
                        vpn_credentials: VpnCredentials | UndefinedType = Undefined,
                        tunnels: Tunnels | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InternetExitPoliciesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            type: type
                            city: city
                            country: country
                            upload_bandwidth: upload_bandwidth
                            download_bandwidth: download_bandwidth
                            firewall: firewall
                            ips_control: ips_control
                            acceptable_use_policy: acceptable_use_policy
                            vpn_credentials: Subclass of AvdList with `VpnCredentialsItem` items.
                            tunnels: Subclass of AvdList with `TunnelsItem` items.
                            _custom_data: _custom_data

                        """

            class InternetExitPolicies(AvdList[InternetExitPoliciesItem]):
                """Subclass of AvdList with `InternetExitPoliciesItem` items."""

            InternetExitPolicies._item_type = InternetExitPoliciesItem

            class Applications(AvdModel):
                """Subclass of AvdModel."""

                class ProfilesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class BuiltinApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {"name": {"type": str}, "services": {"type": Services}, "_custom_data": {"type": dict}}
                        name: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                name: str | None | UndefinedType = Undefined,
                                services: Services | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                BuiltinApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    services: Subclass of AvdList with `str` items.
                                    _custom_data: _custom_data

                                """

                    class BuiltinApplications(AvdList[BuiltinApplicationsItem]):
                        """Subclass of AvdList with `BuiltinApplicationsItem` items."""

                    BuiltinApplications._item_type = BuiltinApplicationsItem

                    class UserDefinedApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                        name: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                UserDefinedApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    _custom_data: _custom_data

                                """

                    class UserDefinedApplications(AvdList[UserDefinedApplicationsItem]):
                        """Subclass of AvdList with `UserDefinedApplicationsItem` items."""

                    UserDefinedApplications._item_type = UserDefinedApplicationsItem

                    class CategoriesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {"category": {"type": str}, "services": {"type": Services}, "_custom_data": {"type": dict}}
                        category: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                category: str | None | UndefinedType = Undefined,
                                services: Services | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CategoriesItem.


                                Subclass of AvdModel.

                                Args:
                                    category: category
                                    services: Subclass of AvdList with `str` items.
                                    _custom_data: _custom_data

                                """

                    class Categories(AvdList[CategoriesItem]):
                        """Subclass of AvdList with `CategoriesItem` items."""

                    Categories._item_type = CategoriesItem

                    class TransportProtocols(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    TransportProtocols._item_type = str

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "builtin_applications": {"type": BuiltinApplications},
                        "user_defined_applications": {"type": UserDefinedApplications},
                        "categories": {"type": Categories},
                        "transport_protocols": {"type": TransportProtocols},
                        "_custom_data": {"type": dict},
                    }
                    name: str | None
                    builtin_applications: BuiltinApplications
                    """Subclass of AvdList with `BuiltinApplicationsItem` items."""
                    user_defined_applications: UserDefinedApplications
                    """Subclass of AvdList with `UserDefinedApplicationsItem` items."""
                    categories: Categories
                    """Subclass of AvdList with `CategoriesItem` items."""
                    transport_protocols: TransportProtocols
                    """Subclass of AvdList with `str` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | None | UndefinedType = Undefined,
                            builtin_applications: BuiltinApplications | UndefinedType = Undefined,
                            user_defined_applications: UserDefinedApplications | UndefinedType = Undefined,
                            categories: Categories | UndefinedType = Undefined,
                            transport_protocols: TransportProtocols | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProfilesItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                builtin_applications: Subclass of AvdList with `BuiltinApplicationsItem` items.
                                user_defined_applications: Subclass of AvdList with `UserDefinedApplicationsItem` items.
                                categories: Subclass of AvdList with `CategoriesItem` items.
                                transport_protocols: Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Profiles(AvdList[ProfilesItem]):
                    """Subclass of AvdList with `ProfilesItem` items."""

                Profiles._item_type = ProfilesItem

                class Categories(AvdModel):
                    """Subclass of AvdModel."""

                    class BuiltinApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Services(AvdList[str]):
                            """Subclass of AvdList with `str` items."""

                        Services._item_type = str

                        _fields: ClassVar[dict] = {
                            "name": {"type": str},
                            "category": {"type": str},
                            "services": {"type": Services},
                            "_custom_data": {"type": dict},
                        }
                        name: str | None
                        category: str | None
                        services: Services
                        """Subclass of AvdList with `str` items."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                name: str | None | UndefinedType = Undefined,
                                category: str | None | UndefinedType = Undefined,
                                services: Services | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                BuiltinApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    category: category
                                    services: Subclass of AvdList with `str` items.
                                    _custom_data: _custom_data

                                """

                    class BuiltinApplications(AvdList[BuiltinApplicationsItem]):
                        """Subclass of AvdList with `BuiltinApplicationsItem` items."""

                    BuiltinApplications._item_type = BuiltinApplicationsItem

                    class UserDefinedApplicationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"name": {"type": str}, "category": {"type": str}, "_custom_data": {"type": dict}}
                        name: str | None
                        category: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                name: str | None | UndefinedType = Undefined,
                                category: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                UserDefinedApplicationsItem.


                                Subclass of AvdModel.

                                Args:
                                    name: name
                                    category: category
                                    _custom_data: _custom_data

                                """

                    class UserDefinedApplications(AvdList[UserDefinedApplicationsItem]):
                        """Subclass of AvdList with `UserDefinedApplicationsItem` items."""

                    UserDefinedApplications._item_type = UserDefinedApplicationsItem

                    _fields: ClassVar[dict] = {
                        "builtin_applications": {"type": BuiltinApplications},
                        "user_defined_applications": {"type": UserDefinedApplications},
                        "_custom_data": {"type": dict},
                    }
                    builtin_applications: BuiltinApplications
                    """Subclass of AvdList with `BuiltinApplicationsItem` items."""
                    user_defined_applications: UserDefinedApplications
                    """Subclass of AvdList with `UserDefinedApplicationsItem` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            builtin_applications: BuiltinApplications | UndefinedType = Undefined,
                            user_defined_applications: UserDefinedApplications | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Categories.


                            Subclass of AvdModel.

                            Args:
                                builtin_applications: Subclass of AvdList with `BuiltinApplicationsItem` items.
                                user_defined_applications: Subclass of AvdList with `UserDefinedApplicationsItem` items.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"profiles": {"type": Profiles}, "categories": {"type": Categories}, "_custom_data": {"type": dict}}
                profiles: Profiles
                """Subclass of AvdList with `ProfilesItem` items."""
                categories: Categories
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        profiles: Profiles | UndefinedType = Undefined,
                        categories: Categories | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Applications.


                        Subclass of AvdModel.

                        Args:
                            profiles: Subclass of AvdList with `ProfilesItem` items.
                            categories: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "role": {"type": str},
                "region": {"type": str},
                "zone": {"type": str},
                "site": {"type": str},
                "vtep_ip": {"type": str},
                "ssl_profile": {"type": str},
                "address": {"type": str},
                "pathfinders": {"type": Pathfinders},
                "interfaces": {"type": Interfaces},
                "pathgroups": {"type": Pathgroups},
                "regions": {"type": Regions},
                "vrfs": {"type": Vrfs},
                "internet_exit_policies": {"type": InternetExitPolicies},
                "applications": {"type": Applications},
                "_custom_data": {"type": dict},
            }
            role: str | None
            region: str | None
            zone: str | None
            site: str | None
            vtep_ip: str | None
            ssl_profile: str | None
            address: str | None
            pathfinders: Pathfinders
            """Subclass of AvdList with `PathfindersItem` items."""
            interfaces: Interfaces
            """Subclass of AvdList with `InterfacesItem` items."""
            pathgroups: Pathgroups
            """Subclass of AvdList with `PathgroupsItem` items."""
            regions: Regions
            """Subclass of AvdList with `RegionsItem` items."""
            vrfs: Vrfs
            """Subclass of AvdList with `VrfsItem` items."""
            internet_exit_policies: InternetExitPolicies
            """Subclass of AvdList with `InternetExitPoliciesItem` items."""
            applications: Applications
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    role: str | None | UndefinedType = Undefined,
                    region: str | None | UndefinedType = Undefined,
                    zone: str | None | UndefinedType = Undefined,
                    site: str | None | UndefinedType = Undefined,
                    vtep_ip: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    pathfinders: Pathfinders | UndefinedType = Undefined,
                    interfaces: Interfaces | UndefinedType = Undefined,
                    pathgroups: Pathgroups | UndefinedType = Undefined,
                    regions: Regions | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                    internet_exit_policies: InternetExitPolicies | UndefinedType = Undefined,
                    applications: Applications | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CvPathfinder.


                    Subclass of AvdModel.

                    Args:
                        role: role
                        region: region
                        zone: zone
                        site: site
                        vtep_ip: vtep_ip
                        ssl_profile: ssl_profile
                        address: address
                        pathfinders: Subclass of AvdList with `PathfindersItem` items.
                        interfaces: Subclass of AvdList with `InterfacesItem` items.
                        pathgroups: Subclass of AvdList with `PathgroupsItem` items.
                        regions: Subclass of AvdList with `RegionsItem` items.
                        vrfs: Subclass of AvdList with `VrfsItem` items.
                        internet_exit_policies: Subclass of AvdList with `InternetExitPoliciesItem` items.
                        applications: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "platform": {"type": str},
            "system_mac_address": {"type": str},
            "cv_tags": {"type": CvTags},
            "cv_pathfinder": {"type": CvPathfinder},
            "_custom_data": {"type": dict},
        }
        platform: str | None
        system_mac_address: str | None
        cv_tags: CvTags
        """Subclass of AvdModel."""
        cv_pathfinder: CvPathfinder
        """
        Metadata used for CV Pathfinder visualization on CloudVision.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                platform: str | None | UndefinedType = Undefined,
                system_mac_address: str | None | UndefinedType = Undefined,
                cv_tags: CvTags | UndefinedType = Undefined,
                cv_pathfinder: CvPathfinder | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Metadata.


                Subclass of AvdModel.

                Args:
                    platform: platform
                    system_mac_address: system_mac_address
                    cv_tags: Subclass of AvdModel.
                    cv_pathfinder:
                       Metadata used for CV Pathfinder visualization on CloudVision.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MlagConfiguration(AvdModel):
        """Subclass of AvdModel."""

        class PeerAddressHeartbeat(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"peer_ip": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            peer_ip: str | None
            """IPv4 or IPv6 Address."""
            vrf: str | None
            """VRF Name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    peer_ip: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerAddressHeartbeat.


                    Subclass of AvdModel.

                    Args:
                        peer_ip: IPv4 or IPv6 Address.
                        vrf: VRF Name.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "domain_id": {"type": str},
            "heartbeat_interval": {"type": int},
            "local_interface": {"type": str},
            "peer_address": {"type": str},
            "peer_address_heartbeat": {"type": PeerAddressHeartbeat},
            "dual_primary_detection_delay": {"type": int},
            "dual_primary_recovery_delay_mlag": {"type": int},
            "dual_primary_recovery_delay_non_mlag": {"type": int},
            "peer_link": {"type": str},
            "reload_delay_mlag": {"type": str},
            "reload_delay_non_mlag": {"type": str},
            "_custom_data": {"type": dict},
        }
        domain_id: str | None
        heartbeat_interval: int | None
        """Heartbeat interval in milliseconds."""
        local_interface: str | None
        """Local Interface Name."""
        peer_address: str | None
        """IPv4 or IPv6 Address."""
        peer_address_heartbeat: PeerAddressHeartbeat
        """Subclass of AvdModel."""
        dual_primary_detection_delay: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_mlag: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_non_mlag: int | None
        """Delay in seconds."""
        peer_link: str | None
        """Port-Channel interface name."""
        reload_delay_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""
        reload_delay_non_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                domain_id: str | None | UndefinedType = Undefined,
                heartbeat_interval: int | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                peer_address: str | None | UndefinedType = Undefined,
                peer_address_heartbeat: PeerAddressHeartbeat | UndefinedType = Undefined,
                dual_primary_detection_delay: int | None | UndefinedType = Undefined,
                dual_primary_recovery_delay_mlag: int | None | UndefinedType = Undefined,
                dual_primary_recovery_delay_non_mlag: int | None | UndefinedType = Undefined,
                peer_link: str | None | UndefinedType = Undefined,
                reload_delay_mlag: str | None | UndefinedType = Undefined,
                reload_delay_non_mlag: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MlagConfiguration.


                Subclass of AvdModel.

                Args:
                    domain_id: domain_id
                    heartbeat_interval: Heartbeat interval in milliseconds.
                    local_interface: Local Interface Name.
                    peer_address: IPv4 or IPv6 Address.
                    peer_address_heartbeat: Subclass of AvdModel.
                    dual_primary_detection_delay: Delay in seconds.
                    dual_primary_recovery_delay_mlag: Delay in seconds.
                    dual_primary_recovery_delay_non_mlag: Delay in seconds.
                    peer_link: Port-Channel interface name.
                    reload_delay_mlag: Delay in seconds <0-86400> or 'infinity'.
                    reload_delay_non_mlag: Delay in seconds <0-86400> or 'infinity'.
                    _custom_data: _custom_data

                """

    class MonitorConnectivity(AvdModel):
        """Subclass of AvdModel."""

        class InterfaceSetsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "interfaces": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            interfaces: str | None
            """
            Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
            Multiple interface
            ranges can be specified separated by ",".
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    interfaces: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceSetsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        interfaces:
                           Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
                           Multiple interface
                           ranges can be specified separated by ",".
                        _custom_data: _custom_data

                    """

        class InterfaceSets(AvdList[InterfaceSetsItem]):
            """Subclass of AvdList with `InterfaceSetsItem` items."""

        InterfaceSets._item_type = InterfaceSetsItem

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "description": {"type": str},
                "ip": {"type": str},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "url": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Host Name."""
            description: str | None
            ip: str | None
            local_interfaces: str | None
            address_only: bool
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.

            Default value: `True`
            """
            url: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    ip: str | None | UndefinedType = Undefined,
                    local_interfaces: str | None | UndefinedType = Undefined,
                    address_only: bool | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Host Name.
                        description: description
                        ip: ip
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        url: url
                        _custom_data: _custom_data

                    """

        class Hosts(AvdIndexedList[str, HostsItem]):
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Hosts._item_type = HostsItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class InterfaceSetsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "interfaces": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                interfaces: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        interfaces: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InterfaceSetsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            interfaces: interfaces
                            _custom_data: _custom_data

                        """

            class InterfaceSets(AvdList[InterfaceSetsItem]):
                """Subclass of AvdList with `InterfaceSetsItem` items."""

            InterfaceSets._item_type = InterfaceSetsItem

            class HostsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "description": {"type": str},
                    "ip": {"type": str},
                    "local_interfaces": {"type": str},
                    "address_only": {"type": bool, "default": True},
                    "url": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Host name."""
                description: str | None
                ip: str | None
                local_interfaces: str | None
                address_only: bool
                """
                When address-only is configured, the source IP of the packet is set to the interface
                IP but the
                packet may exit the device via a different interface.
                When set to `false`, the probe uses the
                interface to exit the device.

                Default value: `True`
                """
                url: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        ip: str | None | UndefinedType = Undefined,
                        local_interfaces: str | None | UndefinedType = Undefined,
                        address_only: bool | UndefinedType = Undefined,
                        url: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HostsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Host name.
                            description: description
                            ip: ip
                            local_interfaces: local_interfaces
                            address_only:
                               When address-only is configured, the source IP of the packet is set to the interface
                               IP but the
                               packet may exit the device via a different interface.
                               When set to `false`, the probe uses the
                               interface to exit the device.
                            url: url
                            _custom_data: _custom_data

                        """

            class Hosts(AvdIndexedList[str, HostsItem]):
                """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "description": {"type": str},
                "interface_sets": {"type": InterfaceSets},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "hosts": {"type": Hosts},
                "_custom_data": {"type": dict},
            }
            name: str
            """VRF Name."""
            description: str | None
            interface_sets: InterfaceSets
            """Subclass of AvdList with `InterfaceSetsItem` items."""
            local_interfaces: str | None
            address_only: bool
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.

            Default value: `True`
            """
            hosts: Hosts
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    interface_sets: InterfaceSets | UndefinedType = Undefined,
                    local_interfaces: str | None | UndefinedType = Undefined,
                    address_only: bool | UndefinedType = Undefined,
                    hosts: Hosts | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        description: description
                        interface_sets: Subclass of AvdList with `InterfaceSetsItem` items.
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "shutdown": {"type": bool},
            "interval": {"type": int},
            "interface_sets": {"type": InterfaceSets},
            "local_interfaces": {"type": str},
            "address_only": {"type": bool, "default": True},
            "hosts": {"type": Hosts},
            "vrfs": {"type": Vrfs},
            "_custom_data": {"type": dict},
        }
        shutdown: bool | None
        interval: int | None
        interface_sets: InterfaceSets
        """Subclass of AvdList with `InterfaceSetsItem` items."""
        local_interfaces: str | None
        address_only: bool
        """
        When address-only is configured, the source IP of the packet is set to the interface
        IP but the
        packet may exit the device via a different interface.
        When set to `false`, the probe uses the
        interface to exit the device.

        Default value: `True`
        """
        hosts: Hosts
        """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`)."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                shutdown: bool | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                interface_sets: InterfaceSets | UndefinedType = Undefined,
                local_interfaces: str | None | UndefinedType = Undefined,
                address_only: bool | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorConnectivity.


                Subclass of AvdModel.

                Args:
                    shutdown: shutdown
                    interval: interval
                    interface_sets: Subclass of AvdList with `InterfaceSetsItem` items.
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `name` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class MonitorLayer1(AvdModel):
        """Subclass of AvdModel."""

        class LoggingTransceiver(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"dom": {"type": bool}, "communication": {"type": bool}, "enabled": {"type": bool}, "_custom_data": {"type": dict}}
            dom: bool | None
            """Enable transceiver Digital Optical Monitoring (DOM) logging."""
            communication: bool | None
            """Enable transceiver SMBus fail and reset logging."""
            enabled: bool | None
            """
            Some platforms support only the `logging transceiver` command. `enabled` key configures this
            command.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    dom: bool | None | UndefinedType = Undefined,
                    communication: bool | None | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LoggingTransceiver.


                    Subclass of AvdModel.

                    Args:
                        dom: Enable transceiver Digital Optical Monitoring (DOM) logging.
                        communication: Enable transceiver SMBus fail and reset logging.
                        enabled:
                           Some platforms support only the `logging transceiver` command. `enabled` key configures this
                           command.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "logging_mac_fault": {"type": bool},
            "logging_transceiver": {"type": LoggingTransceiver},
            "_custom_data": {"type": dict},
        }
        enabled: bool
        """Enable monitor layer1."""
        logging_mac_fault: bool | None
        """Enable MAC fault logging."""
        logging_transceiver: LoggingTransceiver
        """
        Configure transceiver monitoring logging.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                logging_mac_fault: bool | None | UndefinedType = Undefined,
                logging_transceiver: LoggingTransceiver | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorLayer1.


                Subclass of AvdModel.

                Args:
                    enabled: Enable monitor layer1.
                    logging_mac_fault: Enable MAC fault logging.
                    logging_transceiver:
                       Configure transceiver monitoring logging.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MonitorServerRadius(AvdModel):
        """Subclass of AvdModel."""

        class Probe(AvdModel):
            """Subclass of AvdModel."""

            class AccessRequest(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "username": {"type": str},
                    "password": {"type": str},
                    "password_type": {"type": str, "default": "7"},
                    "_custom_data": {"type": dict},
                }
                username: str | None
                password: str | None
                """Encrypted password using the `password_type`."""
                password_type: Literal["0", "7", "8a"]
                """Default value: `"7"`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        username: str | None | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessRequest.


                        Subclass of AvdModel.

                        Args:
                            username: username
                            password: Encrypted password using the `password_type`.
                            password_type: password_type
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "interval": {"type": int},
                "threshold_failure": {"type": int},
                "method": {"type": str},
                "access_request": {"type": AccessRequest},
                "_custom_data": {"type": dict},
            }
            interval: int | None
            """Server probe interval in seconds."""
            threshold_failure: int | None
            """Number of consecutive failed probes before a server is marked as dead."""
            method: Literal["status-server", "access-request"] | None
            """Method used to probe the server. `status-server` is the EOS default method."""
            access_request: AccessRequest
            """
            This can only be set when `method` is `access_request`.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    threshold_failure: int | None | UndefinedType = Undefined,
                    method: Literal["status-server", "access-request"] | None | UndefinedType = Undefined,
                    access_request: AccessRequest | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Probe.


                    Subclass of AvdModel.

                    Args:
                        interval: Server probe interval in seconds.
                        threshold_failure: Number of consecutive failed probes before a server is marked as dead.
                        method: Method used to probe the server. `status-server` is the EOS default method.
                        access_request:
                           This can only be set when `method` is `access_request`.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"service_dot1x": {"type": bool}, "probe": {"type": Probe}, "_custom_data": {"type": dict}}
        service_dot1x: bool | None
        """Monitor servers used for 802.1X authentication."""
        probe: Probe
        """
        Settings for probe sent to the server.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                service_dot1x: bool | None | UndefinedType = Undefined,
                probe: Probe | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorServerRadius.


                Subclass of AvdModel.

                Args:
                    service_dot1x: Monitor servers used for 802.1X authentication.
                    probe:
                       Settings for probe sent to the server.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MonitorSessionDefaultEncapsulationGre(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"payload": {"type": str}, "_custom_data": {"type": dict}}
        payload: Literal["full-packet", "inner-packet"] | None
        """Mirroring GRE payload type configuration commands."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                payload: Literal["full-packet", "inner-packet"] | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorSessionDefaultEncapsulationGre.


                Subclass of AvdModel.

                Args:
                    payload: Mirroring GRE payload type configuration commands.
                    _custom_data: _custom_data

                """

    class MonitorSessionsItem(AvdModel):
        """Subclass of AvdModel."""

        class SourcesItem(AvdModel):
            """Subclass of AvdModel."""

            class AccessGroup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"type": {"type": str}, "name": {"type": str}, "priority": {"type": int}, "_custom_data": {"type": dict}}
                type: Literal["ip", "ipv6", "mac"] | None
                name: str | None
                """ACL Name."""
                priority: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        type: Literal["ip", "ipv6", "mac"] | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.


                        Subclass of AvdModel.

                        Args:
                            type: type
                            name: ACL Name.
                            priority: priority
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}, "access_group": {"type": AccessGroup}, "_custom_data": {"type": dict}}
            name: str | None
            """Interface name, range or comma separated list."""
            direction: Literal["rx", "tx", "both"] | None
            access_group: AccessGroup
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    direction: Literal["rx", "tx", "both"] | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourcesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name, range or comma separated list.
                        direction: direction
                        access_group: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Sources(AvdList[SourcesItem]):
            """Subclass of AvdList with `SourcesItem` items."""

        Sources._item_type = SourcesItem

        class Destinations(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Destinations._item_type = str

        class AccessGroup(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "name": {"type": str}, "_custom_data": {"type": dict}}
            type: Literal["ip", "ipv6", "mac"] | None
            name: str | None
            """ACL Name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    type: Literal["ip", "ipv6", "mac"] | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessGroup.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        name: ACL Name.
                        _custom_data: _custom_data

                    """

        class Truncate(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool | None
            size: int | None
            """Size in bytes."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    size: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Truncate.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        size: Size in bytes.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "sources": {"type": Sources},
            "destinations": {"type": Destinations},
            "encapsulation_gre_metadata_tx": {"type": bool},
            "header_remove_size": {"type": int},
            "access_group": {"type": AccessGroup},
            "rate_limit_per_ingress_chip": {"type": str},
            "rate_limit_per_egress_chip": {"type": str},
            "sample": {"type": int},
            "truncate": {"type": Truncate},
            "_custom_data": {"type": dict},
        }
        name: str
        """Session Name."""
        sources: Sources
        """Subclass of AvdList with `SourcesItem` items."""
        destinations: Destinations
        """Subclass of AvdList with `str` items."""
        encapsulation_gre_metadata_tx: bool | None
        header_remove_size: int | None
        """Number of bytes to remove from header."""
        access_group: AccessGroup
        """Subclass of AvdModel."""
        rate_limit_per_ingress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        rate_limit_per_egress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        sample: int | None
        truncate: Truncate
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sources: Sources | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
                header_remove_size: int | None | UndefinedType = Undefined,
                access_group: AccessGroup | UndefinedType = Undefined,
                rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
                rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
                sample: int | None | UndefinedType = Undefined,
                truncate: Truncate | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorSessionsItem.


                Subclass of AvdModel.

                Args:
                    name: Session Name.
                    sources: Subclass of AvdList with `SourcesItem` items.
                    destinations: Subclass of AvdList with `str` items.
                    encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                    header_remove_size: Number of bytes to remove from header.
                    access_group: Subclass of AvdModel.
                    rate_limit_per_ingress_chip:
                       Ratelimit and unit as string.
                       Examples:  # fmt: skip
                         "100000 bps"
                         "100 kbps"
                         "10 mbps"
                    rate_limit_per_egress_chip:
                       Ratelimit and unit as string.
                       Examples:  # fmt: skip
                         "100000 bps"
                         "100 kbps"
                         "10 mbps"
                    sample: sample
                    truncate: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class MonitorSessions(AvdList[MonitorSessionsItem]):
        """Subclass of AvdList with `MonitorSessionsItem` items."""

    MonitorSessions._item_type = MonitorSessionsItem

    class MonitorTelemetryInflux(AvdModel):
        """Subclass of AvdModel."""

        class DestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "database": {"type": str},
                "data_retention_policy": {"type": str},
                "url": {"type": str},
                "username": {"type": str},
                "password": {"type": str},
                "password_type": {"type": str, "default": "7"},
                "_custom_data": {"type": dict},
            }
            name: str
            """InfluxDB connection name."""
            database: str | None
            """Set name of the database."""
            data_retention_policy: str | None
            url: str | None
            """It only accepts http(s), udp and unix domain destination URL."""
            username: str | None
            password: str | None
            password_type: Literal["0", "7", "8a"]
            """Default value: `"7"`"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    database: str | None | UndefinedType = Undefined,
                    data_retention_policy: str | None | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    username: str | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    DestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        name: InfluxDB connection name.
                        database: Set name of the database.
                        data_retention_policy: data_retention_policy
                        url: It only accepts http(s), udp and unix domain destination URL.
                        username: username
                        password: password
                        password_type: password_type
                        _custom_data: _custom_data

                    """

        class Destinations(AvdIndexedList[str, DestinationsItem]):
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Destinations._item_type = DestinationsItem

        class SourceSocketsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "connection_limit": {"type": int}, "url": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Label of the socket connection."""
            connection_limit: int | None
            url: str | None
            """It only accepts http(s), udp and unix domain socket URL."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    connection_limit: int | None | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourceSocketsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Label of the socket connection.
                        connection_limit: connection_limit
                        url: It only accepts http(s), udp and unix domain socket URL.
                        _custom_data: _custom_data

                    """

        class SourceSockets(AvdIndexedList[str, SourceSocketsItem]):
            """Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SourceSockets._item_type = SourceSocketsItem

        class TagsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "value": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Key of the global tag pair."""
            value: str
            """Value of the global tag pair."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    value: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TagsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Key of the global tag pair.
                        value: Value of the global tag pair.
                        _custom_data: _custom_data

                    """

        class Tags(AvdIndexedList[str, TagsItem]):
            """Subclass of AvdIndexedList with `TagsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Tags._item_type = TagsItem

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destinations": {"type": Destinations},
            "source_group_standard_disabled": {"type": bool},
            "source_sockets": {"type": SourceSockets},
            "tags": {"type": Tags},
            "_custom_data": {"type": dict},
        }
        vrf: str | None
        destinations: Destinations
        """
        Configure telemetry output destinations.

        Subclass of AvdIndexedList with `DestinationsItem` items.
        Primary key is `name` (`str`).
        """
        source_group_standard_disabled: bool | None
        """Disable standard set of telemetry."""
        source_sockets: SourceSockets
        """Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`)."""
        tags: Tags
        """
        Extra tags added to the telemetry output.

        Subclass of AvdIndexedList with `TagsItem` items. Primary
        key is `name` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                source_group_standard_disabled: bool | None | UndefinedType = Undefined,
                source_sockets: SourceSockets | UndefinedType = Undefined,
                tags: Tags | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorTelemetryInflux.


                Subclass of AvdModel.

                Args:
                    vrf: vrf
                    destinations:
                       Configure telemetry output destinations.

                       Subclass of AvdIndexedList with `DestinationsItem` items.
                       Primary key is `name` (`str`).
                    source_group_standard_disabled: Disable standard set of telemetry.
                    source_sockets: Subclass of AvdIndexedList with `SourceSocketsItem` items. Primary key is `name` (`str`).
                    tags:
                       Extra tags added to the telemetry output.

                       Subclass of AvdIndexedList with `TagsItem` items. Primary
                       key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class MonitorTelemetryPostcardPolicy(AvdModel):
        """Subclass of AvdModel."""

        class Ingress(AvdModel):
            """Subclass of AvdModel."""

            class Collection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}, "version": {"type": int}, "_custom_data": {"type": dict}}
                source: str | None
                """Source IP address of GRE tunnel."""
                destination: str | None
                """Destination IP address of GRE tunnel."""
                version: Literal[1, 2] | None
                """Postcard version."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source: str | None | UndefinedType = Undefined,
                        destination: str | None | UndefinedType = Undefined,
                        version: Literal[1, 2] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Collection.


                        Subclass of AvdModel.

                        Args:
                            source: Source IP address of GRE tunnel.
                            destination: Destination IP address of GRE tunnel.
                            version: Postcard version.
                            _custom_data: _custom_data

                        """

            class Sample(AvdModel):
                """Subclass of AvdModel."""

                class TcpUdpChecksum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"value": {"type": int}, "mask": {"type": str}, "_custom_data": {"type": dict}}
                    value: int | None
                    """TCP/UDP checksum or IP ID value."""
                    mask: str | None
                    """16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            value: int | None | UndefinedType = Undefined,
                            mask: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TcpUdpChecksum.


                            Subclass of AvdModel.

                            Args:
                                value: TCP/UDP checksum or IP ID value.
                                mask: 16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"rate": {"type": int}, "tcp_udp_checksum": {"type": TcpUdpChecksum}, "_custom_data": {"type": dict}}
                rate: Literal[16384, 32768, 65536] | None
                """Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined."""
                tcp_udp_checksum: TcpUdpChecksum
                """
                TCP/UDP parameters.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rate: Literal[16384, 32768, 65536] | None | UndefinedType = Undefined,
                        tcp_udp_checksum: TcpUdpChecksum | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Sample.


                        Subclass of AvdModel.

                        Args:
                            rate: Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined.
                            tcp_udp_checksum:
                               TCP/UDP parameters.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"collection": {"type": Collection}, "sample": {"type": Sample}, "_custom_data": {"type": dict}}
            collection: Collection
            """
            Collector configuration.

            Subclass of AvdModel.
            """
            sample: Sample
            """
            Sampling parameters.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    collection: Collection | UndefinedType = Undefined,
                    sample: Sample | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ingress.


                    Subclass of AvdModel.

                    Args:
                        collection:
                           Collector configuration.

                           Subclass of AvdModel.
                        sample:
                           Sampling parameters.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class MarkerVxlan(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "header_word_zero_bit": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool | None
            """Enable vxlan marking using default bit 0."""
            header_word_zero_bit: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    header_word_zero_bit: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MarkerVxlan.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable vxlan marking using default bit 0.
                        header_word_zero_bit: header_word_zero_bit
                        _custom_data: _custom_data

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "ingress_sample_policy": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Profile name."""
            ingress_sample_policy: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ingress_sample_policy: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Profile name.
                        ingress_sample_policy: ingress_sample_policy
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class SamplePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class MatchRulesItem(AvdModel):
                """Subclass of AvdModel."""

                class ProtocolsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class SourcePorts(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    SourcePorts._item_type = str

                    class DestinationPorts(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    DestinationPorts._item_type = str

                    _fields: ClassVar[dict] = {
                        "protocol": {"type": str},
                        "source_ports": {"type": SourcePorts},
                        "destination_ports": {"type": DestinationPorts},
                        "_custom_data": {"type": dict},
                    }
                    protocol: Literal["tcp", "udp"]
                    source_ports: SourcePorts
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      ["12", "14-20"]
                    ["www"]

                    Subclass of AvdList with `str` items.
                    """
                    destination_ports: DestinationPorts
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      ["12", "14-20",
                    "80"]
                      ["https"]

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            protocol: Literal["tcp", "udp"] | UndefinedType = Undefined,
                            source_ports: SourcePorts | UndefinedType = Undefined,
                            destination_ports: DestinationPorts | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProtocolsItem.


                            Subclass of AvdModel.

                            Args:
                                protocol: protocol
                                source_ports:
                                   A list of port numbers or port range or port name. Combination of port numbers or range and port
                                   name is not supported on EOS. The port numbers should be in range of 0-65535.
                                   e.g.
                                     ["12", "14-20"]
                                   ["www"]

                                   Subclass of AvdList with `str` items.
                                destination_ports:
                                   A list of port numbers or port range or port name. Combination of port numbers or range and port
                                   name is not supported on EOS. The port numbers should be in range of 0-65535.
                                   e.g.
                                     ["12", "14-20",
                                   "80"]
                                     ["https"]

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Protocols(AvdIndexedList[str, ProtocolsItem]):
                    """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "destination_prefix": {"type": str},
                    "source_prefix": {"type": str},
                    "protocols": {"type": Protocols},
                    "_custom_data": {"type": dict},
                }
                name: str
                type: Literal["ipv4", "ipv6"]
                """IP address version."""
                destination_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                source_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                protocols: Protocols
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                        destination_prefix: str | None | UndefinedType = Undefined,
                        source_prefix: str | None | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchRulesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            type: IP address version.
                            destination_prefix:
                               IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                               eg. 10.3.3.0/24
                            source_prefix:
                               IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                               eg. 10.3.3.0/24
                            protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).
                            _custom_data: _custom_data

                        """

            class MatchRules(AvdIndexedList[str, MatchRulesItem]):
                """Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            MatchRules._item_type = MatchRulesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "match_rules": {"type": MatchRules}, "_custom_data": {"type": dict}}
            name: str
            match_rules: MatchRules
            """Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    match_rules: MatchRules | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SamplePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        match_rules: Subclass of AvdIndexedList with `MatchRulesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class SamplePolicies(AvdIndexedList[str, SamplePoliciesItem]):
            """Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SamplePolicies._item_type = SamplePoliciesItem

        _fields: ClassVar[dict] = {
            "disabled": {"type": bool, "default": True},
            "ingress": {"type": Ingress},
            "marker_vxlan": {"type": MarkerVxlan},
            "profiles": {"type": Profiles},
            "sample_policies": {"type": SamplePolicies},
            "_custom_data": {"type": dict},
        }
        disabled: bool
        """
        Enable or disable the postcard telemetry feature.

        Default value: `True`
        """
        ingress: Ingress
        """Subclass of AvdModel."""
        marker_vxlan: MarkerVxlan
        """Subclass of AvdModel."""
        profiles: Profiles
        """
        Postcard telemetry profiles.

        Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
        `name` (`str`).
        """
        sample_policies: SamplePolicies
        """Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                disabled: bool | UndefinedType = Undefined,
                ingress: Ingress | UndefinedType = Undefined,
                marker_vxlan: MarkerVxlan | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                sample_policies: SamplePolicies | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorTelemetryPostcardPolicy.


                Subclass of AvdModel.

                Args:
                    disabled: Enable or disable the postcard telemetry feature.
                    ingress: Subclass of AvdModel.
                    marker_vxlan: Subclass of AvdModel.
                    profiles:
                       Postcard telemetry profiles.

                       Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is
                       `name` (`str`).
                    sample_policies: Subclass of AvdIndexedList with `SamplePoliciesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Mpls(AvdModel):
        """Subclass of AvdModel."""

        class Ldp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "interface_disabled_default": {"type": bool},
                "router_id": {"type": str},
                "shutdown": {"type": bool},
                "transport_address_interface": {"type": str},
                "_custom_data": {"type": dict},
            }
            interface_disabled_default: bool | None
            router_id: str | None
            shutdown: bool | None
            transport_address_interface: str | None
            """Interface Name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interface_disabled_default: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    transport_address_interface: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ldp.


                    Subclass of AvdModel.

                    Args:
                        interface_disabled_default: interface_disabled_default
                        router_id: router_id
                        shutdown: shutdown
                        transport_address_interface: Interface Name.
                        _custom_data: _custom_data

                    """

        class Icmp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "fragmentation_needed_tunneling": {"type": bool},
                "ttl_exceeded_tunneling": {"type": bool},
                "_custom_data": {"type": dict},
            }
            fragmentation_needed_tunneling: bool | None
            """Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big)."""
            ttl_exceeded_tunneling: bool | None
            """Enables the MPLS tunneling of TTL exceeded ICMP replies."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    fragmentation_needed_tunneling: bool | None | UndefinedType = Undefined,
                    ttl_exceeded_tunneling: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Icmp.


                    Subclass of AvdModel.

                    Args:
                        fragmentation_needed_tunneling: Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big).
                        ttl_exceeded_tunneling: Enables the MPLS tunneling of TTL exceeded ICMP replies.
                        _custom_data: _custom_data

                    """

        class Rsvp(AvdModel):
            """Subclass of AvdModel."""

            class Refresh(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "method": {"type": str}, "_custom_data": {"type": dict}}
                interval: int | None
                """Time between refreshes."""
                method: Literal["bundled", "explicit"] | None
                """
                Neighbor refresh mechanism.
                bundled: Refresh states using message identifier lists.
                explicit: Send
                each message individually.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | None | UndefinedType = Undefined,
                        method: Literal["bundled", "explicit"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Refresh.


                        Subclass of AvdModel.

                        Args:
                            interval: Time between refreshes.
                            method:
                               Neighbor refresh mechanism.
                               bundled: Refresh states using message identifier lists.
                               explicit: Send
                               each message individually.
                            _custom_data: _custom_data

                        """

            class Authentication(AvdModel):
                """Subclass of AvdModel."""

                class PasswordIndexesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "index": {"type": int},
                        "password_type": {"type": str, "default": "7"},
                        "password": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    index: int
                    """Password index."""
                    password_type: Literal["0", "7", "8a"]
                    """
                    Authentication password type.

                    Default value: `"7"`
                    """
                    password: str | None
                    """Password string."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            index: int | UndefinedType = Undefined,
                            password_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            password: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PasswordIndexesItem.


                            Subclass of AvdModel.

                            Args:
                                index: Password index.
                                password_type: Authentication password type.
                                password: Password string.
                                _custom_data: _custom_data

                            """

                class PasswordIndexes(AvdIndexedList[int, PasswordIndexesItem]):
                    """Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`)."""

                    _primary_key: ClassVar[str] = "index"

                PasswordIndexes._item_type = PasswordIndexesItem

                _fields: ClassVar[dict] = {
                    "password_indexes": {"type": PasswordIndexes},
                    "active_index": {"type": int},
                    "sequence_number_window": {"type": int},
                    "type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                password_indexes: PasswordIndexes
                """Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`)."""
                active_index: int | None
                """Use index as active password."""
                sequence_number_window: int | None
                """Size of reorder window for index in the sequence."""
                type: Literal["md5", "none"] | None
                """Authentication mechanism."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        password_indexes: PasswordIndexes | UndefinedType = Undefined,
                        active_index: int | None | UndefinedType = Undefined,
                        sequence_number_window: int | None | UndefinedType = Undefined,
                        type: Literal["md5", "none"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Authentication.


                        Subclass of AvdModel.

                        Args:
                            password_indexes: Subclass of AvdIndexedList with `PasswordIndexesItem` items. Primary key is `index` (`int`).
                            active_index: Use index as active password.
                            sequence_number_window: Size of reorder window for index in the sequence.
                            type: Authentication mechanism.
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class Authentication(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"index": {"type": int}, "type": {"type": str}, "_custom_data": {"type": dict}}
                    index: int | None
                    """Password index."""
                    type: Literal["md5", "none"] | None
                    """Authentication mechanism."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            index: int | None | UndefinedType = Undefined,
                            type: Literal["md5", "none"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Authentication.


                            Subclass of AvdModel.

                            Args:
                                index: Password index.
                                type: Authentication mechanism.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "ipv6_address": {"type": str},
                    "authentication": {"type": Authentication},
                    "_custom_data": {"type": dict},
                }
                ip_address: str | None
                """Neighbor's interface IPv4 address."""
                ipv6_address: str | None
                """Neighbor's interface IPv6 address."""
                authentication: Authentication
                """
                Cryptographic authentication.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | None | UndefinedType = Undefined,
                        ipv6_address: str | None | UndefinedType = Undefined,
                        authentication: Authentication | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: Neighbor's interface IPv4 address.
                            ipv6_address: Neighbor's interface IPv6 address.
                            authentication:
                               Cryptographic authentication.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdList[NeighborsItem]):
                """Subclass of AvdList with `NeighborsItem` items."""

            Neighbors._item_type = NeighborsItem

            class FastReroute(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "mode": {"type": str},
                    "reversion": {"type": str},
                    "bypass_tunnel_optimization_interval": {"type": int},
                    "_custom_data": {"type": dict},
                }
                mode: Literal["link-protection", "node-protection", "none"] | None
                """
                Fast reroute mode.
                link-protection: Protect against failure of the next link.
                node-protection:
                Protect against failure of the next node.
                none: Disable fast reroute.
                """
                reversion: Literal["global", "local"] | None
                """
                Reversion behavior.
                Global revertive repair.
                Local revertive repair.
                """
                bypass_tunnel_optimization_interval: int | None
                """
                Fast-reroute bypass configuration.
                Interval between each re-optimization attempt in seconds.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection", "none"] | None | UndefinedType = Undefined,
                        reversion: Literal["global", "local"] | None | UndefinedType = Undefined,
                        bypass_tunnel_optimization_interval: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastReroute.


                        Subclass of AvdModel.

                        Args:
                            mode:
                               Fast reroute mode.
                               link-protection: Protect against failure of the next link.
                               node-protection:
                               Protect against failure of the next node.
                               none: Disable fast reroute.
                            reversion:
                               Reversion behavior.
                               Global revertive repair.
                               Local revertive repair.
                            bypass_tunnel_optimization_interval:
                               Fast-reroute bypass configuration.
                               Interval between each re-optimization attempt in seconds.
                            _custom_data: _custom_data

                        """

            class Srlg(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "strict": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                """Select SRLG behavior."""
                strict: bool | None
                """Apply strict SRLG constraint."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        strict: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Srlg.


                        Subclass of AvdModel.

                        Args:
                            enabled: Select SRLG behavior.
                            strict: Apply strict SRLG constraint.
                            _custom_data: _custom_data

                        """

            class PreemptionMethod(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"preemption": {"type": str}, "timer": {"type": int}, "_custom_data": {"type": dict}}
                preemption: Literal["hard", "soft"] | None
                timer: int | None
                """Timer value in units of seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        preemption: Literal["hard", "soft"] | None | UndefinedType = Undefined,
                        timer: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PreemptionMethod.


                        Subclass of AvdModel.

                        Args:
                            preemption: preemption
                            timer: Timer value in units of seconds.
                            _custom_data: _custom_data

                        """

            class GracefulRestart(AvdModel):
                """Subclass of AvdModel."""

                class RoleHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "timer_recovery": {"type": int},
                        "timer_restart": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    timer_recovery: int | None
                    """Maximum recovery timer value in seconds."""
                    timer_restart: int | None
                    """Maximum restart timer value in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timer_recovery: int | None | UndefinedType = Undefined,
                            timer_restart: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RoleHelper.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timer_recovery: Maximum recovery timer value in seconds.
                                timer_restart: Maximum restart timer value in seconds.
                                _custom_data: _custom_data

                            """

                class RoleSpeaker(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "timer_recovery": {"type": int},
                        "timer_restart": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    timer_recovery: int | None
                    """Maximum recovery timer value in seconds."""
                    timer_restart: int | None
                    """Maximum restart timer value in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timer_recovery: int | None | UndefinedType = Undefined,
                            timer_restart: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RoleSpeaker.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timer_recovery: Maximum recovery timer value in seconds.
                                timer_restart: Maximum restart timer value in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"role_helper": {"type": RoleHelper}, "role_speaker": {"type": RoleSpeaker}, "_custom_data": {"type": dict}}
                role_helper: RoleHelper
                """Subclass of AvdModel."""
                role_speaker: RoleSpeaker
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        role_helper: RoleHelper | UndefinedType = Undefined,
                        role_speaker: RoleSpeaker | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GracefulRestart.


                        Subclass of AvdModel.

                        Args:
                            role_helper: Subclass of AvdModel.
                            role_speaker: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Hello(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                """Time between hello messages in seconds."""
                multiplier: int | None
                """Number of missed hellos after which the neighbor is expired."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | None | UndefinedType = Undefined,
                        multiplier: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Hello.


                        Subclass of AvdModel.

                        Args:
                            interval: Time between hello messages in seconds.
                            multiplier: Number of missed hellos after which the neighbor is expired.
                            _custom_data: _custom_data

                        """

            class HitlessRestart(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timer_recovery": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool | None
                timer_recovery: int | None
                """
                Time stale states will be preserved after restart.
                Value in seconds.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        timer_recovery: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        HitlessRestart.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            timer_recovery:
                               Time stale states will be preserved after restart.
                               Value in seconds.
                            _custom_data: _custom_data

                        """

            class P2mp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, enabled: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        P2mp.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "refresh": {"type": Refresh},
                "authentication": {"type": Authentication},
                "neighbors": {"type": Neighbors},
                "ip_access_group": {"type": str},
                "ipv6_access_group": {"type": str},
                "fast_reroute": {"type": FastReroute},
                "srlg": {"type": Srlg},
                "label_local_termination": {"type": str},
                "preemption_method": {"type": PreemptionMethod},
                "mtu_signaling": {"type": bool},
                "graceful_restart": {"type": GracefulRestart},
                "hello": {"type": Hello},
                "hitless_restart": {"type": HitlessRestart},
                "p2mp": {"type": P2mp},
                "shutdown": {"type": bool},
                "_custom_data": {"type": dict},
            }
            refresh: Refresh
            """Subclass of AvdModel."""
            authentication: Authentication
            """
            Cryptographic authentication.

            Subclass of AvdModel.
            """
            neighbors: Neighbors
            """Subclass of AvdList with `NeighborsItem` items."""
            ip_access_group: str | None
            """IPv4 Access list name."""
            ipv6_access_group: str | None
            """IPv6 access list name."""
            fast_reroute: FastReroute
            """Subclass of AvdModel."""
            srlg: Srlg
            """Subclass of AvdModel."""
            label_local_termination: Literal["implicit-null", "explicit-null"] | None
            """Local termination label to be advertised."""
            preemption_method: PreemptionMethod
            """Subclass of AvdModel."""
            mtu_signaling: bool | None
            """Enable MTU signaling."""
            graceful_restart: GracefulRestart
            """
            RSVP graceful restart.

            Subclass of AvdModel.
            """
            hello: Hello
            """Subclass of AvdModel."""
            hitless_restart: HitlessRestart
            """
            RSVP hitless restart.

            Subclass of AvdModel.
            """
            p2mp: P2mp
            """Subclass of AvdModel."""
            shutdown: bool | None
            """Make `shutdown` key false for `no shutdown` cli."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    refresh: Refresh | UndefinedType = Undefined,
                    authentication: Authentication | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    ip_access_group: str | None | UndefinedType = Undefined,
                    ipv6_access_group: str | None | UndefinedType = Undefined,
                    fast_reroute: FastReroute | UndefinedType = Undefined,
                    srlg: Srlg | UndefinedType = Undefined,
                    label_local_termination: Literal["implicit-null", "explicit-null"] | None | UndefinedType = Undefined,
                    preemption_method: PreemptionMethod | UndefinedType = Undefined,
                    mtu_signaling: bool | None | UndefinedType = Undefined,
                    graceful_restart: GracefulRestart | UndefinedType = Undefined,
                    hello: Hello | UndefinedType = Undefined,
                    hitless_restart: HitlessRestart | UndefinedType = Undefined,
                    p2mp: P2mp | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Rsvp.


                    Subclass of AvdModel.

                    Args:
                        refresh: Subclass of AvdModel.
                        authentication:
                           Cryptographic authentication.

                           Subclass of AvdModel.
                        neighbors: Subclass of AvdList with `NeighborsItem` items.
                        ip_access_group: IPv4 Access list name.
                        ipv6_access_group: IPv6 access list name.
                        fast_reroute: Subclass of AvdModel.
                        srlg: Subclass of AvdModel.
                        label_local_termination: Local termination label to be advertised.
                        preemption_method: Subclass of AvdModel.
                        mtu_signaling: Enable MTU signaling.
                        graceful_restart:
                           RSVP graceful restart.

                           Subclass of AvdModel.
                        hello: Subclass of AvdModel.
                        hitless_restart:
                           RSVP hitless restart.

                           Subclass of AvdModel.
                        p2mp: Subclass of AvdModel.
                        shutdown: Make `shutdown` key false for `no shutdown` cli.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}, "icmp": {"type": Icmp}, "rsvp": {"type": Rsvp}, "_custom_data": {"type": dict}}
        ip: bool | None
        ldp: Ldp
        """Subclass of AvdModel."""
        icmp: Icmp
        """
        Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

        Subclass
        of AvdModel.
        """
        rsvp: Rsvp
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ip: bool | None | UndefinedType = Undefined,
                ldp: Ldp | UndefinedType = Undefined,
                icmp: Icmp | UndefinedType = Undefined,
                rsvp: Rsvp | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Mpls.


                Subclass of AvdModel.

                Args:
                    ip: ip
                    ldp: Subclass of AvdModel.
                    icmp:
                       Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

                       Subclass
                       of AvdModel.
                    rsvp: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Ntp(AvdModel):
        """Subclass of AvdModel."""

        class LocalInterface(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            """Source interface."""
            vrf: str | None
            """VRF name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalInterface.


                    Subclass of AvdModel.

                    Args:
                        name: Source interface.
                        vrf: VRF name.
                        _custom_data: _custom_data

                    """

        class ServersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "burst": {"type": bool},
                "iburst": {"type": bool},
                "key": {"type": int},
                "local_interface": {"type": str},
                "maxpoll": {"type": int},
                "minpoll": {"type": int},
                "preferred": {"type": bool},
                "version": {"type": int},
                "vrf": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str | None
            """IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org."""
            burst: bool | None
            iburst: bool | None
            key: int | None
            local_interface: str | None
            """Source interface."""
            maxpoll: int | None
            """Value of maxpoll between 3 - 17 (Logarithmic)."""
            minpoll: int | None
            """Value of minpoll between 3 - 17 (Logarithmic)."""
            preferred: bool | None
            version: int | None
            vrf: str | None
            """VRF name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    burst: bool | None | UndefinedType = Undefined,
                    iburst: bool | None | UndefinedType = Undefined,
                    key: int | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    maxpoll: int | None | UndefinedType = Undefined,
                    minpoll: int | None | UndefinedType = Undefined,
                    preferred: bool | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServersItem.


                    Subclass of AvdModel.

                    Args:
                        name: IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org.
                        burst: burst
                        iburst: iburst
                        key: key
                        local_interface: Source interface.
                        maxpoll: Value of maxpoll between 3 - 17 (Logarithmic).
                        minpoll: Value of minpoll between 3 - 17 (Logarithmic).
                        preferred: preferred
                        version: version
                        vrf: VRF name.
                        _custom_data: _custom_data

                    """

        class Servers(AvdList[ServersItem]):
            """Subclass of AvdList with `ServersItem` items."""

        Servers._item_type = ServersItem

        class AuthenticationKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "hash_algorithm": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str},
                "_custom_data": {"type": dict},
            }
            id: int
            """Key identifier."""
            hash_algorithm: Literal["md5", "sha1"] | None
            key: str | None
            """Obfuscated key."""
            key_type: Literal["0", "7", "8a"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AuthenticationKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: Key identifier.
                        hash_algorithm: hash_algorithm
                        key: Obfuscated key.
                        key_type: key_type
                        _custom_data: _custom_data

                    """

        class AuthenticationKeys(AvdIndexedList[int, AuthenticationKeysItem]):
            """Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        AuthenticationKeys._item_type = AuthenticationKeysItem

        _fields: ClassVar[dict] = {
            "local_interface": {"type": LocalInterface},
            "servers": {"type": Servers},
            "authenticate": {"type": bool},
            "authenticate_servers_only": {"type": bool},
            "authentication_keys": {"type": AuthenticationKeys},
            "trusted_keys": {"type": str},
            "_custom_data": {"type": dict},
        }
        local_interface: LocalInterface
        """Subclass of AvdModel."""
        servers: Servers
        """Subclass of AvdList with `ServersItem` items."""
        authenticate: bool | None
        authenticate_servers_only: bool | None
        authentication_keys: AuthenticationKeys
        """Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`)."""
        trusted_keys: str | None
        """List of trusted-keys as string ex. 10-12,15."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                local_interface: LocalInterface | UndefinedType = Undefined,
                servers: Servers | UndefinedType = Undefined,
                authenticate: bool | None | UndefinedType = Undefined,
                authenticate_servers_only: bool | None | UndefinedType = Undefined,
                authentication_keys: AuthenticationKeys | UndefinedType = Undefined,
                trusted_keys: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ntp.


                Subclass of AvdModel.

                Args:
                    local_interface: Subclass of AvdModel.
                    servers: Subclass of AvdList with `ServersItem` items.
                    authenticate: authenticate
                    authenticate_servers_only: authenticate_servers_only
                    authentication_keys: Subclass of AvdIndexedList with `AuthenticationKeysItem` items. Primary key is `id` (`int`).
                    trusted_keys: List of trusted-keys as string ex. 10-12,15.
                    _custom_data: _custom_data

                """

    class PatchPanel(AvdModel):
        """Subclass of AvdModel."""

        class Connector(AvdModel):
            """Subclass of AvdModel."""

            class Interface(AvdModel):
                """Subclass of AvdModel."""

                class Patch(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"bgp_vpws_remote_failure_errdisable": {"type": bool}, "_custom_data": {"type": dict}}
                    bgp_vpws_remote_failure_errdisable: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            bgp_vpws_remote_failure_errdisable: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Patch.


                            Subclass of AvdModel.

                            Args:
                                bgp_vpws_remote_failure_errdisable: bgp_vpws_remote_failure_errdisable
                                _custom_data: _custom_data

                            """

                class Recovery(AvdModel):
                    """Subclass of AvdModel."""

                    class ReviewDelay(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"min": {"type": int}, "max": {"type": int}, "_custom_data": {"type": dict}}
                        min: int
                        """Minimum delay."""
                        max: int
                        """Maximum delay."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                ReviewDelay.


                                Subclass of AvdModel.

                                Args:
                                    min: Minimum delay.
                                    max: Maximum delay.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"review_delay": {"type": ReviewDelay}, "_custom_data": {"type": dict}}
                    review_delay: ReviewDelay
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, review_delay: ReviewDelay | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Recovery.


                            Subclass of AvdModel.

                            Args:
                                review_delay: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"patch": {"type": Patch}, "recovery": {"type": Recovery}, "_custom_data": {"type": dict}}
                patch: Patch
                """Subclass of AvdModel."""
                recovery: Recovery
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        patch: Patch | UndefinedType = Undefined,
                        recovery: Recovery | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Interface.


                        Subclass of AvdModel.

                        Args:
                            patch: Subclass of AvdModel.
                            recovery: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"interface": {"type": Interface}, "_custom_data": {"type": dict}}
            interface: Interface
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, interface: Interface | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Connector.


                    Subclass of AvdModel.

                    Args:
                        interface: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class PatchesItem(AvdModel):
            """Subclass of AvdModel."""

            class ConnectorsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "type": {"type": str}, "endpoint": {"type": str}, "_custom_data": {"type": dict}}
                id: str
                type: Literal["interface", "pseudowire"]
                endpoint: str
                """
                String with relevant endpoint depending on type.
                Examples:
                - "Ethernet1"
                - "Ethernet1 dot1q vlan
                123"
                - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                - "ldp LDP_PW_1"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        type: Literal["interface", "pseudowire"] | UndefinedType = Undefined,
                        endpoint: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ConnectorsItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            type: type
                            endpoint:
                               String with relevant endpoint depending on type.
                               Examples:  # fmt: skip
                               - "Ethernet1"
                               - "Ethernet1 dot1q vlan
                               123"
                               - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                               - "ldp LDP_PW_1"
                            _custom_data: _custom_data

                        """

            class Connectors(AvdIndexedList[str, ConnectorsItem]):
                """Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            Connectors._item_type = ConnectorsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool}, "connectors": {"type": Connectors}, "_custom_data": {"type": dict}}
            name: str
            enabled: bool | None
            connectors: Connectors
            """
            Must have exactly two connectors to a patch of which at least one must be of type "interface".
            Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    connectors: Connectors | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PatchesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        enabled: enabled
                        connectors:
                           Must have exactly two connectors to a patch of which at least one must be of type "interface".
                           Subclass of AvdIndexedList with `ConnectorsItem` items. Primary key is `id` (`str`).
                        _custom_data: _custom_data

                    """

        class Patches(AvdIndexedList[str, PatchesItem]):
            """Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Patches._item_type = PatchesItem

        _fields: ClassVar[dict] = {"connector": {"type": Connector}, "patches": {"type": Patches}, "_custom_data": {"type": dict}}
        connector: Connector
        """Subclass of AvdModel."""
        patches: Patches
        """Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                connector: Connector | UndefinedType = Undefined,
                patches: Patches | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PatchPanel.


                Subclass of AvdModel.

                Args:
                    connector: Subclass of AvdModel.
                    patches: Subclass of AvdIndexedList with `PatchesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class PeerFiltersItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "match": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            match: str
            """
            Match as string.
            Example: "as-range 1-100 result accept"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    match: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        match:
                           Match as string.
                           Example: "as-range 1-100 result accept"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
        name: str
        """Peer-filter Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PeerFiltersItem.


                Subclass of AvdModel.

                Args:
                    name: Peer-filter Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class PeerFilters(AvdIndexedList[str, PeerFiltersItem]):
        """Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PeerFilters._item_type = PeerFiltersItem

    class Platform(AvdModel):
        """Subclass of AvdModel."""

        class Trident(AvdModel):
            """Subclass of AvdModel."""

            class L3(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"routing_mac_address_per_vlan": {"type": bool}, "_custom_data": {"type": dict}}
                routing_mac_address_per_vlan: bool | None
                """Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, routing_mac_address_per_vlan: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        L3.


                        Subclass of AvdModel.

                        Args:
                            routing_mac_address_per_vlan: Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing.
                            _custom_data: _custom_data

                        """

            class Mmu(AvdModel):
                """Subclass of AvdModel."""

                class QueueProfilesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class MulticastQueuesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Drop(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"precedence": {"type": int}, "threshold": {"type": str}, "_custom_data": {"type": dict}}
                            precedence: Literal[1, 2]
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    precedence: Literal[1, 2] | UndefinedType = Undefined,
                                    threshold: str | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Drop.


                                    Subclass of AvdModel.

                                    Args:
                                        precedence: precedence
                                        threshold:
                                           Drop Threshold. This value may also be fractions.
                                           Example: 7/8 or 3/4 or 1/2
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                            "_custom_data": {"type": dict},
                        }
                        id: int
                        unit: Literal["bytes", "cells"] | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop
                        """Subclass of AvdModel."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | UndefinedType = Undefined,
                                unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined,
                                reserved: int | None | UndefinedType = Undefined,
                                threshold: str | None | UndefinedType = Undefined,
                                drop: Drop | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MulticastQueuesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                    reserved:
                                       Amount of memory that should be reserved for this
                                       queue.
                                    threshold: Dynamic Shared Memory threshold.
                                    drop: Subclass of AvdModel.
                                    _custom_data: _custom_data

                                """

                    class MulticastQueues(AvdIndexedList[int, MulticastQueuesItem]):
                        """Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key is `id` (`int`)."""

                        _primary_key: ClassVar[str] = "id"

                    MulticastQueues._item_type = MulticastQueuesItem

                    class UnicastQueuesItem(AvdModel):
                        """Subclass of AvdModel."""

                        class Drop(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"precedence": {"type": int}, "threshold": {"type": str}, "_custom_data": {"type": dict}}
                            precedence: Literal[1, 2]
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    precedence: Literal[1, 2] | UndefinedType = Undefined,
                                    threshold: str | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Drop.


                                    Subclass of AvdModel.

                                    Args:
                                        precedence: precedence
                                        threshold:
                                           Drop Threshold. This value may also be fractions.
                                           Example: 7/8 or 3/4 or 1/2
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                            "_custom_data": {"type": dict},
                        }
                        id: int
                        unit: Literal["bytes", "cells"] | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop
                        """Subclass of AvdModel."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                id: int | UndefinedType = Undefined,
                                unit: Literal["bytes", "cells"] | None | UndefinedType = Undefined,
                                reserved: int | None | UndefinedType = Undefined,
                                threshold: str | None | UndefinedType = Undefined,
                                drop: Drop | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                UnicastQueuesItem.


                                Subclass of AvdModel.

                                Args:
                                    id: id
                                    unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                    reserved:
                                       Amount of memory that should be reserved for this
                                       queue.
                                    threshold: Dynamic Shared Memory threshold.
                                    drop: Subclass of AvdModel.
                                    _custom_data: _custom_data

                                """

                    class UnicastQueues(AvdIndexedList[int, UnicastQueuesItem]):
                        """Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is `id` (`int`)."""

                        _primary_key: ClassVar[str] = "id"

                    UnicastQueues._item_type = UnicastQueuesItem

                    _fields: ClassVar[dict] = {
                        "name": {"type": str},
                        "multicast_queues": {"type": MulticastQueues},
                        "unicast_queues": {"type": UnicastQueues},
                        "_custom_data": {"type": dict},
                    }
                    name: str
                    multicast_queues: MulticastQueues
                    """Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key is `id` (`int`)."""
                    unicast_queues: UnicastQueues
                    """Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is `id` (`int`)."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            multicast_queues: MulticastQueues | UndefinedType = Undefined,
                            unicast_queues: UnicastQueues | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            QueueProfilesItem.


                            Subclass of AvdModel.

                            Args:
                                name: name
                                multicast_queues: Subclass of AvdIndexedList with `MulticastQueuesItem` items. Primary key is `id` (`int`).
                                unicast_queues: Subclass of AvdIndexedList with `UnicastQueuesItem` items. Primary key is `id` (`int`).
                                _custom_data: _custom_data

                            """

                class QueueProfiles(AvdIndexedList[str, QueueProfilesItem]):
                    """Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                QueueProfiles._item_type = QueueProfilesItem

                _fields: ClassVar[dict] = {"active_profile": {"type": str}, "queue_profiles": {"type": QueueProfiles}, "_custom_data": {"type": dict}}
                active_profile: str | None
                """The queue profile to be applied to the platform."""
                queue_profiles: QueueProfiles
                """Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        active_profile: str | None | UndefinedType = Undefined,
                        queue_profiles: QueueProfiles | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mmu.


                        Subclass of AvdModel.

                        Args:
                            active_profile: The queue profile to be applied to the platform.
                            queue_profiles: Subclass of AvdIndexedList with `QueueProfilesItem` items. Primary key is `name` (`str`).
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"forwarding_table_partition": {"type": str}, "l3": {"type": L3}, "mmu": {"type": Mmu}, "_custom_data": {"type": dict}}
            forwarding_table_partition: str | None
            l3: L3
            """Subclass of AvdModel."""
            mmu: Mmu
            """
            Memory Management Unit settings.


            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    forwarding_table_partition: str | None | UndefinedType = Undefined,
                    l3: L3 | UndefinedType = Undefined,
                    mmu: Mmu | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Trident.


                    Subclass of AvdModel.

                    Args:
                        forwarding_table_partition: forwarding_table_partition
                        l3: Subclass of AvdModel.
                        mmu:
                           Memory Management Unit settings.


                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Sand(AvdModel):
            """Subclass of AvdModel."""

            class QosMapsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"traffic_class": {"type": int}, "to_network_qos": {"type": int}, "_custom_data": {"type": dict}}
                traffic_class: int | None
                to_network_qos: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        traffic_class: int | None | UndefinedType = Undefined,
                        to_network_qos: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        QosMapsItem.


                        Subclass of AvdModel.

                        Args:
                            traffic_class: traffic_class
                            to_network_qos: to_network_qos
                            _custom_data: _custom_data

                        """

            class QosMaps(AvdList[QosMapsItem]):
                """Subclass of AvdList with `QosMapsItem` items."""

            QosMaps._item_type = QosMapsItem

            class Lag(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"hardware_only": {"type": bool}, "mode": {"type": str}, "_custom_data": {"type": dict}}
                hardware_only: bool | None
                mode: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        hardware_only: bool | None | UndefinedType = Undefined,
                        mode: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lag.


                        Subclass of AvdModel.

                        Args:
                            hardware_only: hardware_only
                            mode: mode
                            _custom_data: _custom_data

                        """

            class MulticastReplication(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"default": {"type": str}, "_custom_data": {"type": dict}}
                default: Literal["ingress", "egress"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        default: Literal["ingress", "egress"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MulticastReplication.


                        Subclass of AvdModel.

                        Args:
                            default: default
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "qos_maps": {"type": QosMaps},
                "lag": {"type": Lag},
                "forwarding_mode": {"type": str},
                "multicast_replication": {"type": MulticastReplication},
                "mdb_profile": {"type": str},
                "_custom_data": {"type": dict},
            }
            qos_maps: QosMaps
            """Subclass of AvdList with `QosMapsItem` items."""
            lag: Lag
            """Subclass of AvdModel."""
            forwarding_mode: str | None
            multicast_replication: MulticastReplication
            """Subclass of AvdModel."""
            mdb_profile: Literal["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"] | None
            """Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    qos_maps: QosMaps | UndefinedType = Undefined,
                    lag: Lag | UndefinedType = Undefined,
                    forwarding_mode: str | None | UndefinedType = Undefined,
                    multicast_replication: MulticastReplication | UndefinedType = Undefined,
                    mdb_profile: Literal["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sand.


                    Subclass of AvdModel.

                    Args:
                        qos_maps: Subclass of AvdList with `QosMapsItem` items.
                        lag: Subclass of AvdModel.
                        forwarding_mode: forwarding_mode
                        multicast_replication: Subclass of AvdModel.
                        mdb_profile: Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG.
                        _custom_data: _custom_data

                    """

        class Sfe(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"data_plane_cpu_allocation_max": {"type": int}, "_custom_data": {"type": dict}}
            data_plane_cpu_allocation_max: int | None
            """Maximum number of CPUs used for data plane traffic forwarding."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Sfe.


                    Subclass of AvdModel.

                    Args:
                        data_plane_cpu_allocation_max: Maximum number of CPUs used for data plane traffic forwarding.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"trident": {"type": Trident}, "sand": {"type": Sand}, "sfe": {"type": Sfe}, "_custom_data": {"type": dict}}
        trident: Trident
        """Subclass of AvdModel."""
        sand: Sand
        """
        Most of the platform sand options are hardware dependent and optional.

        Subclass of AvdModel.
        """
        sfe: Sfe
        """
        Sfe (Software Forwarding Engine) settings.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                trident: Trident | UndefinedType = Undefined,
                sand: Sand | UndefinedType = Undefined,
                sfe: Sfe | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Platform.


                Subclass of AvdModel.

                Args:
                    trident: Subclass of AvdModel.
                    sand:
                       Most of the platform sand options are hardware dependent and optional.

                       Subclass of AvdModel.
                    sfe:
                       Sfe (Software Forwarding Engine) settings.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Poe(AvdModel):
        """Subclass of AvdModel."""

        class Reboot(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"action": {"type": str}, "_custom_data": {"type": dict}}
            action: Literal["power-off", "maintain"] | None
            """PoE action for interface. By default in EOS, reboot action is set to power-off."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["power-off", "maintain"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Reboot.


                    Subclass of AvdModel.

                    Args:
                        action: PoE action for interface. By default in EOS, reboot action is set to power-off.
                        _custom_data: _custom_data

                    """

        class InterfaceShutdown(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"action": {"type": str}, "_custom_data": {"type": dict}}
            action: Literal["power-off", "maintain"] | None
            """PoE action for interface. By default in EOS, interface shutdown action is set to maintain."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["power-off", "maintain"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceShutdown.


                    Subclass of AvdModel.

                    Args:
                        action: PoE action for interface. By default in EOS, interface shutdown action is set to maintain.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"reboot": {"type": Reboot}, "interface_shutdown": {"type": InterfaceShutdown}, "_custom_data": {"type": dict}}
        reboot: Reboot
        """
        Set the global PoE power behavior for PoE ports when the system is rebooted.

        Subclass of AvdModel.
        """
        interface_shutdown: InterfaceShutdown
        """
        Set the global PoE power behavior for PoE ports when ports are admin down.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                reboot: Reboot | UndefinedType = Undefined,
                interface_shutdown: InterfaceShutdown | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Poe.


                Subclass of AvdModel.

                Args:
                    reboot:
                       Set the global PoE power behavior for PoE ports when the system is rebooted.

                       Subclass of AvdModel.
                    interface_shutdown:
                       Set the global PoE power behavior for PoE ports when ports are admin down.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class PolicyMaps(AvdModel):
        """Subclass of AvdModel."""

        class PbrItem(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                class Set(AvdModel):
                    """Subclass of AvdModel."""

                    class Nexthop(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"ip_address": {"type": str}, "recursive": {"type": bool}, "_custom_data": {"type": dict}}
                        ip_address: str | None
                        """IPv4 or IPv6 Address."""
                        recursive: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                ip_address: str | None | UndefinedType = Undefined,
                                recursive: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Nexthop.


                                Subclass of AvdModel.

                                Args:
                                    ip_address: IPv4 or IPv6 Address.
                                    recursive: recursive
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"nexthop": {"type": Nexthop}, "_custom_data": {"type": dict}}
                    nexthop: Nexthop
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, nexthop: Nexthop | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Set.


                            Subclass of AvdModel.

                            Args:
                                nexthop: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "index": {"type": int},
                    "drop": {"type": bool},
                    "set": {"type": Set},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Class Name."""
                index: int | None
                drop: bool | None
                """'drop' and 'set' are mutually exclusive."""
                set: Set
                """
                Set Nexthop
                'drop' and 'set' are mutually exclusive.


                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        index: int | None | UndefinedType = Undefined,
                        drop: bool | None | UndefinedType = Undefined,
                        set: Set | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Class Name.
                            index: index
                            drop: 'drop' and 'set' are mutually exclusive.
                            set:
                               Set Nexthop
                               'drop' and 'set' are mutually exclusive.


                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "classes": {"type": Classes}, "_custom_data": {"type": dict}}
            name: str
            """Policy-Map Name."""
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    classes: Classes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PbrItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy-Map Name.
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Pbr(AvdIndexedList[str, PbrItem]):
            """Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                class Set(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "cos": {"type": int},
                        "dscp": {"type": str},
                        "traffic_class": {"type": int},
                        "drop_precedence": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    cos: int | None
                    dscp: str | None
                    traffic_class: int | None
                    drop_precedence: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            cos: int | None | UndefinedType = Undefined,
                            dscp: str | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            drop_precedence: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Set.


                            Subclass of AvdModel.

                            Args:
                                cos: cos
                                dscp: dscp
                                traffic_class: traffic_class
                                drop_precedence: drop_precedence
                                _custom_data: _custom_data

                            """

                class Police(AvdModel):
                    """Subclass of AvdModel."""

                    class Action(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"type": {"type": str}, "dscp_value": {"type": str}, "_custom_data": {"type": dict}}
                        type: Literal["dscp", "drop-precedence"] | None
                        """Set action for policed traffic."""
                        dscp_value: str | None
                        """Set when action.type is set to "dscp"."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                type: Literal["dscp", "drop-precedence"] | None | UndefinedType = Undefined,
                                dscp_value: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Action.


                                Subclass of AvdModel.

                                Args:
                                    type: Set action for policed traffic.
                                    dscp_value: Set when action.type is set to "dscp".
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "rate": {"type": int},
                        "rate_unit": {"type": str, "default": "bps"},
                        "rate_burst_size": {"type": int},
                        "rate_burst_size_unit": {"type": str, "default": "bytes"},
                        "action": {"type": Action},
                        "higher_rate": {"type": int},
                        "higher_rate_unit": {"type": str, "default": "bps"},
                        "higher_rate_burst_size": {"type": int},
                        "higher_rate_burst_size_unit": {"type": str, "default": "bytes"},
                        "_custom_data": {"type": dict},
                    }
                    rate: int | None
                    """
                    Specify rate.
                    Range in kbps <8-200000000>.
                    """
                    rate_unit: Literal["bps", "kbps", "mbps", "pps"]
                    """Default value: `"bps"`"""
                    rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"]
                    """Default value: `"bytes"`"""
                    action: Action
                    """Subclass of AvdModel."""
                    higher_rate: int | None
                    """
                    Specify higher rate.
                    Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                    """
                    higher_rate_unit: Literal["bps", "kbps", "mbps", "pps"]
                    """Default value: `"bps"`"""
                    higher_rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    higher_rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"]
                    """Default value: `"bytes"`"""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            rate: int | None | UndefinedType = Undefined,
                            rate_unit: Literal["bps", "kbps", "mbps", "pps"] | UndefinedType = Undefined,
                            rate_burst_size: int | None | UndefinedType = Undefined,
                            rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"] | UndefinedType = Undefined,
                            action: Action | UndefinedType = Undefined,
                            higher_rate: int | None | UndefinedType = Undefined,
                            higher_rate_unit: Literal["bps", "kbps", "mbps", "pps"] | UndefinedType = Undefined,
                            higher_rate_burst_size: int | None | UndefinedType = Undefined,
                            higher_rate_burst_size_unit: Literal["bytes", "kbytes", "mbytes", "packets"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Police.


                            Subclass of AvdModel.

                            Args:
                                rate:
                                   Specify rate.
                                   Range in kbps <8-200000000>.
                                rate_unit: rate_unit
                                rate_burst_size: Range in bytes <256-128000000>.
                                rate_burst_size_unit: rate_burst_size_unit
                                action: Subclass of AvdModel.
                                higher_rate:
                                   Specify higher rate.
                                   Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                                higher_rate_unit: higher_rate_unit
                                higher_rate_burst_size: Range in bytes <256-128000000>.
                                higher_rate_burst_size_unit: higher_rate_burst_size_unit
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "set": {"type": Set}, "police": {"type": Police}, "_custom_data": {"type": dict}}
                name: str
                """Class Name."""
                set: Set
                """Subclass of AvdModel."""
                police: Police
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        set: Set | UndefinedType = Undefined,
                        police: Police | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Class Name.
                            set: Subclass of AvdModel.
                            police: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "classes": {"type": Classes}, "_custom_data": {"type": dict}}
            name: str
            """Policy-Map Name."""
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    classes: Classes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    QosItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy-Map Name.
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Qos(AvdIndexedList[str, QosItem]):
            """Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        class CoppSystemPolicy(AvdModel):
            """Subclass of AvdModel."""

            class ClassesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "shape": {"type": int},
                    "bandwidth": {"type": int},
                    "rate_unit": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                shape: int | None
                """Maximum rate limit."""
                bandwidth: int | None
                """Minimum bandwidth."""
                rate_unit: Literal["pps", "kbps"] | None
                """The `rate_unit` must be defined for `shape` and `bandwidth`."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        shape: int | None | UndefinedType = Undefined,
                        bandwidth: int | None | UndefinedType = Undefined,
                        rate_unit: Literal["pps", "kbps"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ClassesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            shape: Maximum rate limit.
                            bandwidth: Minimum bandwidth.
                            rate_unit: The `rate_unit` must be defined for `shape` and `bandwidth`.
                            _custom_data: _custom_data

                        """

            class Classes(AvdIndexedList[str, ClassesItem]):
                """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"classes": {"type": Classes}, "_custom_data": {"type": dict}}
            classes: Classes
            """Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, classes: Classes | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    CoppSystemPolicy.


                    Subclass of AvdModel.

                    Args:
                        classes: Subclass of AvdIndexedList with `ClassesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}, "copp_system_policy": {"type": CoppSystemPolicy}, "_custom_data": {"type": dict}}
        pbr: Pbr
        """
        PBR Policy-Maps.

        Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
        """
        qos: Qos
        """
        QOS Policy-Maps.

        Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`).
        """
        copp_system_policy: CoppSystemPolicy
        """
        Control-plane policy configuration.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                pbr: Pbr | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                copp_system_policy: CoppSystemPolicy | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PolicyMaps.


                Subclass of AvdModel.

                Args:
                    pbr:
                       PBR Policy-Maps.

                       Subclass of AvdIndexedList with `PbrItem` items. Primary key is `name` (`str`).
                    qos:
                       QOS Policy-Maps.

                       Subclass of AvdIndexedList with `QosItem` items. Primary key is `name` (`str`).
                    copp_system_policy:
                       Control-plane policy configuration.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class PortChannelInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"link_status": {"type": bool}, "storm_control_discards": {"type": bool}, "_custom_data": {"type": dict}}
                link_status: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        link_status: bool | None | UndefinedType = Undefined,
                        storm_control_discards: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status
                            storm_control_discards: Discards due to storm-control.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}, "_custom_data": {"type": dict}}
            event: Event
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class EncapsulationDot1q(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"vlan": {"type": int}, "inner_vlan": {"type": int}, "_custom_data": {"type": dict}}
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    vlan: int | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EncapsulationDot1q.


                    Subclass of AvdModel.

                    Args:
                        vlan: VLAD ID.
                        inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.
                        _custom_data: _custom_data

                    """

        class EncapsulationVlan(AvdModel):
            """Subclass of AvdModel."""

            class Client(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}, "_custom_data": {"type": dict}}
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Client VLAN ID.
                                outer: Client Outer VLAN ID.
                                inner: Client Inner VLAN ID.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                    "_custom_data": {"type": dict},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                unmatched: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        unmatched: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "unmatched", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Client.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            unmatched: unmatched
                            encapsulation: encapsulation
                            vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                            inner_encapsulation: inner_encapsulation
                            _custom_data: _custom_data

                        """

            class Network(AvdModel):
                """Subclass of AvdModel."""

                class Dot1q(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}, "_custom_data": {"type": dict}}
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network Outer VLAN ID."""
                    inner: int | None
                    """Network Inner VLAN ID."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vlan: int | None | UndefinedType = Undefined,
                            outer: int | None | UndefinedType = Undefined,
                            inner: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1q.


                            Subclass of AvdModel.

                            Args:
                                vlan: Network VLAN ID.
                                outer: Network Outer VLAN ID.
                                inner: Network Inner VLAN ID.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                    "_custom_data": {"type": dict},
                }
                dot1q: Dot1q
                """Subclass of AvdModel."""
                client: bool | None
                encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Literal["dot1q", "dot1ad"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dot1q: Dot1q | UndefinedType = Undefined,
                        client: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["dot1q", "dot1ad", "client", "client inner", "untagged"] | None | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer_vlan: int | None | UndefinedType = Undefined,
                        inner_vlan: int | None | UndefinedType = Undefined,
                        inner_encapsulation: Literal["dot1q", "dot1ad"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Network.


                        Subclass of AvdModel.

                        Args:
                            dot1q: Subclass of AvdModel.
                            client: client
                            encapsulation:
                               `untagged` (no encapsulation) is applicable for `untagged` client only.
                               `client` and `client inner`
                               (retain client encapsulation) is not applicable for `untagged` client.
                            vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_vlan: Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                            inner_encapsulation: inner_encapsulation
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"client": {"type": Client}, "network": {"type": Network}, "_custom_data": {"type": dict}}
            client: Client
            """Subclass of AvdModel."""
            network: Network
            """
            Network encapsulation are all optional, and skipped if using client unmatched.

            Subclass of
            AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    client: Client | UndefinedType = Undefined,
                    network: Network | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EncapsulationVlan.


                    Subclass of AvdModel.

                    Args:
                        client: Subclass of AvdModel.
                        network:
                           Network encapsulation are all optional, and skipped if using client unmatched.

                           Subclass of
                           AvdModel.
                        _custom_data: _custom_data

                    """

        class LinkTrackingGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "direction": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Group name."""
            direction: Literal["upstream", "downstream"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkTrackingGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        direction: direction
                        _custom_data: _custom_data

                    """

        class LinkTrackingGroups(AvdIndexedList[str, LinkTrackingGroupsItem]):
            """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class LinkTracking(AvdModel):
            """Subclass of AvdModel."""

            class Groups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Groups._item_type = str

            _fields: ClassVar[dict] = {"direction": {"type": str}, "groups": {"type": Groups}, "_custom_data": {"type": dict}}
            direction: Literal["upstream", "downstream"] | None
            groups: Groups
            """
            Link state group(s) an interface belongs to.

            Subclass of AvdList with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    direction: Literal["upstream", "downstream"] | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkTracking.


                    Subclass of AvdModel.

                    Args:
                        direction: direction
                        groups:
                           Link state group(s) an interface belongs to.

                           Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trunk": {"type": str}, "vlan": {"type": int}, "_custom_data": {"type": dict}}
            trunk: Literal["tagged", "untagged"] | None
            vlan: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trunk: Literal["tagged", "untagged"] | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        trunk: trunk
                        vlan: vlan
                        _custom_data: _custom_data

                    """

        class L2Protocol(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}, "_custom_data": {"type": dict}}
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                    forwarding_profile: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    L2Protocol.


                    Subclass of AvdModel.

                    Args:
                        encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                        forwarding_profile: L2 protocol forwarding profile.
                        _custom_data: _custom_data

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class Qos(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}, "_custom_data": {"type": dict}}
            trust: Literal["dscp", "cos", "disabled"] | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    trust: Literal["dscp", "cos", "disabled"] | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    cos: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Qos.


                    Subclass of AvdModel.

                    Args:
                        trust: trust
                        dscp: DSCP value.
                        cos: COS value.
                        _custom_data: _custom_data

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            class PerLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rfc_7130": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                rfc_7130: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        rfc_7130: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PerLink.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rfc_7130: rfc_7130
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
                "neighbor": {"type": str},
                "per_link": {"type": PerLink},
                "_custom_data": {"type": dict},
            }
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None
            neighbor: str | None
            """
            IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
            (router_bfd.local_address) has to be defined globally on the switch.
            """
            per_link: PerLink
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    neighbor: str | None | UndefinedType = Undefined,
                    per_link: PerLink | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier
                        neighbor:
                           IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
                           (router_bfd.local_address) has to be defined globally on the switch.
                        per_link: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}, "_custom_data": {"type": dict}}
                input: str | None
                """Policy Based Routing Policy-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Policy Based Routing Policy-map name.
                            _custom_data: _custom_data

                        """

            class Qos(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}, "_custom_data": {"type": dict}}
                input: str
                """Quality of Service Policy-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Qos.


                        Subclass of AvdModel.

                        Args:
                            input: Quality of Service Policy-map name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "qos": {"type": Qos}, "_custom_data": {"type": dict}}
            pbr: Pbr
            """Subclass of AvdModel."""
            qos: Qos
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    pbr: Pbr | UndefinedType = Undefined,
                    qos: Qos | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.
                        qos: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Mpls(AvdModel):
            """Subclass of AvdModel."""

            class Ldp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": bool}, "igp_sync": {"type": bool}, "_custom_data": {"type": dict}}
                interface: bool | None
                igp_sync: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interface: bool | None | UndefinedType = Undefined,
                        igp_sync: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ldp.


                        Subclass of AvdModel.

                        Args:
                            interface: interface
                            igp_sync: igp_sync
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ip": {"type": bool}, "ldp": {"type": Ldp}, "_custom_data": {"type": dict}}
            ip: bool | None
            ldp: Ldp
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip: bool | None | UndefinedType = Undefined,
                    ldp: Ldp | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mpls.


                    Subclass of AvdModel.

                    Args:
                        ip: ip
                        ldp: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class VlanTranslationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "field_from": {"type": str},
                "to": {"type": int},
                "direction": {"type": str, "default": "both"},
                "_custom_data": {"type": dict},
            }
            _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
            _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: Literal["in", "out", "both"]
            """Default value: `"both"`"""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    field_from: str | None | UndefinedType = Undefined,
                    to: int | None | UndefinedType = Undefined,
                    direction: Literal["in", "out", "both"] | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslationsItem.


                    Subclass of AvdModel.

                    Args:
                        field_from: List of vlans as string (only one vlan if direction is "both").
                        to: VLAN ID.
                        direction: direction
                        _custom_data: _custom_data

                    """

        class VlanTranslations(AvdList[VlanTranslationsItem]):
            """Subclass of AvdList with `VlanTranslationsItem` items."""

        VlanTranslations._item_type = VlanTranslationsItem

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Rate in kbps, pps or percent.
                           Supported options are platform dependent.
                           Examples:  # fmt: skip
                           - "5000 kbps"
                           -
                           "1000 pps"
                           - "20 percent"
                        _custom_data: _custom_data

                    """

        class StormControl(AvdModel):
            """Subclass of AvdModel."""

            class All(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        All.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class Broadcast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Broadcast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class Multicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Multicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            class UnknownUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level": {"type": str}, "unit": {"type": str, "default": "percent"}, "_custom_data": {"type": dict}}
                level: str | None
                """Configure maximum storm-control level."""
                unit: Literal["percent", "pps"]
                """
                Optional field and is hardware dependent.

                Default value: `"percent"`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level: str | None | UndefinedType = Undefined,
                        unit: Literal["percent", "pps"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        UnknownUnicast.


                        Subclass of AvdModel.

                        Args:
                            level: Configure maximum storm-control level.
                            unit: Optional field and is hardware dependent.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
                "_custom_data": {"type": dict},
            }
            all: All
            """Subclass of AvdModel."""
            broadcast: Broadcast
            """Subclass of AvdModel."""
            multicast: Multicast
            """Subclass of AvdModel."""
            unknown_unicast: UnknownUnicast
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    all: All | UndefinedType = Undefined,
                    broadcast: Broadcast | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StormControl.


                    Subclass of AvdModel.

                    Args:
                        all: Subclass of AvdModel.
                        broadcast: Subclass of AvdModel.
                        multicast: Subclass of AvdModel.
                        unknown_unicast: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}, "_custom_data": {"type": dict}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    both: Both | UndefinedType = Undefined,
                    level_1: Level1 | UndefinedType = Undefined,
                    level_2: Level2 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TrafficPolicy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"input": {"type": str}, "output": {"type": str}, "_custom_data": {"type": dict}}
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    input: str | None | UndefinedType = Undefined,
                    output: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficPolicy.


                    Subclass of AvdModel.

                    Args:
                        input: Ingress traffic policy.
                        output: Egress traffic policy.
                        _custom_data: _custom_data

                    """

        class EvpnEthernetSegment(AvdModel):
            """Subclass of AvdModel."""

            class DesignatedForwarderElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool, "default": False},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                algorithm: Literal["modulus", "preference"] | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool
                """
                Dont_preempt is only used when "algorithm" is "preference".

                Default value: `False`
                """
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["modulus", "preference"] | None | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                        dont_preempt: bool | UndefinedType = Undefined,
                        hold_time: int | None | UndefinedType = Undefined,
                        subsequent_hold_time: int | None | UndefinedType = Undefined,
                        candidate_reachability_required: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DesignatedForwarderElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm: algorithm
                            preference_value: Preference_value is only used when "algorithm" is "preference".
                            dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                            hold_time: hold_time
                            subsequent_hold_time: subsequent_hold_time
                            candidate_reachability_required: candidate_reachability_required
                            _custom_data: _custom_data

                        """

            class Mpls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}, "_custom_data": {"type": dict}}
                shared_index: int | None
                tunnel_flood_filter_time: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        shared_index: int | None | UndefinedType = Undefined,
                        tunnel_flood_filter_time: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Mpls.


                        Subclass of AvdModel.

                        Args:
                            shared_index: shared_index
                            tunnel_flood_filter_time: tunnel_flood_filter_time
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
                "_custom_data": {"type": dict},
            }
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Literal["all-active", "single-active"] | None
            designated_forwarder_election: DesignatedForwarderElection
            """Subclass of AvdModel."""
            mpls: Mpls
            """Subclass of AvdModel."""
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    identifier: str | None | UndefinedType = Undefined,
                    redundancy: Literal["all-active", "single-active"] | None | UndefinedType = Undefined,
                    designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                    mpls: Mpls | UndefinedType = Undefined,
                    route_target: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnEthernetSegment.


                    Subclass of AvdModel.

                    Args:
                        identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                        redundancy: redundancy
                        designated_forwarder_election: Subclass of AvdModel.
                        mpls: Subclass of AvdModel.
                        route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.
                        _custom_data: _custom_data

                    """

        class Ptp(AvdModel):
            """Subclass of AvdModel."""

            class Announce(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                timeout: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | None | UndefinedType = Undefined,
                        timeout: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Announce.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            timeout: timeout
                            _custom_data: _custom_data

                        """

            class Profile(AvdModel):
                """Subclass of AvdModel."""

                class G82751(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"destination_mac_address": {"type": str}, "_custom_data": {"type": dict}}
                    destination_mac_address: Literal["forwardable", "non-forwardable"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            destination_mac_address: Literal["forwardable", "non-forwardable"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            G82751.


                            Subclass of AvdModel.

                            Args:
                                destination_mac_address: destination_mac_address
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"g8275_1": {"type": G82751}, "_custom_data": {"type": dict}}
                g8275_1: G82751
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, g8275_1: G82751 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Profile.


                        Subclass of AvdModel.

                        Args:
                            g8275_1: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class SyncMessage(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        SyncMessage.


                        Subclass of AvdModel.

                        Args:
                            interval: interval
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
                "mpass": {"type": bool},
                "_custom_data": {"type": dict},
            }
            enable: bool | None
            announce: Announce
            """Subclass of AvdModel."""
            delay_req: int | None
            delay_mechanism: Literal["e2e", "p2p"] | None
            profile: Profile
            """Subclass of AvdModel."""
            sync_message: SyncMessage
            """Subclass of AvdModel."""
            role: Literal["master", "dynamic"] | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Literal["ipv4", "ipv6", "layer2"] | None
            mpass: bool | None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    announce: Announce | UndefinedType = Undefined,
                    delay_req: int | None | UndefinedType = Undefined,
                    delay_mechanism: Literal["e2e", "p2p"] | None | UndefinedType = Undefined,
                    profile: Profile | UndefinedType = Undefined,
                    sync_message: SyncMessage | UndefinedType = Undefined,
                    role: Literal["master", "dynamic"] | None | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    transport: Literal["ipv4", "ipv6", "layer2"] | None | UndefinedType = Undefined,
                    mpass: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ptp.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        announce: Subclass of AvdModel.
                        delay_req: delay_req
                        delay_mechanism: delay_mechanism
                        profile: Subclass of AvdModel.
                        sync_message: Subclass of AvdModel.
                        role: role
                        vlan: VLAN can be 'all' or list of vlans as string.
                        transport: transport
                        mpass:
                           When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                           logical device.
                           Arista PTP enabled devices always place PTP messages on the same physical link
                           within the port-channel.
                           Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                           devices.
                        _custom_data: _custom_data

                    """

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"destination": {"type": Destination}, "source": {"type": Source}, "_custom_data": {"type": dict}}
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
                "_custom_data": {"type": dict},
            }
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: ipv6_prefix
                        valid_lifetime: Infinite or lifetime in seconds.
                        preferred_lifetime: Infinite or lifetime in seconds.
                        no_autoconfig_flag: no_autoconfig_flag
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}, "_custom_data": {"type": dict}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: str | None | UndefinedType = Undefined,
                            interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                    "_custom_data": {"type": dict},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            hello: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}, "_custom_data": {"type": dict}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class FlowTracker(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sampled": {"type": str}, "hardware": {"type": str}, "_custom_data": {"type": dict}}
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sampled: str | None | UndefinedType = Undefined,
                    hardware: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracker.


                    Subclass of AvdModel.

                    Args:
                        sampled: Sampled flow tracker name.
                        hardware: Hardware flow tracker name.
                        _custom_data: _custom_data

                    """

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"session_tracker": {"type": str}, "_custom_data": {"type": dict}}
            session_tracker: str | None
            """Name of session tracker."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, session_tracker: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        session_tracker: Name of session tracker.
                        _custom_data: _custom_data

                    """

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}, "_custom_data": {"type": dict}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                            _custom_data: _custom_data

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            _custom_data: _custom_data

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.
                        _custom_data: _custom_data

                    """

        class Sflow(AvdModel):
            """Subclass of AvdModel."""

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable": {"type": bool}, "unmodified_enable": {"type": bool}, "_custom_data": {"type": dict}}
                enable: bool | None
                unmodified_enable: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enable: bool | None | UndefinedType = Undefined,
                        unmodified_enable: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable: enable
                            unmodified_enable: unmodified_enable
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"enable": {"type": bool}, "egress": {"type": Egress}, "_custom_data": {"type": dict}}
            enable: bool | None
            egress: Egress
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | None | UndefinedType = Undefined,
                    egress: Egress | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sflow.


                    Subclass of AvdModel.

                    Args:
                        enable: enable
                        egress: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Switchport(AvdModel):
            """Subclass of AvdModel."""

            class Trunk(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": Groups},
                    "_custom_data": {"type": dict},
                }
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs (1-4094).
                Warning: This should not be combined with
                `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `port_channel_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `port_channel_interfaces[].trunk_private_vlan_secondary`.
                """
                groups: Groups
                """
                Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.


                Subclass of
                AvdList with `str` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        native_vlan_tag: bool | None | UndefinedType = Undefined,
                        private_vlan_secondary: bool | None | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Trunk.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan:
                               VLAN ID or range(s) of VLAN IDs (1-4094).
                               Warning: This should not be combined with
                               `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                            native_vlan:
                               Set native VLAN when interface is in trunking mode.
                               Warning: This should not be combined with
                               `port_channel_interfaces[].native_vlan`.
                            native_vlan_tag:
                               If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                               Warning: This
                               should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                            private_vlan_secondary:
                               Enable secondary VLAN mapping for a private vlan.
                               Warning: This should not be combined with
                               `port_channel_interfaces[].trunk_private_vlan_secondary`.
                            groups:
                               Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.


                               Subclass of
                               AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class Phone(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"vlan": {"type": int}, "trunk": {"type": str}, "_custom_data": {"type": dict}}
                vlan: int | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`."""
                trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        vlan: int | None | UndefinedType = Undefined,
                        trunk: Literal["tagged", "tagged phone", "untagged", "untagged phone"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Phone.


                        Subclass of AvdModel.

                        Args:
                            vlan: Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`.
                            trunk: Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`
                            _custom_data: _custom_data

                        """

            class Dot1q(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ethertype": {"type": int}, "vlan_tag": {"type": str}, "_custom_data": {"type": dict}}
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Literal["disallowed", "required"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ethertype: int | None | UndefinedType = Undefined,
                        vlan_tag: Literal["disallowed", "required"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.


                        Subclass of AvdModel.

                        Args:
                            ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                            vlan_tag: vlan_tag
                            _custom_data: _custom_data

                        """

            class VlanTranslations(AvdModel):
                """Subclass of AvdModel."""

                class DirectionInItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str | None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | None | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionInItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                _custom_data: _custom_data

                            """

                class DirectionIn(AvdList[DirectionInItem]):
                    """Subclass of AvdList with `DirectionInItem` items."""

                DirectionIn._item_type = DirectionInItem

                class DirectionOutItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | None | UndefinedType = Undefined,
                            dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                            inner_vlan_to: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOutItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel_to:
                                   VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                                   This takes precedence over `to` and
                                   `inner_vlan_to`.
                                inner_vlan_to: Inner VLAN ID to map to.
                                _custom_data: _custom_data

                            """

                class DirectionOut(AvdList[DirectionOutItem]):
                    """Subclass of AvdList with `DirectionOutItem` items."""

                DirectionOut._item_type = DirectionOutItem

                class DirectionBothItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "field_from": {"type": str},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            to: int | UndefinedType = Undefined,
                            dot1q_tunnel: bool | None | UndefinedType = Undefined,
                            inner_vlan_from: int | None | UndefinedType = Undefined,
                            network: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionBothItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                                to: VLAN ID to map to.
                                dot1q_tunnel: dot1q_tunnel
                                inner_vlan_from: Inner VLAN ID to map from.
                                network:
                                   Enable use of network-side VLAN ID.
                                   This setting can only be enabled when `inner_vlan_from` is
                                   defined.
                                _custom_data: _custom_data

                            """

                class DirectionBoth(AvdList[DirectionBothItem]):
                    """Subclass of AvdList with `DirectionBothItem` items."""

                DirectionBoth._item_type = DirectionBothItem

                _fields: ClassVar[dict] = {
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": DirectionIn},
                    "direction_out": {"type": DirectionOut},
                    "direction_both": {"type": DirectionBoth},
                    "_custom_data": {"type": dict},
                }
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: DirectionIn
                """
                Map ingress traffic only.

                Subclass of AvdList with `DirectionInItem` items.
                """
                direction_out: DirectionOut
                """
                Map egress traffic only.

                Subclass of AvdList with `DirectionOutItem` items.
                """
                direction_both: DirectionBoth
                """
                Map both egress and ingress traffic.

                Subclass of AvdList with `DirectionBothItem` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        in_required: bool | None | UndefinedType = Undefined,
                        out_required: bool | None | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        direction_both: DirectionBoth | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlanTranslations.


                        Subclass of AvdModel.

                        Args:
                            in_required: Drop the ingress traffic that do not match any VLAN mapping.
                            out_required: Drop the egress traffic that do not match any VLAN mapping.
                            direction_in:
                               Map ingress traffic only.

                               Subclass of AvdList with `DirectionInItem` items.
                            direction_out:
                               Map egress traffic only.

                               Subclass of AvdList with `DirectionOutItem` items.
                            direction_both:
                               Map both egress and ingress traffic.

                               Subclass of AvdList with `DirectionBothItem` items.
                            _custom_data: _custom_data

                        """

            class BackupLink(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interface": {"type": str}, "prefer_vlan": {"type": str}, "_custom_data": {"type": dict}}
                interface: str
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interface: str | UndefinedType = Undefined,
                        prefer_vlan: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BackupLink.


                        Subclass of AvdModel.

                        Args:
                            interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                            prefer_vlan: VLANs to carry on the backup interface (1-4094).
                            _custom_data: _custom_data

                        """

            class Backup(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                    "_custom_data": {"type": dict},
                }
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dest_macaddr: str | None | UndefinedType = Undefined,
                        initial_mac_move_delay: int | None | UndefinedType = Undefined,
                        mac_move_burst: int | None | UndefinedType = Undefined,
                        mac_move_burst_interval: int | None | UndefinedType = Undefined,
                        preemption_delay: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Backup.


                        Subclass of AvdModel.

                        Args:
                            dest_macaddr:
                               Destination MAC address for MAC move updates.
                               The mac address should be multicast or broadcast.
                               Example: 01:00:00:00:00:00
                            initial_mac_move_delay: Initial MAC move delay in milliseconds.
                            mac_move_burst: Size of MAC move bursts.
                            mac_move_burst_interval: MAC move burst interval in milliseconds.
                            preemption_delay: Preemption delay in milliseconds.
                            _custom_data: _custom_data

                        """

            class PortSecurity(AvdModel):
                """Subclass of AvdModel."""

                class MacAddressMaximum(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"disabled": {"type": bool}, "limit": {"type": int}, "_custom_data": {"type": dict}}
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            disabled: bool | None | UndefinedType = Undefined,
                            limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MacAddressMaximum.


                            Subclass of AvdModel.

                            Args:
                                disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                                limit: MAC address limit.
                                _custom_data: _custom_data

                            """

                class Violation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"mode": {"type": str}, "protect_log": {"type": bool}, "_custom_data": {"type": dict}}
                    mode: Literal["shutdown", "protect"] | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            mode: Literal["shutdown", "protect"] | None | UndefinedType = Undefined,
                            protect_log: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Violation.


                            Subclass of AvdModel.

                            Args:
                                mode: Configure port security mode.
                                protect_log: Log new addresses seen after limit is reached in protect mode.
                                _custom_data: _custom_data

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"range": {"type": str}, "mac_address_maximum": {"type": int}, "_custom_data": {"type": dict}}
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            range: str | UndefinedType = Undefined,
                            mac_address_maximum: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                range:
                                   VLAN ID or range(s) of VLAN IDs, <1-4094>.
                                   Example:  # fmt: skip
                                     - 3
                                     - 1,3
                                     - 1-10
                                mac_address_maximum: mac_address_maximum
                                _custom_data: _custom_data

                            """

                class Vlans(AvdIndexedList[str, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""

                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """
                Maximum number of MAC addresses allowed on the interface.

                Subclass of AvdModel.
                """
                violation: Violation
                """
                Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                Subclass of AvdModel.
                """
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                        violation: Violation | UndefinedType = Undefined,
                        vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortSecurity.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            mac_address_maximum:
                               Maximum number of MAC addresses allowed on the interface.

                               Subclass of AvdModel.
                            violation:
                               Configure violation mode (shutdown or protect), EOS default is 'shutdown'.

                               Subclass of AvdModel.
                            vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `range` (`str`).
                            _custom_data: _custom_data

                        """

            class Tap(AvdModel):
                """Subclass of AvdModel."""

                class Default(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class NexthopGroups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    NexthopGroups._item_type = str

                    _fields: ClassVar[dict] = {
                        "groups": {"type": Groups},
                        "interfaces": {"type": Interfaces},
                        "nexthop_groups": {"type": NexthopGroups},
                        "_custom_data": {"type": dict},
                    }
                    groups: Groups
                    """
                    Tap group names for the interface.

                    Subclass of AvdList with `str` items.
                    """
                    interfaces: Interfaces
                    """
                    Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                    Subclass of AvdList
                    with `str` items.
                    """
                    nexthop_groups: NexthopGroups
                    """
                    Default nexthop-group names.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            groups: Groups | UndefinedType = Undefined,
                            interfaces: Interfaces | UndefinedType = Undefined,
                            nexthop_groups: NexthopGroups | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Default.


                            Subclass of AvdModel.

                            Args:
                                groups:
                                   Tap group names for the interface.

                                   Subclass of AvdList with `str` items.
                                interfaces:
                                   Interfaces like -  Ethernet1, InternalRecirc1, Port-Channel1, Recirc-Channel1.

                                   Subclass of AvdList
                                   with `str` items.
                                nexthop_groups:
                                   Default nexthop-group names.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "inner_vlan": {"type": int}, "_custom_data": {"type": dict}}
                    id: int | None
                    """Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535)."""
                    inner_vlan: int | None
                    """Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094)."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | None | UndefinedType = Undefined,
                            inner_vlan: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                id: Tap port VLAN ID (1-4094) or DzGRE extended ID (1-65535).
                                inner_vlan: Tap port inner VLAN ID. Only applicable if `id` is a VLAN ID (1-4094).
                                _custom_data: _custom_data

                            """

                class Truncation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "size": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    size: int | None
                    """Ingress packet truncation size in bytes."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Truncation.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                size: Ingress packet truncation size in bytes.
                                _custom_data: _custom_data

                            """

                class MacAddress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "destination": {"type": str}, "_custom_data": {"type": dict}}
                    source: str | None
                    """MAC address for the source."""
                    destination: str | None
                    """MAC address for the destination."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source: str | None | UndefinedType = Undefined,
                            destination: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MacAddress.


                            Subclass of AvdModel.

                            Args:
                                source: MAC address for the source.
                                destination: MAC address for the destination.
                                _custom_data: _custom_data

                            """

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    class Gre(AvdModel):
                        """Subclass of AvdModel."""

                        class ProtocolsItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "protocol": {"type": str},
                                "strip": {"type": bool},
                                "feature_header_length": {"type": int},
                                "re_encapsulation_ethernet_header": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            protocol: str
                            """
                            Protocol type in GRE header.
                            Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                            "0x0".
                            """
                            strip: bool | None
                            """This is a required key to strip GRE encapsulation header with protocols."""
                            feature_header_length: int | None
                            """
                            Feature header length in bytes.
                            Note: This setting does not appear in the EOS running-config for
                            protocol 0x0.
                            """
                            re_encapsulation_ethernet_header: bool | None
                            """
                            Extra ethernet header to prepend to the terminated packet.
                            Note: This setting does not appear in the
                            EOS running-config for protocol 0x0.
                            """
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    protocol: str | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    feature_header_length: int | None | UndefinedType = Undefined,
                                    re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    ProtocolsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        protocol:
                                           Protocol type in GRE header.
                                           Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                           "0x0".
                                        strip: This is a required key to strip GRE encapsulation header with protocols.
                                        feature_header_length:
                                           Feature header length in bytes.
                                           Note: This setting does not appear in the EOS running-config for
                                           protocol 0x0.
                                        re_encapsulation_ethernet_header:
                                           Extra ethernet header to prepend to the terminated packet.
                                           Note: This setting does not appear in the
                                           EOS running-config for protocol 0x0.
                                        _custom_data: _custom_data

                                    """

                        class Protocols(AvdIndexedList[str, ProtocolsItem]):
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                            _primary_key: ClassVar[str] = "protocol"

                        Protocols._item_type = ProtocolsItem

                        class DestinationsItem(AvdModel):
                            """Subclass of AvdModel."""

                            class ProtocolsItem(AvdModel):
                                """Subclass of AvdModel."""

                                _fields: ClassVar[dict] = {
                                    "protocol": {"type": str},
                                    "strip": {"type": bool},
                                    "feature_header_length": {"type": int},
                                    "re_encapsulation_ethernet_header": {"type": bool},
                                    "_custom_data": {"type": dict},
                                }
                                protocol: str
                                """
                                Protocol type in GRE header.
                                Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                "0x0".
                                """
                                strip: bool | None
                                """This is a required key to strip GRE encapsulation header for specific destination with protocols."""
                                feature_header_length: int | None
                                """
                                Feature header length in bytes.
                                Note: This setting does not appear in the EOS running-config for
                                protocol 0x0.
                                """
                                re_encapsulation_ethernet_header: bool | None
                                """
                                Extra ethernet header to prepend to the terminated packet.
                                Note: This setting does not appear in the
                                EOS running-config for protocol 0x0.
                                """
                                _custom_data: dict[str, Any]

                                if TYPE_CHECKING:

                                    def __init__(
                                        self,
                                        *,
                                        protocol: str | UndefinedType = Undefined,
                                        strip: bool | None | UndefinedType = Undefined,
                                        feature_header_length: int | None | UndefinedType = Undefined,
                                        re_encapsulation_ethernet_header: bool | None | UndefinedType = Undefined,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        ProtocolsItem.


                                        Subclass of AvdModel.

                                        Args:
                                            protocol:
                                               Protocol type in GRE header.
                                               Valid range: 0x0-0xFFFF. The value must be enclosed in quotes, e.g.,
                                               "0x0".
                                            strip: This is a required key to strip GRE encapsulation header for specific destination with protocols.
                                            feature_header_length:
                                               Feature header length in bytes.
                                               Note: This setting does not appear in the EOS running-config for
                                               protocol 0x0.
                                            re_encapsulation_ethernet_header:
                                               Extra ethernet header to prepend to the terminated packet.
                                               Note: This setting does not appear in the
                                               EOS running-config for protocol 0x0.
                                            _custom_data: _custom_data

                                        """

                            class Protocols(AvdIndexedList[str, ProtocolsItem]):
                                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                                _primary_key: ClassVar[str] = "protocol"

                            Protocols._item_type = ProtocolsItem

                            _fields: ClassVar[dict] = {
                                "destination": {"type": str},
                                "source": {"type": str},
                                "strip": {"type": bool},
                                "protocols": {"type": Protocols},
                                "_custom_data": {"type": dict},
                            }
                            destination: str
                            """Destination IP address of tunnel packets."""
                            source: str | None
                            """
                            Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                            GRE packet that matches the `destination` is terminated.
                            """
                            strip: bool | None
                            """Strip GRE encapsulation header for specific destination."""
                            protocols: Protocols
                            """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    destination: str | UndefinedType = Undefined,
                                    source: str | None | UndefinedType = Undefined,
                                    strip: bool | None | UndefinedType = Undefined,
                                    protocols: Protocols | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DestinationsItem.


                                    Subclass of AvdModel.

                                    Args:
                                        destination: Destination IP address of tunnel packets.
                                        source:
                                           Source IP address of tunnel packets. Applied only when destination is defined. When not defined; any
                                           GRE packet that matches the `destination` is terminated.
                                        strip: Strip GRE encapsulation header for specific destination.
                                        protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).
                                        _custom_data: _custom_data

                                    """

                        class Destinations(AvdIndexedList[str, DestinationsItem]):
                            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                            _primary_key: ClassVar[str] = "destination"

                        Destinations._item_type = DestinationsItem

                        _fields: ClassVar[dict] = {
                            "strip": {"type": bool},
                            "protocols": {"type": Protocols},
                            "destinations": {"type": Destinations},
                            "_custom_data": {"type": dict},
                        }
                        strip: bool | None
                        """Strip GRE encapsulation header for all GRE tunnels."""
                        protocols: Protocols
                        """
                        Protocols for all destinations; destination-specific protocols should be set under the
                        `destinations[].protocols` key.

                        Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                        is `protocol` (`str`).
                        """
                        destinations: Destinations
                        """
                        In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                        mutually exclusive.

                        Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                        `destination` (`str`).
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                strip: bool | None | UndefinedType = Undefined,
                                protocols: Protocols | UndefinedType = Undefined,
                                destinations: Destinations | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Gre.


                                Subclass of AvdModel.

                                Args:
                                    strip: Strip GRE encapsulation header for all GRE tunnels.
                                    protocols:
                                       Protocols for all destinations; destination-specific protocols should be set under the
                                       `destinations[].protocols` key.

                                       Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key
                                       is `protocol` (`str`).
                                    destinations:
                                       In EOS, `gre.strip` and `destinations.destination/source.strip` (without defining protocols) are
                                       mutually exclusive.

                                       Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is
                                       `destination` (`str`).
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"vxlan_strip": {"type": bool}, "gre": {"type": Gre}, "_custom_data": {"type": dict}}
                    vxlan_strip: bool | None
                    """
                    Strip VXLAN encapsulation header.
                    `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                    exclusive.
                    `mpls_pop_all` takes precedence.
                    """
                    gre: Gre
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            vxlan_strip: bool | None | UndefinedType = Undefined,
                            gre: Gre | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                vxlan_strip:
                                   Strip VXLAN encapsulation header.
                                   `encapsulation.vxlan_strip` and `mpls_pop_all` are mutually
                                   exclusive.
                                   `mpls_pop_all` takes precedence.
                                gre: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "allowed_vlan": {"type": str},
                    "default": {"type": Default},
                    "identity": {"type": Identity},
                    "mpls_pop_all": {"type": bool},
                    "native_vlan": {"type": int},
                    "truncation": {"type": Truncation},
                    "mac_address": {"type": MacAddress},
                    "encapsulation": {"type": Encapsulation},
                    "_custom_data": {"type": dict},
                }
                allowed_vlan: str | None
                """VLAN ID or range(s) of VLAN IDs within range 1-4094."""
                default: Default
                """
                Default tap destination config.

                Subclass of AvdModel.
                """
                identity: Identity
                """Subclass of AvdModel."""
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                native_vlan: int | None
                """Native VLAN ID when interface is in tap mode."""
                truncation: Truncation
                """Subclass of AvdModel."""
                mac_address: MacAddress
                """Subclass of AvdModel."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        default: Default | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        truncation: Truncation | UndefinedType = Undefined,
                        mac_address: MacAddress | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tap.


                        Subclass of AvdModel.

                        Args:
                            allowed_vlan: VLAN ID or range(s) of VLAN IDs within range 1-4094.
                            default:
                               Default tap destination config.

                               Subclass of AvdModel.
                            identity: Subclass of AvdModel.
                            mpls_pop_all: Pop all MPLS labels.
                            native_vlan: Native VLAN ID when interface is in tap mode.
                            truncation: Subclass of AvdModel.
                            mac_address: Subclass of AvdModel.
                            encapsulation: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Tool(AvdModel):
                """Subclass of AvdModel."""

                class Encapsulation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"dot1br_strip": {"type": bool}, "vn_tag_strip": {"type": bool}, "_custom_data": {"type": dict}}
                    dot1br_strip: bool | None
                    """Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS."""
                    vn_tag_strip: bool | None
                    """Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dot1br_strip: bool | None | UndefinedType = Undefined,
                            vn_tag_strip: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Encapsulation.


                            Subclass of AvdModel.

                            Args:
                                dot1br_strip: Remove a 802.1 BR tag in packet header. 'mpls_pop_all' takes precedence over 'dot1br_strip' in EOS.
                                vn_tag_strip: Remove a VN-tag in packet header. 'mpls_pop_all' takes precedence over 'vn_tag_strip' in EOS.
                                _custom_data: _custom_data

                            """

                class Identity(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "tag": {"type": str},
                        "dot1q_dzgre_source": {"type": str},
                        "qinq_dzgre_source": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    tag: Literal["dot1q", "qinq"] | None
                    dot1q_dzgre_source: Literal["policy", "port"] | None
                    qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            tag: Literal["dot1q", "qinq"] | None | UndefinedType = Undefined,
                            dot1q_dzgre_source: Literal["policy", "port"] | None | UndefinedType = Undefined,
                            qinq_dzgre_source: Literal["policy inner port", "port inner policy"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Identity.


                            Subclass of AvdModel.

                            Args:
                                tag: tag
                                dot1q_dzgre_source: dot1q_dzgre_source
                                qinq_dzgre_source: qinq_dzgre_source
                                _custom_data: _custom_data

                            """

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                _fields: ClassVar[dict] = {
                    "mpls_pop_all": {"type": bool},
                    "encapsulation": {"type": Encapsulation},
                    "allowed_vlan": {"type": str},
                    "identity": {"type": Identity},
                    "groups": {"type": Groups},
                    "dot1q_remove_outer_vlan_tag": {"type": str},
                    "_custom_data": {"type": dict},
                }
                mpls_pop_all: bool | None
                """Pop all MPLS labels."""
                encapsulation: Encapsulation
                """Subclass of AvdModel."""
                allowed_vlan: str | None
                """VLAN ID or range of VLAN IDs within range 1-4094."""
                identity: Identity
                """Subclass of AvdModel."""
                groups: Groups
                """
                Tool groups for the interface.

                Subclass of AvdList with `str` items.
                """
                dot1q_remove_outer_vlan_tag: str | None
                """
                Indices of vlan tags to be removed.
                Range: 1-2
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mpls_pop_all: bool | None | UndefinedType = Undefined,
                        encapsulation: Encapsulation | UndefinedType = Undefined,
                        allowed_vlan: str | None | UndefinedType = Undefined,
                        identity: Identity | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        dot1q_remove_outer_vlan_tag: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tool.


                        Subclass of AvdModel.

                        Args:
                            mpls_pop_all: Pop all MPLS labels.
                            encapsulation: Subclass of AvdModel.
                            allowed_vlan: VLAN ID or range of VLAN IDs within range 1-4094.
                            identity: Subclass of AvdModel.
                            groups:
                               Tool groups for the interface.

                               Subclass of AvdList with `str` items.
                            dot1q_remove_outer_vlan_tag:
                               Indices of vlan tags to be removed.
                               Range: 1-2
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
                "tap": {"type": Tap},
                "tool": {"type": Tool},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            """Warning: This should not be combined with `port_channel_interfaces[].type = routed`."""
            mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
            """Warning: This should not be combined with `port_channel_interfaces[].mode`"""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
            """
            trunk: Trunk
            """Subclass of AvdModel."""
            phone: Phone
            """Subclass of AvdModel."""
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `port_channel_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            """Subclass of AvdModel."""
            source_interface: Literal["tx", "tx multicast"] | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `port_channel_interfaces[].vlan_translations`.

            Subclass of AvdModel.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            """Subclass of AvdModel."""
            backup: Backup
            """
            The `backup_link` is required for this setting.

            Subclass of AvdModel.
            """
            port_security: PortSecurity
            """Subclass of AvdModel."""
            tap: Tap
            """
            In tap mode, the interface operates as a tap port.
            Tap ports receive traffic for replication on one
            or more tool ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            tool: Tool
            """
            In tool mode, the interface operates as a tool port.
            Tool ports replicate traffic received by tap
            ports.
            This setting applies only to parent interfaces.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                    access_vlan: int | None | UndefinedType = Undefined,
                    trunk: Trunk | UndefinedType = Undefined,
                    phone: Phone | UndefinedType = Undefined,
                    pvlan_mapping: str | None | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    source_interface: Literal["tx", "tx multicast"] | None | UndefinedType = Undefined,
                    vlan_translations: VlanTranslations | UndefinedType = Undefined,
                    vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                    backup_link: BackupLink | UndefinedType = Undefined,
                    backup: Backup | UndefinedType = Undefined,
                    port_security: PortSecurity | UndefinedType = Undefined,
                    tap: Tap | UndefinedType = Undefined,
                    tool: Tool | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Switchport.


                    Subclass of AvdModel.

                    Args:
                        enabled: Warning: This should not be combined with `port_channel_interfaces[].type = routed`.
                        mode: Warning: This should not be combined with `port_channel_interfaces[].mode`
                        access_vlan:
                           Set VLAN when interface is in access mode.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
                        trunk: Subclass of AvdModel.
                        phone: Subclass of AvdModel.
                        pvlan_mapping:
                           Secondary VLAN IDs of the private VLAN mapping.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].pvlan_mapping`.
                        dot1q: Subclass of AvdModel.
                        source_interface:
                           tx: Allow bridged traffic to go out of the source interface.
                           tx multicast: Allow multicast traffic
                           only to go out of the source interface.
                        vlan_translations:
                           VLAN Translation mappings.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].vlan_translations`.

                           Subclass of AvdModel.
                        vlan_forwarding_accept_all: vlan_forwarding_accept_all
                        backup_link: Subclass of AvdModel.
                        backup:
                           The `backup_link` is required for this setting.

                           Subclass of AvdModel.
                        port_security: Subclass of AvdModel.
                        tap:
                           In tap mode, the interface operates as a tap port.
                           Tap ports receive traffic for replication on one
                           or more tool ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        tool:
                           In tool mode, the interface operates as a tool port.
                           Tool ports replicate traffic received by tap
                           ports.
                           This setting applies only to parent interfaces.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TrafficEngineering(AvdModel):
            """Subclass of AvdModel."""

            class AdministrativeGroups(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            AdministrativeGroups._item_type = str

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_groups": {"type": AdministrativeGroups}, "_custom_data": {"type": dict}}
            enabled: bool | None
            """Whether to enable traffic-engineering on this interface."""
            administrative_groups: AdministrativeGroups
            """
            List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
            integers 0-127.

            Subclass of AvdList with `str` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    administrative_groups: AdministrativeGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficEngineering.


                    Subclass of AvdModel.

                    Args:
                        enabled: Whether to enable traffic-engineering on this interface.
                        administrative_groups:
                           List of traffic-engineering administrative groups, valid values are names, ranges 0-127, or single
                           integers 0-127.

                           Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "profile": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "snmp_trap_link_change": {"type": bool},
            "type": {"type": str},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "vrf": {"type": str},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "mode": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "link_tracking": {"type": LinkTracking},
            "phone": {"type": Phone},
            "l2_protocol": {"type": L2Protocol},
            "mtu": {"type": int},
            "mlag": {"type": int},
            "trunk_groups": {"type": TrunkGroups},
            "lacp_fallback_timeout": {"type": int},
            "min_links": {"type": int},
            "lacp_fallback_mode": {"type": str},
            "qos": {"type": Qos},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": VlanTranslations},
            "shape": {"type": Shape},
            "storm_control": {"type": StormControl},
            "ip_proxy_arp": {"type": bool},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "isis_authentication": {"type": IsisAuthentication},
            "traffic_policy": {"type": TrafficPolicy},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "lacp_id": {"type": str},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "ptp": {"type": Ptp},
            "ip_address": {"type": str},
            "dhcp_client_accept_default_route": {"type": bool},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "pim": {"type": Pim},
            "service_profile": {"type": str},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "flow_tracker": {"type": FlowTracker},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "switchport": {"type": Switchport},
            "traffic_engineering": {"type": TrafficEngineering},
            "validate_state": {"type": bool},
            "validate_lldp": {"type": bool},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        description: str | None
        profile: str | None
        """Interface profile."""
        logging: Logging
        """Subclass of AvdModel."""
        shutdown: bool | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        snmp_trap_link_change: bool | None
        type: Literal["routed", "switched", "l3dot1q", "l2dot1q"] | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        Interface will not be listed in device documentation, unless "type" is set.
        """
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.

        Subclass of AvdModel.
        """
        vrf: str | None
        """VRF name."""
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        Subclass of AvdModel.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None
        native_vlan: int | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        link_tracking_groups: LinkTrackingGroups
        """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
        link_tracking: LinkTracking
        """Subclass of AvdModel."""
        phone: Phone
        """Subclass of AvdModel."""
        l2_protocol: L2Protocol
        """Subclass of AvdModel."""
        mtu: int | None
        mlag: int | None
        """MLAG ID."""
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        lacp_fallback_timeout: int | None
        """Timeout in seconds. EOS default is 90 seconds."""
        min_links: int | None
        """
        Minimum number of ports required up before bringing up a port-channel.
        Maximum in `min_links` is
        hardware dependent.
        """
        lacp_fallback_mode: Literal["individual", "static"] | None
        qos: Qos
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        mpls: Mpls
        """Subclass of AvdModel."""
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: VlanTranslations
        """Subclass of AvdList with `VlanTranslationsItem` items."""
        shape: Shape
        """Subclass of AvdModel."""
        storm_control: StormControl
        """Subclass of AvdModel."""
        ip_proxy_arp: bool | None
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None
        isis_hello_padding: bool | None
        isis_authentication_mode: Literal["text", "md5"] | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        isis_authentication: IsisAuthentication
        """
        This key should not be mixed with port_channel_interfaces[].isis_authentication_mode or
        ethernet_interfaces[].isis_authentication_key.

        Subclass of AvdModel.
        """
        traffic_policy: TrafficPolicy
        """Subclass of AvdModel."""
        evpn_ethernet_segment: EvpnEthernetSegment
        """Subclass of AvdModel."""
        lacp_id: str | None
        """LACP ID with format xxxx.xxxx.xxxx."""
        spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None
        spanning_tree_guard: Literal["loop", "root", "disabled"] | None
        spanning_tree_portfast: Literal["edge", "network"] | None
        vmtracer: bool | None
        ptp: Ptp
        """Subclass of AvdModel."""
        ip_address: str | None
        """IPv4 address/mask or "dhcp"."""
        dhcp_client_accept_default_route: bool | None
        """Install default-route obtained via DHCP."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        ip_nat: IpNat
        """Subclass of AvdModel."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6 address/mask."""
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        pim: Pim
        """Subclass of AvdModel."""
        service_profile: str | None
        """QOS profile."""
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""
        flow_tracker: FlowTracker
        """Subclass of AvdModel."""
        bgp: Bgp
        """Subclass of AvdModel."""
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        """Subclass of AvdModel."""
        switchport: Switchport
        """Subclass of AvdModel."""
        traffic_engineering: TrafficEngineering
        """Subclass of AvdModel."""
        validate_state: bool | None
        """
        Set to false to disable interface state and LLDP topology validation performed by the
        `eos_validate_state` role.
        """
        validate_lldp: bool | None
        """Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                l2_mtu: int | None | UndefinedType = Undefined,
                l2_mru: int | None | UndefinedType = Undefined,
                vlans: str | None | UndefinedType = Undefined,
                snmp_trap_link_change: bool | None | UndefinedType = Undefined,
                type: Literal["routed", "switched", "l3dot1q", "l2dot1q"] | None | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                vlan_id: int | None | UndefinedType = Undefined,
                mode: Literal["access", "dot1q-tunnel", "trunk", "trunk phone"] | None | UndefinedType = Undefined,
                native_vlan: int | None | UndefinedType = Undefined,
                native_vlan_tag: bool | None | UndefinedType = Undefined,
                link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
                link_tracking: LinkTracking | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                l2_protocol: L2Protocol | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                mlag: int | None | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                lacp_fallback_timeout: int | None | UndefinedType = Undefined,
                min_links: int | None | UndefinedType = Undefined,
                lacp_fallback_mode: Literal["individual", "static"] | None | UndefinedType = Undefined,
                qos: Qos | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                storm_control: StormControl | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_circuit_type: Literal["level-1-2", "level-1", "level-2"] | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_authentication_mode: Literal["text", "md5"] | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                traffic_policy: TrafficPolicy | UndefinedType = Undefined,
                evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                lacp_id: str | None | UndefinedType = Undefined,
                spanning_tree_bpdufilter: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_bpduguard: Literal["enabled", "disabled", "True", "False", "true", "false"] | None | UndefinedType = Undefined,
                spanning_tree_guard: Literal["loop", "root", "disabled"] | None | UndefinedType = Undefined,
                spanning_tree_portfast: Literal["edge", "network"] | None | UndefinedType = Undefined,
                vmtracer: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                dhcp_client_accept_default_route: bool | None | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                mac_access_group_in: str | None | UndefinedType = Undefined,
                mac_access_group_out: str | None | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                service_profile: str | None | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                flow_tracker: FlowTracker | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                peer_interface: str | None | UndefinedType = Undefined,
                peer_type: str | None | UndefinedType = Undefined,
                sflow: Sflow | UndefinedType = Undefined,
                switchport: Switchport | UndefinedType = Undefined,
                traffic_engineering: TrafficEngineering | UndefinedType = Undefined,
                validate_state: bool | None | UndefinedType = Undefined,
                validate_lldp: bool | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PortChannelInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: name
                    description: description
                    profile: Interface profile.
                    logging: Subclass of AvdModel.
                    shutdown: shutdown
                    l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                    l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                    vlans:
                       List of switchport vlans as string.
                       For a trunk port this would be a range like "1-200,300".
                       For an
                       access port this would be a single vlan "123".
                    snmp_trap_link_change: snmp_trap_link_change
                    type:
                       l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                       Interface will not be listed in device documentation, unless "type" is set.
                    encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                    encapsulation_dot1q:
                       Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                       `ethernet_interfaces[].type: l2dot1q`.

                       Subclass of AvdModel.
                    vrf: VRF name.
                    encapsulation_vlan:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `encapsulation_vlan` should not
                       be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                       Subclass of AvdModel.
                    vlan_id:
                       This setting can only be applied to sub-interfaces on EOS.
                       Warning: `vlan_id` should not be combined
                       with `ethernet_interfaces[].type == l2dot1q`.
                    mode: mode
                    native_vlan: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                    link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                    link_tracking: Subclass of AvdModel.
                    phone: Subclass of AvdModel.
                    l2_protocol: Subclass of AvdModel.
                    mtu: mtu
                    mlag: MLAG ID.
                    trunk_groups: Subclass of AvdList with `str` items.
                    lacp_fallback_timeout: Timeout in seconds. EOS default is 90 seconds.
                    min_links:
                       Minimum number of ports required up before bringing up a port-channel.
                       Maximum in `min_links` is
                       hardware dependent.
                    lacp_fallback_mode: lacp_fallback_mode
                    qos: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    mpls: Subclass of AvdModel.
                    trunk_private_vlan_secondary: trunk_private_vlan_secondary
                    pvlan_mapping: List of vlans as string.
                    vlan_translations: Subclass of AvdList with `VlanTranslationsItem` items.
                    shape: Subclass of AvdModel.
                    storm_control: Subclass of AvdModel.
                    ip_proxy_arp: ip_proxy_arp
                    isis_enable: ISIS instance.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_circuit_type: isis_circuit_type
                    isis_hello_padding: isis_hello_padding
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    isis_authentication:
                       This key should not be mixed with port_channel_interfaces[].isis_authentication_mode or
                       ethernet_interfaces[].isis_authentication_key.

                       Subclass of AvdModel.
                    traffic_policy: Subclass of AvdModel.
                    evpn_ethernet_segment: Subclass of AvdModel.
                    lacp_id: LACP ID with format xxxx.xxxx.xxxx.
                    spanning_tree_bpdufilter: spanning_tree_bpdufilter
                    spanning_tree_bpduguard: spanning_tree_bpduguard
                    spanning_tree_guard: spanning_tree_guard
                    spanning_tree_portfast: spanning_tree_portfast
                    vmtracer: vmtracer
                    ptp: Subclass of AvdModel.
                    ip_address: IPv4 address/mask or "dhcp".
                    dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    ip_nat: Subclass of AvdModel.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6 address/mask.
                    ipv6_address_link_local: Link local IPv6 address/mask.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    access_group_in: Access list name.
                    access_group_out: Access list name.
                    ipv6_access_group_in: IPv6 access list name.
                    ipv6_access_group_out: IPv6 access list name.
                    mac_access_group_in: MAC access list name.
                    mac_access_group_out: MAC access list name.
                    pim: Subclass of AvdModel.
                    service_profile: QOS profile.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ospf_area: ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password.
                    ospf_message_digest_keys: Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    flow_tracker: Subclass of AvdModel.
                    bgp: Subclass of AvdModel.
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    peer: Key only used for documentation or validation purposes.
                    peer_interface: Key only used for documentation or validation purposes.
                    peer_type: Key only used for documentation or validation purposes.
                    sflow: Subclass of AvdModel.
                    switchport: Subclass of AvdModel.
                    traffic_engineering: Subclass of AvdModel.
                    validate_state:
                       Set to false to disable interface state and LLDP topology validation performed by the
                       `eos_validate_state` role.
                    validate_lldp: Set to false to disable the LLDP topology validation performed by the `eos_validate_state` role.
                    eos_cli: Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class PortChannelInterfaces(AvdIndexedList[str, PortChannelInterfacesItem]):
        """Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PortChannelInterfaces._item_type = PortChannelInterfacesItem

    class PrefixListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 10.255.0.0/27 eq 32"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "permit 10.255.0.0/27 eq 32"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PrefixListsItem.


                Subclass of AvdModel.

                Args:
                    name: Prefix-list Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class PrefixLists(AvdIndexedList[str, PrefixListsItem]):
        """Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    PrefixLists._item_type = PrefixListsItem

    class PriorityFlowControl(AvdModel):
        """Subclass of AvdModel."""

        class Watchdog(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "action": {"type": str},
                "timeout": {"type": str},
                "polling_interval": {"type": str},
                "recovery_time": {"type": str},
                "override_action_drop": {"type": bool},
                "_custom_data": {"type": dict},
            }
            action: Literal["drop", "no-drop"] | None
            """Action on stuck queue."""
            timeout: str | None
            """
            Timeout in seconds after which port should be errdisabled or
            should start dropping on congested
            priorities.
            This should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            polling_interval: str | None
            """
            Time interval in seconds at which the watchdog should poll the queues.
            This should be decimal with
            up to 3 decimal point.
            Example: 0.005 or 60
            """
            recovery_time: str | None
            """
            Recovery-time in seconds after which stuck queue should
            recover and start forwarding again.
            This
            should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            override_action_drop: bool | None
            """Override configured action on stuck queue to drop."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    action: Literal["drop", "no-drop"] | None | UndefinedType = Undefined,
                    timeout: str | None | UndefinedType = Undefined,
                    polling_interval: str | None | UndefinedType = Undefined,
                    recovery_time: str | None | UndefinedType = Undefined,
                    override_action_drop: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Watchdog.


                    Subclass of AvdModel.

                    Args:
                        action: Action on stuck queue.
                        timeout:
                           Timeout in seconds after which port should be errdisabled or
                           should start dropping on congested
                           priorities.
                           This should be decimal with up to 2 decimal point.
                           Example: 0.01 or 60
                        polling_interval:
                           Time interval in seconds at which the watchdog should poll the queues.
                           This should be decimal with
                           up to 3 decimal point.
                           Example: 0.005 or 60
                        recovery_time:
                           Recovery-time in seconds after which stuck queue should
                           recover and start forwarding again.
                           This
                           should be decimal with up to 2 decimal point.
                           Example: 0.01 or 60
                        override_action_drop: Override configured action on stuck queue to drop.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"all_off": {"type": bool}, "watchdog": {"type": Watchdog}, "_custom_data": {"type": dict}}
        all_off: bool | None
        """Disable PFC on all interfaces."""
        watchdog: Watchdog
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                all_off: bool | None | UndefinedType = Undefined,
                watchdog: Watchdog | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                PriorityFlowControl.


                Subclass of AvdModel.

                Args:
                    all_off: Disable PFC on all interfaces.
                    watchdog: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Ptp(AvdModel):
        """Subclass of AvdModel."""

        class Source(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip": {"type": str}, "_custom_data": {"type": dict}}
            ip: str | None
            """Source IP."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ip: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Source.


                    Subclass of AvdModel.

                    Args:
                        ip: Source IP.
                        _custom_data: _custom_data

                    """

        class MessageType(AvdModel):
            """Subclass of AvdModel."""

            class General(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"dscp": {"type": int}, "_custom_data": {"type": dict}}
                dscp: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, dscp: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        General.


                        Subclass of AvdModel.

                        Args:
                            dscp: dscp
                            _custom_data: _custom_data

                        """

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"dscp": {"type": int}, "_custom_data": {"type": dict}}
                dscp: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, dscp: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            dscp: dscp
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"general": {"type": General}, "event": {"type": Event}, "_custom_data": {"type": dict}}
            general: General
            """Subclass of AvdModel."""
            event: Event
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    general: General | UndefinedType = Undefined,
                    event: Event | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MessageType.


                    Subclass of AvdModel.

                    Args:
                        general: Subclass of AvdModel.
                        event: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Monitor(AvdModel):
            """Subclass of AvdModel."""

            class Threshold(AvdModel):
                """Subclass of AvdModel."""

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"offset_from_master": {"type": int}, "mean_path_delay": {"type": int}, "_custom_data": {"type": dict}}
                    offset_from_master: int | None
                    mean_path_delay: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            offset_from_master: int | None | UndefinedType = Undefined,
                            mean_path_delay: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                offset_from_master: offset_from_master
                                mean_path_delay: mean_path_delay
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "offset_from_master": {"type": int},
                    "mean_path_delay": {"type": int},
                    "drop": {"type": Drop},
                    "_custom_data": {"type": dict},
                }
                offset_from_master: int | None
                mean_path_delay: int | None
                drop: Drop
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        offset_from_master: int | None | UndefinedType = Undefined,
                        mean_path_delay: int | None | UndefinedType = Undefined,
                        drop: Drop | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Threshold.


                        Subclass of AvdModel.

                        Args:
                            offset_from_master: offset_from_master
                            mean_path_delay: mean_path_delay
                            drop: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class MissingMessage(AvdModel):
                """Subclass of AvdModel."""

                class Intervals(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"announce": {"type": int}, "follow_up": {"type": int}, "sync": {"type": int}, "_custom_data": {"type": dict}}
                    announce: int | None
                    follow_up: int | None
                    sync: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            announce: int | None | UndefinedType = Undefined,
                            follow_up: int | None | UndefinedType = Undefined,
                            sync: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Intervals.


                            Subclass of AvdModel.

                            Args:
                                announce: announce
                                follow_up: follow_up
                                sync: sync
                                _custom_data: _custom_data

                            """

                class SequenceIds(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "announce": {"type": int},
                        "delay_resp": {"type": int},
                        "follow_up": {"type": int},
                        "sync": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    announce: int | None
                    delay_resp: int | None
                    follow_up: int | None
                    sync: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            announce: int | None | UndefinedType = Undefined,
                            delay_resp: int | None | UndefinedType = Undefined,
                            follow_up: int | None | UndefinedType = Undefined,
                            sync: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SequenceIds.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                announce: announce
                                delay_resp: delay_resp
                                follow_up: follow_up
                                sync: sync
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"intervals": {"type": Intervals}, "sequence_ids": {"type": SequenceIds}, "_custom_data": {"type": dict}}
                intervals: Intervals
                """Subclass of AvdModel."""
                sequence_ids: SequenceIds
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        intervals: Intervals | UndefinedType = Undefined,
                        sequence_ids: SequenceIds | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingMessage.


                        Subclass of AvdModel.

                        Args:
                            intervals: Subclass of AvdModel.
                            sequence_ids: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool, "default": True},
                "threshold": {"type": Threshold},
                "missing_message": {"type": MissingMessage},
                "_custom_data": {"type": dict},
            }
            enabled: bool
            """Default value: `True`"""
            threshold: Threshold
            """Subclass of AvdModel."""
            missing_message: MissingMessage
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    threshold: Threshold | UndefinedType = Undefined,
                    missing_message: MissingMessage | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Monitor.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        threshold: Subclass of AvdModel.
                        missing_message: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "mode": {"type": str},
            "profile": {"type": str},
            "mode_one_step": {"type": bool},
            "forward_unicast": {"type": bool},
            "clock_identity": {"type": str},
            "source": {"type": Source},
            "priority1": {"type": int},
            "priority2": {"type": int},
            "ttl": {"type": int},
            "domain": {"type": int},
            "message_type": {"type": MessageType},
            "monitor": {"type": Monitor},
            "_custom_data": {"type": dict},
        }
        mode: Literal["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"] | None
        profile: Literal["g8275.1", "g8275.2"] | None
        mode_one_step: bool | None
        forward_unicast: bool | None
        clock_identity: str | None
        """The clock-id in xx:xx:xx:xx:xx:xx format."""
        source: Source
        """Subclass of AvdModel."""
        priority1: int | None
        priority2: int | None
        ttl: int | None
        domain: int | None
        message_type: MessageType
        """Subclass of AvdModel."""
        monitor: Monitor
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mode: Literal["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"] | None | UndefinedType = Undefined,
                profile: Literal["g8275.1", "g8275.2"] | None | UndefinedType = Undefined,
                mode_one_step: bool | None | UndefinedType = Undefined,
                forward_unicast: bool | None | UndefinedType = Undefined,
                clock_identity: str | None | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
                priority1: int | None | UndefinedType = Undefined,
                priority2: int | None | UndefinedType = Undefined,
                ttl: int | None | UndefinedType = Undefined,
                domain: int | None | UndefinedType = Undefined,
                message_type: MessageType | UndefinedType = Undefined,
                monitor: Monitor | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.


                Subclass of AvdModel.

                Args:
                    mode: mode
                    profile: profile
                    mode_one_step: mode_one_step
                    forward_unicast: forward_unicast
                    clock_identity: The clock-id in xx:xx:xx:xx:xx:xx format.
                    source: Subclass of AvdModel.
                    priority1: priority1
                    priority2: priority2
                    ttl: ttl
                    domain: domain
                    message_type: Subclass of AvdModel.
                    monitor: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class Qos(AvdModel):
        """Subclass of AvdModel."""

        class Map(AvdModel):
            """Subclass of AvdModel."""

            class Cos(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Cos._item_type = str

            class Dscp(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Dscp._item_type = str

            class Exp(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Exp._item_type = str

            class TrafficClass(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            TrafficClass._item_type = str

            _fields: ClassVar[dict] = {
                "cos": {"type": Cos},
                "dscp": {"type": Dscp},
                "exp": {"type": Exp},
                "traffic_class": {"type": TrafficClass},
                "_custom_data": {"type": dict},
            }
            cos: Cos
            """Subclass of AvdList with `str` items."""
            dscp: Dscp
            """Subclass of AvdList with `str` items."""
            exp: Exp
            """Subclass of AvdList with `str` items."""
            traffic_class: TrafficClass
            """Subclass of AvdList with `str` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    cos: Cos | UndefinedType = Undefined,
                    dscp: Dscp | UndefinedType = Undefined,
                    exp: Exp | UndefinedType = Undefined,
                    traffic_class: TrafficClass | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Map.


                    Subclass of AvdModel.

                    Args:
                        cos: Subclass of AvdList with `str` items.
                        dscp: Subclass of AvdList with `str` items.
                        exp: Subclass of AvdList with `str` items.
                        traffic_class: Subclass of AvdList with `str` items.
                        _custom_data: _custom_data

                    """

        class RandomDetect(AvdModel):
            """Subclass of AvdModel."""

            class Ecn(AvdModel):
                """Subclass of AvdModel."""

                class AllowNonEct(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "chip_based": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    """
                    Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                    Check which command is
                    required for your platform.
                    """
                    chip_based: bool | None
                    """Allow non-ect chip-based."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            chip_based: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AllowNonEct.


                            Subclass of AvdModel.

                            Args:
                                enabled:
                                   Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                                   Check which command is
                                   required for your platform.
                                chip_based: Allow non-ect chip-based.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"allow_non_ect": {"type": AllowNonEct}, "_custom_data": {"type": dict}}
                allow_non_ect: AllowNonEct
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, allow_non_ect: AllowNonEct | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Ecn.


                        Subclass of AvdModel.

                        Args:
                            allow_non_ect: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "_custom_data": {"type": dict}}
            ecn: Ecn
            """
            Global ECN Configuration.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ecn: Ecn | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    RandomDetect.


                    Subclass of AvdModel.

                    Args:
                        ecn:
                           Global ECN Configuration.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "map": {"type": Map},
            "rewrite_dscp": {"type": bool},
            "random_detect": {"type": RandomDetect},
            "_custom_data": {"type": dict},
        }
        map: Map
        """Subclass of AvdModel."""
        rewrite_dscp: bool | None
        random_detect: RandomDetect
        """
        Global random-detect settings.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                map: Map | UndefinedType = Undefined,
                rewrite_dscp: bool | None | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Qos.


                Subclass of AvdModel.

                Args:
                    map: Subclass of AvdModel.
                    rewrite_dscp: rewrite_dscp
                    random_detect:
                       Global random-detect settings.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class QosProfilesItem(AvdModel):
        """Subclass of AvdModel."""

        class Shape(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
            rate: str | None
            """
            Supported options are platform dependent.
            Example: "< rate > kbps", "1-100 percent", "< rate > pps"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Shape.


                    Subclass of AvdModel.

                    Args:
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                        _custom_data: _custom_data

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Type(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"qos_input": {"type": str}, "_custom_data": {"type": dict}}
                qos_input: str | None
                """Policy-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, qos_input: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Type.


                        Subclass of AvdModel.

                        Args:
                            qos_input: Policy-map name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"type": {"type": Type}, "_custom_data": {"type": dict}}
            type: Type
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, type: Type | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        type: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                            _custom_data: _custom_data

                        """

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """
                        Units to be used for the threshold values.
                        This should be one of segments, byte, kbytes, mbytes.
                        """
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units:
                                       Units to be used for the threshold values.
                                       This should be one of segments, byte, kbytes, mbytes.
                                    min: Random-detect ECN minimum-threshold.
                                    max: Random-detect ECN maximum-threshold.
                                    max_probability: Random-detect ECN maximum mark probability.
                                    weight: Random-detect ECN weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: bool | None | UndefinedType = Undefined,
                            threshold: Threshold | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"] | UndefinedType = Undefined,
                                drop_precedence: int | None | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                drop_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Units to be used for the threshold values.
                                    drop_precedence: Specify Drop Precedence value.
                                    min: WRED minimum-threshold.
                                    max: WRED maximum-threshold.
                                    drop_probability: WRED drop probability.
                                    weight: WRED weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, threshold: Threshold | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "drop": {"type": Drop}, "_custom_data": {"type": dict}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                drop: Drop
                """
                Set WRED parameters.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ecn: Ecn | UndefinedType = Undefined,
                        drop: Drop | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            drop:
                               Set WRED parameters.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
                "_custom_data": {"type": dict},
            }
            id: int
            """TX-Queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: TX-Queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.
                        random_detect: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class TxQueues(AvdIndexedList[int, TxQueuesItem]):
            """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class UcTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                            _custom_data: _custom_data

                        """

            class RandomDetect(AvdModel):
                """Subclass of AvdModel."""

                class Ecn(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"]
                        """Unit to be used for the threshold values."""
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "milliseconds"] | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                max_probability: int | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Unit to be used for the threshold values.
                                    min: Random-detect ECN minimum-threshold.
                                    max: Random-detect ECN maximum-threshold.
                                    max_probability: Random-detect ECN maximum mark probability.
                                    weight: Random-detect ECN weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"count": {"type": bool}, "threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: bool | None | UndefinedType = Undefined,
                            threshold: Threshold | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ecn.


                            Subclass of AvdModel.

                            Args:
                                count: Enable counter for random-detect ECNs.
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Drop(AvdModel):
                    """Subclass of AvdModel."""

                    class Threshold(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                units: Literal["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"] | UndefinedType = Undefined,
                                drop_precedence: int | None | UndefinedType = Undefined,
                                min: int | UndefinedType = Undefined,
                                max: int | UndefinedType = Undefined,
                                drop_probability: int | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Threshold.


                                Subclass of AvdModel.

                                Args:
                                    units: Units to be used for the threshold values.
                                    drop_precedence: Specify Drop Precedence value.
                                    min: WRED minimum-threshold.
                                    max: WRED maximum-threshold.
                                    drop_probability: WRED drop probability.
                                    weight: WRED weight.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                    threshold: Threshold
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, threshold: Threshold | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Drop.


                            Subclass of AvdModel.

                            Args:
                                threshold: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ecn": {"type": Ecn}, "drop": {"type": Drop}, "_custom_data": {"type": dict}}
                ecn: Ecn
                """
                Explicit Congestion Notification.

                Subclass of AvdModel.
                """
                drop: Drop
                """
                Set WRED parameters.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ecn: Ecn | UndefinedType = Undefined,
                        drop: Drop | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RandomDetect.


                        Subclass of AvdModel.

                        Args:
                            ecn:
                               Explicit Congestion Notification.

                               Subclass of AvdModel.
                            drop:
                               Set WRED parameters.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
                "_custom_data": {"type": dict},
            }
            id: int
            """UC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                    random_detect: RandomDetect | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    UcTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: UC TX queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.
                        random_detect: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class UcTxQueues(AvdIndexedList[int, UcTxQueuesItem]):
            """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class McTxQueuesItem(AvdModel):
            """Subclass of AvdModel."""

            class Shape(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate": {"type": str}, "_custom_data": {"type": dict}}
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, rate: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Shape.


                        Subclass of AvdModel.

                        Args:
                            rate:
                               Supported options are platform dependent.
                               Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "_custom_data": {"type": dict},
            }
            id: int
            """MC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: Literal["priority strict", "no priority"] | None
            shape: Shape
            """Subclass of AvdModel."""
            comment: str | None
            """Text comment added to queue."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    bandwidth_percent: int | None | UndefinedType = Undefined,
                    bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                    priority: Literal["priority strict", "no priority"] | None | UndefinedType = Undefined,
                    shape: Shape | UndefinedType = Undefined,
                    comment: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    McTxQueuesItem.


                    Subclass of AvdModel.

                    Args:
                        id: MC TX queue ID.
                        bandwidth_percent: bandwidth_percent
                        bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                        priority: priority
                        shape: Subclass of AvdModel.
                        comment: Text comment added to queue.
                        _custom_data: _custom_data

                    """

        class McTxQueues(AvdIndexedList[int, McTxQueuesItem]):
            """Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        McTxQueues._item_type = McTxQueuesItem

        class PriorityFlowControl(AvdModel):
            """Subclass of AvdModel."""

            class Watchdog(AvdModel):
                """Subclass of AvdModel."""

                class Timer(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "timeout": {"type": str},
                        "polling_interval": {"type": str},
                        "recovery_time": {"type": str},
                        "forced": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    timeout: str
                    """
                    Timeout in seconds after which port should be errdisabled or
                    should start dropping on congested
                    priorities.
                    This should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    polling_interval: str
                    """
                    Time interval in seconds at which the watchdog should poll the queues.
                    This should be decimal with
                    up to 3 decimal point or set
                    to 'auto' based on recovery_time and timeout values.
                    Example: 0.005 or
                    60
                    """
                    recovery_time: str
                    """
                    Recovery-time in seconds after which stuck queue should
                    recover and start forwarding again.
                    This
                    should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    forced: bool | None
                    """
                    Force recover any stuck queue(s) after the duration,
                    irrespective of whether PFC frames are being
                    received or not.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            timeout: str | UndefinedType = Undefined,
                            polling_interval: str | UndefinedType = Undefined,
                            recovery_time: str | UndefinedType = Undefined,
                            forced: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Timer.


                            Subclass of AvdModel.

                            Args:
                                timeout:
                                   Timeout in seconds after which port should be errdisabled or
                                   should start dropping on congested
                                   priorities.
                                   This should be decimal with up to 2 decimal point.
                                   Example: 0.01 or 60
                                polling_interval:
                                   Time interval in seconds at which the watchdog should poll the queues.
                                   This should be decimal with
                                   up to 3 decimal point or set
                                   to 'auto' based on recovery_time and timeout values.
                                   Example: 0.005 or
                                   60
                                recovery_time:
                                   Recovery-time in seconds after which stuck queue should
                                   recover and start forwarding again.
                                   This
                                   should be decimal with up to 2 decimal point.
                                   Example: 0.01 or 60
                                forced:
                                   Force recover any stuck queue(s) after the duration,
                                   irrespective of whether PFC frames are being
                                   received or not.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "action": {"type": str}, "timer": {"type": Timer}, "_custom_data": {"type": dict}}
                enabled: bool
                """Enable the watchdog on stuck transmit queues."""
                action: Literal["drop", "notify-only"] | None
                """
                Override the default error-disable action to either drop
                traffic on the stuck queue or notify-only
                without making any actions on the stuck queue.
                """
                timer: Timer
                """
                Timer thresholds whilst monitoring queues.


                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        action: Literal["drop", "notify-only"] | None | UndefinedType = Undefined,
                        timer: Timer | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Watchdog.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable the watchdog on stuck transmit queues.
                            action:
                               Override the default error-disable action to either drop
                               traffic on the stuck queue or notify-only
                               without making any actions on the stuck queue.
                            timer:
                               Timer thresholds whilst monitoring queues.


                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PrioritiesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"priority": {"type": int}, "no_drop": {"type": bool}, "_custom_data": {"type": dict}}
                priority: int
                """Priority queue number (COS value)."""
                no_drop: bool
                """Enable Priority Flow Control frames on this queue."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        priority: int | UndefinedType = Undefined,
                        no_drop: bool | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PrioritiesItem.


                        Subclass of AvdModel.

                        Args:
                            priority: Priority queue number (COS value).
                            no_drop: Enable Priority Flow Control frames on this queue.
                            _custom_data: _custom_data

                        """

            class Priorities(AvdIndexedList[int, PrioritiesItem]):
                """Subclass of AvdIndexedList with `PrioritiesItem` items. Primary key is `priority` (`int`)."""

                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "watchdog": {"type": Watchdog},
                "priorities": {"type": Priorities},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            """Enable Priority Flow control."""
            watchdog: Watchdog
            """
            Watchdog can detect stuck transmit queues.


            Subclass of AvdModel.
            """
            priorities: Priorities
            """
            Set the drop/no_drop on each queue.


            Subclass of AvdIndexedList with `PrioritiesItem` items.
            Primary key is `priority` (`int`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    watchdog: Watchdog | UndefinedType = Undefined,
                    priorities: Priorities | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PriorityFlowControl.


                    Subclass of AvdModel.

                    Args:
                        enabled: Enable Priority Flow control.
                        watchdog:
                           Watchdog can detect stuck transmit queues.


                           Subclass of AvdModel.
                        priorities:
                           Set the drop/no_drop on each queue.


                           Subclass of AvdIndexedList with `PrioritiesItem` items.
                           Primary key is `priority` (`int`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "trust": {"type": str},
            "cos": {"type": int},
            "dscp": {"type": int},
            "shape": {"type": Shape},
            "service_policy": {"type": ServicePolicy},
            "tx_queues": {"type": TxQueues},
            "uc_tx_queues": {"type": UcTxQueues},
            "mc_tx_queues": {"type": McTxQueues},
            "priority_flow_control": {"type": PriorityFlowControl},
            "_custom_data": {"type": dict},
        }
        name: str
        """Profile-Name."""
        trust: Literal["cos", "dscp", "disabled"] | None
        cos: int | None
        dscp: int | None
        shape: Shape
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        tx_queues: TxQueues
        """Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`)."""
        uc_tx_queues: UcTxQueues
        """Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`)."""
        mc_tx_queues: McTxQueues
        """Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`)."""
        priority_flow_control: PriorityFlowControl
        """
        Priority Flow Control settings.


        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                trust: Literal["cos", "dscp", "disabled"] | None | UndefinedType = Undefined,
                cos: int | None | UndefinedType = Undefined,
                dscp: int | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                tx_queues: TxQueues | UndefinedType = Undefined,
                uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
                mc_tx_queues: McTxQueues | UndefinedType = Undefined,
                priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                QosProfilesItem.


                Subclass of AvdModel.

                Args:
                    name: Profile-Name.
                    trust: trust
                    cos: cos
                    dscp: dscp
                    shape: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    tx_queues: Subclass of AvdIndexedList with `TxQueuesItem` items. Primary key is `id` (`int`).
                    uc_tx_queues: Subclass of AvdIndexedList with `UcTxQueuesItem` items. Primary key is `id` (`int`).
                    mc_tx_queues: Subclass of AvdIndexedList with `McTxQueuesItem` items. Primary key is `id` (`int`).
                    priority_flow_control:
                       Priority Flow Control settings.


                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class QosProfiles(AvdIndexedList[str, QosProfilesItem]):
        """Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    QosProfiles._item_type = QosProfilesItem

    class QueueMonitorLength(AvdModel):
        """Subclass of AvdModel."""

        class DefaultThresholds(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"high": {"type": int}, "low": {"type": int}, "_custom_data": {"type": dict}}
            high: int
            """Default high threshold for Ethernet Interfaces."""
            low: int | None
            """
            Default low threshold for Ethernet Interfaces.
            Low threshold support is platform dependent.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    high: int | UndefinedType = Undefined,
                    low: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultThresholds.


                    Subclass of AvdModel.

                    Args:
                        high: Default high threshold for Ethernet Interfaces.
                        low:
                           Default low threshold for Ethernet Interfaces.
                           Low threshold support is platform dependent.
                        _custom_data: _custom_data

                    """

        class Cpu(AvdModel):
            """Subclass of AvdModel."""

            class Thresholds(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"high": {"type": int}, "low": {"type": int}, "_custom_data": {"type": dict}}
                high: int
                low: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        high: int | UndefinedType = Undefined,
                        low: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Thresholds.


                        Subclass of AvdModel.

                        Args:
                            high: high
                            low: low
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"thresholds": {"type": Thresholds}, "_custom_data": {"type": dict}}
            thresholds: Thresholds
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, thresholds: Thresholds | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Cpu.


                    Subclass of AvdModel.

                    Args:
                        thresholds: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "default_thresholds": {"type": DefaultThresholds},
            "log": {"type": int},
            "notifying": {"type": bool},
            "cpu": {"type": Cpu},
            "tx_latency": {"type": bool},
            "_custom_data": {"type": dict},
        }
        enabled: bool
        default_thresholds: DefaultThresholds
        """Subclass of AvdModel."""
        log: int | None
        """Logging interval in seconds."""
        notifying: bool | None
        """Should only be used for platforms supporting the "queue-monitor length notifying" CLI."""
        cpu: Cpu
        """Subclass of AvdModel."""
        tx_latency: bool | None
        """Enable tx-latency mode."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                default_thresholds: DefaultThresholds | UndefinedType = Undefined,
                log: int | None | UndefinedType = Undefined,
                notifying: bool | None | UndefinedType = Undefined,
                cpu: Cpu | UndefinedType = Undefined,
                tx_latency: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                QueueMonitorLength.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    default_thresholds: Subclass of AvdModel.
                    log: Logging interval in seconds.
                    notifying: Should only be used for platforms supporting the "queue-monitor length notifying" CLI.
                    cpu: Subclass of AvdModel.
                    tx_latency: Enable tx-latency mode.
                    _custom_data: _custom_data

                """

    class QueueMonitorStreaming(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "enable": {"type": bool},
            "ip_access_group": {"type": str},
            "ipv6_access_group": {"type": str},
            "max_connections": {"type": int},
            "vrf": {"type": str},
            "_custom_data": {"type": dict},
        }
        enable: bool | None
        ip_access_group: str | None
        """Name of IP ACL."""
        ipv6_access_group: str | None
        """Name of IPv6 ACL."""
        max_connections: int | None
        vrf: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enable: bool | None | UndefinedType = Undefined,
                ip_access_group: str | None | UndefinedType = Undefined,
                ipv6_access_group: str | None | UndefinedType = Undefined,
                max_connections: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                QueueMonitorStreaming.


                Subclass of AvdModel.

                Args:
                    enable: enable
                    ip_access_group: Name of IP ACL.
                    ipv6_access_group: Name of IPv6 ACL.
                    max_connections: max_connections
                    vrf: vrf
                    _custom_data: _custom_data

                """

    class RadiusServer(AvdModel):
        """Subclass of AvdModel."""

        class Attribute32IncludeInAccessReq(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"hostname": {"type": bool}, "format": {"type": str}, "_custom_data": {"type": dict}}
            hostname: bool | None
            format: str | None
            """Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    hostname: bool | None | UndefinedType = Undefined,
                    format: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Attribute32IncludeInAccessReq.


                    Subclass of AvdModel.

                    Args:
                        hostname: hostname
                        format: Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored.
                        _custom_data: _custom_data

                    """

        class DynamicAuthorization(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"port": {"type": int}, "tls_ssl_profile": {"type": str}, "_custom_data": {"type": dict}}
            port: int | None
            """TCP Port."""
            tls_ssl_profile: str | None
            """Name of TLS profile."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    port: int | None | UndefinedType = Undefined,
                    tls_ssl_profile: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    DynamicAuthorization.


                    Subclass of AvdModel.

                    Args:
                        port: TCP Port.
                        tls_ssl_profile: Name of TLS profile.
                        _custom_data: _custom_data

                    """

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            class Tls(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "ssl_profile": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool | None
                """Enable TLS for radius-server."""
                ssl_profile: str | None
                """Name of TLS profile."""
                port: int | None
                """TCP Port used for TLS. EOS default is 2083."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Tls.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable TLS for radius-server.
                            ssl_profile: Name of TLS profile.
                            port: TCP Port used for TLS. EOS default is 2083.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "tls": {"type": Tls},
                "timeout": {"type": int},
                "retransmit": {"type": int},
                "key": {"type": str},
                "_custom_data": {"type": dict},
            }
            host: str
            """Host IP address or name."""
            vrf: str | None
            tls: Tls
            """
            When TLS is configured, `key` is ignored..

            Subclass of AvdModel.
            """
            timeout: int | None
            retransmit: int | None
            key: str | None
            """
            Encrypted key - only type 7 supported.
            When TLS is configured, `key` is ignored.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    tls: Tls | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                    retransmit: int | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        tls:
                           When TLS is configured, `key` is ignored..

                           Subclass of AvdModel.
                        timeout: timeout
                        retransmit: retransmit
                        key:
                           Encrypted key - only type 7 supported.
                           When TLS is configured, `key` is ignored.
                        _custom_data: _custom_data

                    """

        class Hosts(AvdIndexedList[str, HostsItem]):
            """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`)."""

            _primary_key: ClassVar[str] = "host"

        Hosts._item_type = HostsItem

        _fields: ClassVar[dict] = {
            "attribute_32_include_in_access_req": {"type": Attribute32IncludeInAccessReq},
            "deadtime": {"type": int},
            "dynamic_authorization": {"type": DynamicAuthorization},
            "hosts": {"type": Hosts},
            "tls_ssl_profile": {"type": str},
            "_custom_data": {"type": dict},
        }
        attribute_32_include_in_access_req: Attribute32IncludeInAccessReq
        """Subclass of AvdModel."""
        deadtime: int | None
        """Time to skip a non-responsive server in minutes."""
        dynamic_authorization: DynamicAuthorization
        """Subclass of AvdModel."""
        hosts: Hosts
        """Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`)."""
        tls_ssl_profile: str | None
        """Name of global TLS profile."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                attribute_32_include_in_access_req: Attribute32IncludeInAccessReq | UndefinedType = Undefined,
                deadtime: int | None | UndefinedType = Undefined,
                dynamic_authorization: DynamicAuthorization | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                tls_ssl_profile: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RadiusServer.


                Subclass of AvdModel.

                Args:
                    attribute_32_include_in_access_req: Subclass of AvdModel.
                    deadtime: Time to skip a non-responsive server in minutes.
                    dynamic_authorization: Subclass of AvdModel.
                    hosts: Subclass of AvdIndexedList with `HostsItem` items. Primary key is `host` (`str`).
                    tls_ssl_profile: Name of global TLS profile.
                    _custom_data: _custom_data

                """

    class Redundancy(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"protocol": {"type": str}, "_custom_data": {"type": dict}}
        protocol: str | None
        """Redundancy Protocol."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, protocol: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                Redundancy.


                Subclass of AvdModel.

                Args:
                    protocol: Redundancy Protocol.
                    _custom_data: _custom_data

                """

    class RolesItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "sequence": {"type": int},
                "action": {"type": str},
                "mode": {"type": str},
                "command": {"type": str},
                "_custom_data": {"type": dict},
            }
            sequence: int | None
            """Sequence number."""
            action: Literal["permit", "deny"] | None
            mode: str | None
            """"config", "config-all", "exec" or mode key as string."""
            command: str | None
            """Command as string."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | None | UndefinedType = Undefined,
                    action: Literal["permit", "deny"] | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    command: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence number.
                        action: action
                        mode: "config", "config-all", "exec" or mode key as string.
                        command: Command as string.
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdList[SequenceNumbersItem]):
            """Subclass of AvdList with `SequenceNumbersItem` items."""

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
        name: str
        """Role name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdList with `SequenceNumbersItem` items."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RolesItem.


                Subclass of AvdModel.

                Args:
                    name: Role name.
                    sequence_numbers: Subclass of AvdList with `SequenceNumbersItem` items.
                    _custom_data: _custom_data

                """

    class Roles(AvdIndexedList[str, RolesItem]):
        """Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Roles._item_type = RolesItem

    class RouteMapsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            class Match(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Match._item_type = str

            class Set(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            Set._item_type = str

            class Continue(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "sequence_number": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool | None
                sequence_number: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        sequence_number: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Continue.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            sequence_number: sequence_number
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "sequence": {"type": int},
                "type": {"type": str},
                "description": {"type": str},
                "match": {"type": Match},
                "set": {"type": Set},
                "sub_route_map": {"type": str},
                "field_continue": {"type": Continue},
                "_custom_data": {"type": dict},
            }
            _field_to_key_map: ClassVar[dict] = {"field_continue": "continue"}
            _key_to_field_map: ClassVar[dict] = {"continue": "field_continue"}
            sequence: int
            """Sequence ID."""
            type: Literal["permit", "deny"]
            description: str | None
            match: Match
            """
            List of "match" statements.

            Subclass of AvdList with `str` items.
            """
            set: Set
            """
            List of "set" statements.

            Subclass of AvdList with `str` items.
            """
            sub_route_map: str | None
            """Name of Sub-Route-map."""
            field_continue: Continue
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    type: Literal["permit", "deny"] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    match: Match | UndefinedType = Undefined,
                    set: Set | UndefinedType = Undefined,
                    sub_route_map: str | None | UndefinedType = Undefined,
                    field_continue: Continue | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        type: type
                        description: description
                        match:
                           List of "match" statements.

                           Subclass of AvdList with `str` items.
                        set:
                           List of "set" statements.

                           Subclass of AvdList with `str` items.
                        sub_route_map: Name of Sub-Route-map.
                        field_continue: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
        name: str
        """Route-map Name."""
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouteMapsItem.


                Subclass of AvdModel.

                Args:
                    name: Route-map Name.
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class RouteMaps(AvdIndexedList[str, RouteMapsItem]):
        """Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    RouteMaps._item_type = RouteMapsItem

    class RouterAdaptiveVirtualTopology(AvdModel):
        """Subclass of AvdModel."""

        class Region(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}, "_custom_data": {"type": dict}}
            name: str
            id: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    id: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Region.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id
                        _custom_data: _custom_data

                    """

        class Zone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}, "_custom_data": {"type": dict}}
            name: str
            id: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    id: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Zone.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id
                        _custom_data: _custom_data

                    """

        class Site(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}, "_custom_data": {"type": dict}}
            name: str
            id: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    id: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Site.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        id: id
                        _custom_data: _custom_data

                    """

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            class MetricOrder(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"preferred_metric": {"type": str}, "_custom_data": {"type": dict}}
                preferred_metric: Literal["jitter", "latency", "load", "loss-rate"]
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        preferred_metric: Literal["jitter", "latency", "load", "loss-rate"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MetricOrder.


                        Subclass of AvdModel.

                        Args:
                            preferred_metric: preferred_metric
                            _custom_data: _custom_data

                        """

            class OutlierElimination(AvdModel):
                """Subclass of AvdModel."""

                class Threshold(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "jitter": {"type": int},
                        "latency": {"type": int},
                        "load": {"type": str},
                        "loss_rate": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    jitter: int | None
                    """Jitter threshold in millisecond."""
                    latency: int | None
                    """Latency threshold in millisecond."""
                    load: str | None
                    """Load threshold percentage. Valid range <0.00-100.00>."""
                    loss_rate: str | None
                    """Loss-rate threshold percentage. Valid range <0.00-100.00>."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            jitter: int | None | UndefinedType = Undefined,
                            latency: int | None | UndefinedType = Undefined,
                            load: str | None | UndefinedType = Undefined,
                            loss_rate: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.


                            Subclass of AvdModel.

                            Args:
                                jitter: Jitter threshold in millisecond.
                                latency: Latency threshold in millisecond.
                                load: Load threshold percentage. Valid range <0.00-100.00>.
                                loss_rate: Loss-rate threshold percentage. Valid range <0.00-100.00>.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"disabled": {"type": bool}, "threshold": {"type": Threshold}, "_custom_data": {"type": dict}}
                disabled: bool | None
                """Set true to disable the AVT path outlier elimination."""
                threshold: Threshold
                """
                Change the threshold values for path comparison.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        disabled: bool | None | UndefinedType = Undefined,
                        threshold: Threshold | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        OutlierElimination.


                        Subclass of AvdModel.

                        Args:
                            disabled: Set true to disable the AVT path outlier elimination.
                            threshold:
                               Change the threshold values for path comparison.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "load_balance_policy": {"type": str},
                "internet_exit_policy": {"type": str},
                "metric_order": {"type": MetricOrder},
                "outlier_elimination": {"type": OutlierElimination},
                "_custom_data": {"type": dict},
            }
            name: str
            """AVT Name."""
            load_balance_policy: str | None
            """Name of the load-balance policy."""
            internet_exit_policy: str | None
            """Name of the internet exit policy."""
            metric_order: MetricOrder
            """
            Metric order to be used for path comparison.

            Subclass of AvdModel.
            """
            outlier_elimination: OutlierElimination
            """
            AVT path outlier elimination.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    load_balance_policy: str | None | UndefinedType = Undefined,
                    internet_exit_policy: str | None | UndefinedType = Undefined,
                    metric_order: MetricOrder | UndefinedType = Undefined,
                    outlier_elimination: OutlierElimination | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: AVT Name.
                        load_balance_policy: Name of the load-balance policy.
                        internet_exit_policy: Name of the internet exit policy.
                        metric_order:
                           Metric order to be used for path comparison.

                           Subclass of AvdModel.
                        outlier_elimination:
                           AVT path outlier elimination.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class MatchesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "application_profile": {"type": str},
                    "avt_profile": {"type": str},
                    "dscp": {"type": int},
                    "traffic_class": {"type": int},
                    "_custom_data": {"type": dict},
                }
                application_profile: str | None
                """Application profile name."""
                avt_profile: str | None
                """AVT Profile name."""
                dscp: int | None
                """Set DSCP for matched traffic."""
                traffic_class: int | None
                """Set traffic-class for matched traffic."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        application_profile: str | None | UndefinedType = Undefined,
                        avt_profile: str | None | UndefinedType = Undefined,
                        dscp: int | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchesItem.


                        Subclass of AvdModel.

                        Args:
                            application_profile: Application profile name.
                            avt_profile: AVT Profile name.
                            dscp: Set DSCP for matched traffic.
                            traffic_class: Set traffic-class for matched traffic.
                            _custom_data: _custom_data

                        """

            class Matches(AvdList[MatchesItem]):
                """Subclass of AvdList with `MatchesItem` items."""

            Matches._item_type = MatchesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "matches": {"type": Matches}, "_custom_data": {"type": dict}}
            name: str
            """Policy name."""
            matches: Matches
            """Subclass of AvdList with `MatchesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    matches: Matches | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        matches: Subclass of AvdList with `MatchesItem` items.
                        _custom_data: _custom_data

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class ProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "id": {"type": int}, "_custom_data": {"type": dict}}
                name: str | None
                """AVT profile name."""
                id: int
                """Unique ID for this AVT (per VRF)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: AVT profile name.
                            id: Unique ID for this AVT (per VRF).
                            _custom_data: _custom_data

                        """

            class Profiles(AvdIndexedList[int, ProfilesItem]):
                """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "policy": {"type": str}, "profiles": {"type": Profiles}, "_custom_data": {"type": dict}}
            name: str
            """VRF name."""
            policy: str | None
            """AVT Policy name."""
            profiles: Profiles
            """
            AVT profiles in this VRF.

            Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id`
            (`int`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    policy: str | None | UndefinedType = Undefined,
                    profiles: Profiles | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        policy: AVT Policy name.
                        profiles:
                           AVT profiles in this VRF.

                           Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `id`
                           (`int`).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "topology_role": {"type": str},
            "gateway_vxlan": {"type": bool},
            "region": {"type": Region},
            "zone": {"type": Zone},
            "site": {"type": Site},
            "profiles": {"type": Profiles},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
            "_custom_data": {"type": dict},
        }
        topology_role: Literal["edge", "pathfinder", "transit region", "transit zone"] | None
        """Role name."""
        gateway_vxlan: bool | None
        """
        Enables VXLAN gateway router profile.
        Only applicable for `topology_role: edge`, `topology_role:
        transit region` or `topology_role: transit zone`.
        """
        region: Region
        """
        Region name and ID.

        Subclass of AvdModel.
        """
        zone: Zone
        """
        Zone name and ID.

        Subclass of AvdModel.
        """
        site: Site
        """
        Site name and ID.

        Subclass of AvdModel.
        """
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        policies: Policies
        """
        A sequence of application profiles mapped to some virtual topologies.

        Subclass of AvdIndexedList
        with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                topology_role: Literal["edge", "pathfinder", "transit region", "transit zone"] | None | UndefinedType = Undefined,
                gateway_vxlan: bool | None | UndefinedType = Undefined,
                region: Region | UndefinedType = Undefined,
                zone: Zone | UndefinedType = Undefined,
                site: Site | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterAdaptiveVirtualTopology.


                Subclass of AvdModel.

                Args:
                    topology_role: Role name.
                    gateway_vxlan:
                       Enables VXLAN gateway router profile.
                       Only applicable for `topology_role: edge`, `topology_role:
                       transit region` or `topology_role: transit zone`.
                    region:
                       Region name and ID.

                       Subclass of AvdModel.
                    zone:
                       Zone name and ID.

                       Subclass of AvdModel.
                    site:
                       Site name and ID.

                       Subclass of AvdModel.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    policies:
                       A sequence of application profiles mapped to some virtual topologies.

                       Subclass of AvdIndexedList
                       with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterBfd(AvdModel):
        """Subclass of AvdModel."""

        class Multihop(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multihop.


                    Subclass of AvdModel.

                    Args:
                        interval: Rate in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier
                        _custom_data: _custom_data

                    """

        class Sbfd(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterface(AvdModel):
                """Subclass of AvdModel."""

                class Protocols(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}, "_custom_data": {"type": dict}}
                    ipv4: bool | None
                    ipv6: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ipv4: bool | None | UndefinedType = Undefined,
                            ipv6: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Protocols.


                            Subclass of AvdModel.

                            Args:
                                ipv4: ipv4
                                ipv6: ipv6
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "protocols": {"type": Protocols}, "_custom_data": {"type": dict}}
                name: str | None
                """Interface Name."""
                protocols: Protocols
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalInterface.


                        Subclass of AvdModel.

                        Args:
                            name: Interface Name.
                            protocols: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Reflector(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"min_rx": {"type": int}, "local_discriminator": {"type": str}, "_custom_data": {"type": dict}}
                min_rx: int | None
                """Rate in milliseconds."""
                local_discriminator: str | None
                """IPv4 address or 32 bit integer."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        min_rx: int | None | UndefinedType = Undefined,
                        local_discriminator: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Reflector.


                        Subclass of AvdModel.

                        Args:
                            min_rx: Rate in milliseconds.
                            local_discriminator: IPv4 address or 32 bit integer.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "local_interface": {"type": LocalInterface},
                "initiator_interval": {"type": int},
                "initiator_multiplier": {"type": int},
                "initiator_measurement_round_trip": {"type": bool},
                "reflector": {"type": Reflector},
                "_custom_data": {"type": dict},
            }
            local_interface: LocalInterface
            """Subclass of AvdModel."""
            initiator_interval: int | None
            """Rate in milliseconds."""
            initiator_multiplier: int | None
            initiator_measurement_round_trip: bool | None
            """Enable round-trip delay measurement."""
            reflector: Reflector
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_interface: LocalInterface | UndefinedType = Undefined,
                    initiator_interval: int | None | UndefinedType = Undefined,
                    initiator_multiplier: int | None | UndefinedType = Undefined,
                    initiator_measurement_round_trip: bool | None | UndefinedType = Undefined,
                    reflector: Reflector | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sbfd.


                    Subclass of AvdModel.

                    Args:
                        local_interface: Subclass of AvdModel.
                        initiator_interval: Rate in milliseconds.
                        initiator_multiplier: initiator_multiplier
                        initiator_measurement_round_trip: Enable round-trip delay measurement.
                        reflector: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "interval": {"type": int},
            "local_address": {"type": str},
            "min_rx": {"type": int},
            "multiplier": {"type": int},
            "multihop": {"type": Multihop},
            "session_snapshot_interval": {"type": int},
            "session_snapshot_interval_dangerous": {"type": bool},
            "sbfd": {"type": Sbfd},
            "slow_timer": {"type": int},
            "_custom_data": {"type": dict},
        }
        interval: int | None
        """Rate in milliseconds."""
        local_address: str | None
        """Configure BFD local IP/IPv6 address."""
        min_rx: int | None
        """Rate in milliseconds."""
        multiplier: int | None
        multihop: Multihop
        """Subclass of AvdModel."""
        session_snapshot_interval: int | None
        """
        Interval in seconds.
        Intervals below 10 are considered "dangerous" on EOS and must have
        `session_snapshot_interval_dangerous` set to `true`.
        """
        session_snapshot_interval_dangerous: bool | None
        sbfd: Sbfd
        """Subclass of AvdModel."""
        slow_timer: int | None
        """Rate in milliseconds."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                interval: int | None | UndefinedType = Undefined,
                local_address: str | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
                multihop: Multihop | UndefinedType = Undefined,
                session_snapshot_interval: int | None | UndefinedType = Undefined,
                session_snapshot_interval_dangerous: bool | None | UndefinedType = Undefined,
                sbfd: Sbfd | UndefinedType = Undefined,
                slow_timer: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterBfd.


                Subclass of AvdModel.

                Args:
                    interval: Rate in milliseconds.
                    local_address: Configure BFD local IP/IPv6 address.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier
                    multihop: Subclass of AvdModel.
                    session_snapshot_interval:
                       Interval in seconds.
                       Intervals below 10 are considered "dangerous" on EOS and must have
                       `session_snapshot_interval_dangerous` set to `true`.
                    session_snapshot_interval_dangerous: session_snapshot_interval_dangerous
                    sbfd: Subclass of AvdModel.
                    slow_timer: Rate in milliseconds.
                    _custom_data: _custom_data

                """

    class RouterBgp(AvdModel):
        """Subclass of AvdModel."""

        class Timers(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "keepalive_time": {"type": int},
                "hold_time": {"type": int},
                "min_hold_time": {"type": int},
                "send_failure_hold_time": {"type": int},
                "_custom_data": {"type": dict},
            }
            keepalive_time: int | None
            """
            Time between BGP keepalive messages in seconds.
            `keepalive_time` should be lesser than `hold_time`.
            """
            hold_time: int | None
            """
            Hold time in seconds. Must be defined along with `keepalive_time`.
            The valid values are 3-7200 or 0
            if both values are 0.
            """
            min_hold_time: int | None
            """
            Neighbor's minimum hold time constraint in seconds.
            `min_hold_time` should be less than `hold_time`.
            """
            send_failure_hold_time: int | None
            """Send failure hold time in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    keepalive_time: int | None | UndefinedType = Undefined,
                    hold_time: int | None | UndefinedType = Undefined,
                    min_hold_time: int | None | UndefinedType = Undefined,
                    send_failure_hold_time: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timers.


                    Subclass of AvdModel.

                    Args:
                        keepalive_time:
                           Time between BGP keepalive messages in seconds.
                           `keepalive_time` should be lesser than `hold_time`.
                        hold_time:
                           Hold time in seconds. Must be defined along with `keepalive_time`.
                           The valid values are 3-7200 or 0
                           if both values are 0.
                        min_hold_time:
                           Neighbor's minimum hold time constraint in seconds.
                           `min_hold_time` should be less than `hold_time`.
                        send_failure_hold_time: Send failure hold time in seconds.
                        _custom_data: _custom_data

                    """

        class Distance(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "external_routes": {"type": int},
                "internal_routes": {"type": int},
                "local_routes": {"type": int},
                "_custom_data": {"type": dict},
            }
            external_routes: int
            internal_routes: int
            local_routes: int
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    external_routes: int | UndefinedType = Undefined,
                    internal_routes: int | UndefinedType = Undefined,
                    local_routes: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Distance.


                    Subclass of AvdModel.

                    Args:
                        external_routes: external_routes
                        internal_routes: internal_routes
                        local_routes: local_routes
                        _custom_data: _custom_data

                    """

        class GracefulRestart(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "restart_time": {"type": int},
                "stalepath_time": {"type": int},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            restart_time: int | None
            """Number of seconds."""
            stalepath_time: int | None
            """Number of seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_time: int | None | UndefinedType = Undefined,
                    stalepath_time: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestart.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_time: Number of seconds.
                        stalepath_time: Number of seconds.
                        _custom_data: _custom_data

                    """

        class GracefulRestartHelper(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_time": {"type": int}, "long_lived": {"type": bool}, "_custom_data": {"type": dict}}
            enabled: bool | None
            restart_time: int | None
            """
            Number of seconds
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will take precedence if both are configured.
            """
            long_lived: bool | None
            """
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will
            take precedence if both are configured.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_time: int | None | UndefinedType = Undefined,
                    long_lived: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestartHelper.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_time:
                           Number of seconds
                           graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                           restart-time will take precedence if both are configured.
                        long_lived:
                           graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                           restart-time will
                           take precedence if both are configured.
                        _custom_data: _custom_data

                    """

        class MaximumPaths(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"paths": {"type": int}, "ecmp": {"type": int}, "_custom_data": {"type": dict}}
            paths: int
            ecmp: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    paths: int | UndefinedType = Undefined,
                    ecmp: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MaximumPaths.


                    Subclass of AvdModel.

                    Args:
                        paths: paths
                        ecmp: ecmp
                        _custom_data: _custom_data

                    """

        class Updates(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}, "_custom_data": {"type": dict}}
            wait_for_convergence: bool | None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            """
            wait_install: bool | None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    wait_for_convergence: bool | None | UndefinedType = Undefined,
                    wait_install: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Updates.


                    Subclass of AvdModel.

                    Args:
                        wait_for_convergence:
                           Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                           convergence state is reached.
                        wait_install:
                           Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                           This
                           will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                           that may not yet be installed into the forwarding plane.
                        _custom_data: _custom_data

                    """

        class BgpDefaults(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        BgpDefaults._item_type = str

        class Bgp(AvdModel):
            """Subclass of AvdModel."""

            class Default(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_unicast": {"type": bool}, "ipv4_unicast_transport_ipv6": {"type": bool}, "_custom_data": {"type": dict}}
                ipv4_unicast: bool | None
                """Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True)."""
                ipv4_unicast_transport_ipv6: bool | None
                """Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4_unicast: bool | None | UndefinedType = Undefined,
                        ipv4_unicast_transport_ipv6: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Default.


                        Subclass of AvdModel.

                        Args:
                            ipv4_unicast: Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True).
                            ipv4_unicast_transport_ipv6: Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False).
                            _custom_data: _custom_data

                        """

            class RouteReflectorPreserveAttributes(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                always: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteReflectorPreserveAttributes.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            _custom_data: _custom_data

                        """

            class Bestpath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"d_path": {"type": bool}, "_custom_data": {"type": dict}}
                d_path: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, d_path: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Bestpath.


                        Subclass of AvdModel.

                        Args:
                            d_path: d_path
                            _custom_data: _custom_data

                        """

            class AdditionalPaths(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                receive: bool | None
                """Enable or disable reception of additional-paths."""
                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                """
                Select an option to send multiple paths for same prefix through bgp updates.
                any: Send any eligible
                path.
                backup: Best path and installed backup path.
                ecmp: All paths in best path ECMP group.
                limit:
                Limit to n eligible paths.
                disabled: Disable sending any paths.
                """
                send_limit: int | None
                """
                Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                `ecmp`.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        receive: bool | None | UndefinedType = Undefined,
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.


                        Subclass of AvdModel.

                        Args:
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "default": {"type": Default},
                "route_reflector_preserve_attributes": {"type": RouteReflectorPreserveAttributes},
                "bestpath": {"type": Bestpath},
                "additional_paths": {"type": AdditionalPaths},
                "redistribute_internal": {"type": bool},
                "_custom_data": {"type": dict},
            }
            default: Default
            """Subclass of AvdModel."""
            route_reflector_preserve_attributes: RouteReflectorPreserveAttributes
            """Subclass of AvdModel."""
            bestpath: Bestpath
            """Subclass of AvdModel."""
            additional_paths: AdditionalPaths
            """Subclass of AvdModel."""
            redistribute_internal: bool | None
            """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    default: Default | UndefinedType = Undefined,
                    route_reflector_preserve_attributes: RouteReflectorPreserveAttributes | UndefinedType = Undefined,
                    bestpath: Bestpath | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    redistribute_internal: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.


                    Subclass of AvdModel.

                    Args:
                        default: Subclass of AvdModel.
                        route_reflector_preserve_attributes: Subclass of AvdModel.
                        bestpath: Subclass of AvdModel.
                        additional_paths: Subclass of AvdModel.
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                        _custom_data: _custom_data

                    """

        class ListenRangesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "prefix": {"type": str},
                "peer_id_include_router_id": {"type": bool},
                "peer_group": {"type": str},
                "peer_filter": {"type": str},
                "remote_as": {"type": str},
                "_custom_data": {"type": dict},
            }
            prefix: str | None
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            peer_id_include_router_id: bool | None
            """Include router ID as part of peer filter."""
            peer_group: str | None
            """Peer group name."""
            peer_filter: str | None
            """
            Peer-filter name.
            note: `peer_filter` or `remote_as` is required but mutually exclusive.
            If both are
            defined, `peer_filter` takes precedence
            """
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    prefix: str | None | UndefinedType = Undefined,
                    peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ListenRangesItem.


                    Subclass of AvdModel.

                    Args:
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        peer_id_include_router_id: Include router ID as part of peer filter.
                        peer_group: Peer group name.
                        peer_filter:
                           Peer-filter name.
                           note: `peer_filter` or `remote_as` is required but mutually exclusive.
                           If both are
                           defined, `peer_filter` takes precedence
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        _custom_data: _custom_data

                    """

        class ListenRanges(AvdList[ListenRangesItem]):
            """Subclass of AvdList with `ListenRangesItem` items."""

        ListenRanges._item_type = ListenRangesItem

        class NeighborDefault(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"send_community": {"type": str}, "_custom_data": {"type": dict}}
            send_community: (
                Literal["all", "large", "extended", "standard", "extended large", "standard large", "standard extended", "standard extended large"] | None
            )
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    send_community: Literal[
                        "all", "large", "extended", "standard", "extended large", "standard large", "standard extended", "standard extended large"
                    ]
                    | None
                    | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborDefault.


                    Subclass of AvdModel.

                    Args:
                        send_community: send_community
                        _custom_data: _custom_data

                    """

        class PeerGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class AsPath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}, "_custom_data": {"type": dict}}
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        remote_as_replace_out: bool | None | UndefinedType = Undefined,
                        prepend_own_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AsPath.


                        Subclass of AvdModel.

                        Args:
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.
                            _custom_data: _custom_data

                        """

            class RemovePrivateAs(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                all: bool | None
                replace_as: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAs.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            replace_as: replace_as
                            _custom_data: _custom_data

                        """

            class RemovePrivateAsIngress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                replace_as: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAsIngress.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            replace_as: replace_as
                            _custom_data: _custom_data

                        """

            class BfdTimers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | UndefinedType = Undefined,
                        min_rx: int | UndefinedType = Undefined,
                        multiplier: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BfdTimers.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier
                            _custom_data: _custom_data

                        """

            class DefaultOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                always: bool | None
                route_map: str | None
                """Route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            route_map: Route-map name.
                            _custom_data: _custom_data

                        """

            class MissingPolicy(AvdModel):
                """Subclass of AvdModel."""

                class DirectionIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.
                                _custom_data: _custom_data

                            """

                class DirectionOut(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}, "_custom_data": {"type": dict}}
                direction_in: DirectionIn
                """
                Missing policy inbound direction.

                Subclass of AvdModel.
                """
                direction_out: DirectionOut
                """
                Missing policy outbound direction.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.


                        Subclass of AvdModel.

                        Args:
                            direction_in:
                               Missing policy inbound direction.

                               Subclass of AvdModel.
                            direction_out:
                               Missing policy outbound direction.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class LinkBandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "default": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        default: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LinkBandwidth.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            default: nn.nn(K|M|G) link speed in bits/second.
                            _custom_data: _custom_data

                        """

            class AllowasIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        times: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AllowasIn.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.
                            _custom_data: _custom_data

                        """

            class RibInPrePolicyRetain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                all: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RibInPrePolicyRetain.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            _custom_data: _custom_data

                        """

            class SharedSecret(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"profile": {"type": str}, "hash_algorithm": {"type": str}, "_custom_data": {"type": dict}}
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        profile: str | UndefinedType = Undefined,
                        hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.


                        Subclass of AvdModel.

                        Args:
                            profile: Name of profile defined under `management_security`.
                            hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "type": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "description": {"type": str},
                "shutdown": {"type": bool},
                "as_path": {"type": AsPath},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "next_hop_unchanged": {"type": bool},
                "update_source": {"type": str},
                "route_reflector_client": {"type": bool},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "ebgp_multihop": {"type": int},
                "next_hop_self": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "link_bandwidth": {"type": LinkBandwidth},
                "allowas_in": {"type": AllowasIn},
                "weight": {"type": int},
                "timers": {"type": str},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
                "_custom_data": {"type": dict},
            }
            name: str
            """Peer-group name."""
            type: str | None
            """Key only used for documentation or validation purposes."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            description: str | None
            shutdown: bool | None
            as_path: AsPath
            """
            BGP AS-PATH options.

            Subclass of AvdModel.
            """
            remove_private_as: RemovePrivateAs
            """
            Remove private AS numbers in outbound AS path.

            Subclass of AvdModel.
            """
            remove_private_as_ingress: RemovePrivateAsIngress
            """Subclass of AvdModel."""
            next_hop_unchanged: bool | None
            update_source: str | None
            """IP address or interface name."""
            route_reflector_client: bool | None
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """
            Override default BFD timers. BFD must be enabled with `bfd: true`.

            Subclass of AvdModel.
            """
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None
            password: str | None
            passive: bool | None
            default_originate: DefaultOriginate
            """Subclass of AvdModel."""
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """
            Missing policy configuration for all address-families.

            Subclass of AvdModel.
            """
            link_bandwidth: LinkBandwidth
            """Subclass of AvdModel."""
            allowas_in: AllowasIn
            """Subclass of AvdModel."""
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            """Subclass of AvdModel."""
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            session_tracker: str | None
            shared_secret: SharedSecret
            """Subclass of AvdModel."""
            ttl_maximum_hops: int | None
            """Maximum number of hops."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    local_as: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    as_path: AsPath | UndefinedType = Undefined,
                    remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                    remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    update_source: str | None | UndefinedType = Undefined,
                    route_reflector_client: bool | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bfd_timers: BfdTimers | UndefinedType = Undefined,
                    ebgp_multihop: int | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    passive: bool | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    send_community: str | None | UndefinedType = Undefined,
                    maximum_routes: int | None | UndefinedType = Undefined,
                    maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                    maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                    allowas_in: AllowasIn | UndefinedType = Undefined,
                    weight: int | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    session_tracker: str | None | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    ttl_maximum_hops: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Peer-group name.
                        type: Key only used for documentation or validation purposes.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        description: description
                        shutdown: shutdown
                        as_path:
                           BGP AS-PATH options.

                           Subclass of AvdModel.
                        remove_private_as:
                           Remove private AS numbers in outbound AS path.

                           Subclass of AvdModel.
                        remove_private_as_ingress: Subclass of AvdModel.
                        next_hop_unchanged: next_hop_unchanged
                        update_source: IP address or interface name.
                        route_reflector_client: route_reflector_client
                        bfd: Enable BFD.
                        bfd_timers:
                           Override default BFD timers. BFD must be enabled with `bfd: true`.

                           Subclass of AvdModel.
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_self: next_hop_self
                        password: password
                        passive: passive
                        default_originate: Subclass of AvdModel.
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: Maximum number of routes (0 means unlimited).
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        missing_policy:
                           Missing policy configuration for all address-families.

                           Subclass of AvdModel.
                        link_bandwidth: Subclass of AvdModel.
                        allowas_in: Subclass of AvdModel.
                        weight: weight
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        rib_in_pre_policy_retain: Subclass of AvdModel.
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        session_tracker: session_tracker
                        shared_secret: Subclass of AvdModel.
                        ttl_maximum_hops: Maximum number of hops.
                        _custom_data: _custom_data

                    """

        class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PeerGroups._item_type = PeerGroupsItem

        class NeighborsItem(AvdModel):
            """Subclass of AvdModel."""

            class AsPath(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}, "_custom_data": {"type": dict}}
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        remote_as_replace_out: bool | None | UndefinedType = Undefined,
                        prepend_own_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AsPath.


                        Subclass of AvdModel.

                        Args:
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.
                            _custom_data: _custom_data

                        """

            class BfdTimers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        interval: int | UndefinedType = Undefined,
                        min_rx: int | UndefinedType = Undefined,
                        multiplier: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BfdTimers.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier
                            _custom_data: _custom_data

                        """

            class DefaultOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                always: bool | None
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            always: always
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class MissingPolicy(AvdModel):
                """Subclass of AvdModel."""

                class DirectionIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.
                                _custom_data: _custom_data

                            """

                class DirectionOut(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    action: Literal["deny", "permit", "deny-in-out"]
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.


                            Subclass of AvdModel.

                            Args:
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}, "_custom_data": {"type": dict}}
                direction_in: DirectionIn
                """
                Missing policy inbound direction.

                Subclass of AvdModel.
                """
                direction_out: DirectionOut
                """
                Missing policy outbound direction.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.


                        Subclass of AvdModel.

                        Args:
                            direction_in:
                               Missing policy inbound direction.

                               Subclass of AvdModel.
                            direction_out:
                               Missing policy outbound direction.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class AllowasIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        times: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AllowasIn.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.
                            _custom_data: _custom_data

                        """

            class LinkBandwidth(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "default": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        default: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LinkBandwidth.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            default: nn.nn(K|M|G) link speed in bits/second.
                            _custom_data: _custom_data

                        """

            class RibInPrePolicyRetain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                all: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RibInPrePolicyRetain.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            _custom_data: _custom_data

                        """

            class RemovePrivateAs(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                all: bool | None
                replace_as: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAs.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            all: all
                            replace_as: replace_as
                            _custom_data: _custom_data

                        """

            class RemovePrivateAsIngress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                replace_as: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAsIngress.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            replace_as: replace_as
                            _custom_data: _custom_data

                        """

            class SharedSecret(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"profile": {"type": str}, "hash_algorithm": {"type": str}, "_custom_data": {"type": dict}}
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        profile: str | UndefinedType = Undefined,
                        hash_algorithm: Literal["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"] | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.


                        Subclass of AvdModel.

                        Args:
                            profile: Name of profile defined under `management_security`.
                            hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "ip_address": {"type": str},
                "peer_group": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "as_path": {"type": AsPath},
                "peer": {"type": str},
                "description": {"type": str},
                "route_reflector_client": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "shutdown": {"type": bool},
                "update_source": {"type": str},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "weight": {"type": int},
                "timers": {"type": str},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "allowas_in": {"type": AllowasIn},
                "ebgp_multihop": {"type": int},
                "next_hop_self": {"type": bool},
                "link_bandwidth": {"type": LinkBandwidth},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
                "_custom_data": {"type": dict},
            }
            ip_address: str
            peer_group: str | None
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            as_path: AsPath
            """
            BGP AS-PATH options.

            Subclass of AvdModel.
            """
            peer: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            route_reflector_client: bool | None
            password: str | None
            passive: bool | None
            shutdown: bool | None
            update_source: str | None
            """Source Interface."""
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """
            Override default BFD timers. BFD must be enabled with `bfd: true`.

            Subclass of AvdModel.
            """
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            default_originate: DefaultOriginate
            """Subclass of AvdModel."""
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """
            Missing policy configuration for all address-families.

            Subclass of AvdModel.
            """
            allowas_in: AllowasIn
            """Subclass of AvdModel."""
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None
            link_bandwidth: LinkBandwidth
            """Subclass of AvdModel."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            """Subclass of AvdModel."""
            remove_private_as: RemovePrivateAs
            """
            Remove private AS numbers in outbound AS path.

            Subclass of AvdModel.
            """
            remove_private_as_ingress: RemovePrivateAsIngress
            """Subclass of AvdModel."""
            session_tracker: str | None
            shared_secret: SharedSecret
            """Subclass of AvdModel."""
            ttl_maximum_hops: int | None
            """Maximum number of hops."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_address: str | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    local_as: str | None | UndefinedType = Undefined,
                    as_path: AsPath | UndefinedType = Undefined,
                    peer: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    route_reflector_client: bool | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    passive: bool | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    update_source: str | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bfd_timers: BfdTimers | UndefinedType = Undefined,
                    weight: int | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    send_community: str | None | UndefinedType = Undefined,
                    maximum_routes: int | None | UndefinedType = Undefined,
                    maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                    maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    allowas_in: AllowasIn | UndefinedType = Undefined,
                    ebgp_multihop: int | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                    remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                    remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                    session_tracker: str | None | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    ttl_maximum_hops: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.


                    Subclass of AvdModel.

                    Args:
                        ip_address: ip_address
                        peer_group: peer_group
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        as_path:
                           BGP AS-PATH options.

                           Subclass of AvdModel.
                        peer: Key only used for documentation or validation purposes.
                        description: description
                        route_reflector_client: route_reflector_client
                        password: password
                        passive: passive
                        shutdown: shutdown
                        update_source: Source Interface.
                        bfd: Enable BFD.
                        bfd_timers:
                           Override default BFD timers. BFD must be enabled with `bfd: true`.

                           Subclass of AvdModel.
                        weight: weight
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        default_originate: Subclass of AvdModel.
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: Maximum number of routes (0 means unlimited).
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        missing_policy:
                           Missing policy configuration for all address-families.

                           Subclass of AvdModel.
                        allowas_in: Subclass of AvdModel.
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_self: next_hop_self
                        link_bandwidth: Subclass of AvdModel.
                        rib_in_pre_policy_retain: Subclass of AvdModel.
                        remove_private_as:
                           Remove private AS numbers in outbound AS path.

                           Subclass of AvdModel.
                        remove_private_as_ingress: Subclass of AvdModel.
                        session_tracker: session_tracker
                        shared_secret: Subclass of AvdModel.
                        ttl_maximum_hops: Maximum number of hops.
                        _custom_data: _custom_data

                    """

        class Neighbors(AvdIndexedList[str, NeighborsItem]):
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

            _primary_key: ClassVar[str] = "ip_address"

        Neighbors._item_type = NeighborsItem

        class NeighborInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "remote_as": {"type": str},
                "peer": {"type": str},
                "peer_group": {"type": str, "default": "Peer-group name"},
                "description": {"type": str},
                "peer_filter": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Interface name."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            peer: str | None
            """Key only used for documentation or validation purposes."""
            peer_group: str
            """Default value: `"Peer-group name"`"""
            description: str | None
            peer_filter: str | None
            """Peer-filter name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    peer: str | None | UndefinedType = Undefined,
                    peer_group: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        peer: Key only used for documentation or validation purposes.
                        peer_group: peer_group
                        description: description
                        peer_filter: Peer-filter name.
                        _custom_data: _custom_data

                    """

        class NeighborInterfaces(AvdIndexedList[str, NeighborInterfacesItem]):
            """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        NeighborInterfaces._item_type = NeighborInterfacesItem

        class AggregateAddressesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "prefix": {"type": str},
                "advertise_only": {"type": bool},
                "as_set": {"type": bool},
                "summary_only": {"type": bool},
                "attribute_map": {"type": str},
                "match_map": {"type": str},
                "_custom_data": {"type": dict},
            }
            prefix: str
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            advertise_only: bool | None
            as_set: bool | None
            summary_only: bool | None
            attribute_map: str | None
            """Route-map name."""
            match_map: str | None
            """Route-map name."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    prefix: str | UndefinedType = Undefined,
                    advertise_only: bool | None | UndefinedType = Undefined,
                    as_set: bool | None | UndefinedType = Undefined,
                    summary_only: bool | None | UndefinedType = Undefined,
                    attribute_map: str | None | UndefinedType = Undefined,
                    match_map: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AggregateAddressesItem.


                    Subclass of AvdModel.

                    Args:
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        advertise_only: advertise_only
                        as_set: as_set
                        summary_only: summary_only
                        attribute_map: Route-map name.
                        match_map: Route-map name.
                        _custom_data: _custom_data

                    """

        class AggregateAddresses(AvdIndexedList[str, AggregateAddressesItem]):
            """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""

            _primary_key: ClassVar[str] = "prefix"

        AggregateAddresses._item_type = AggregateAddressesItem

        class Redistribute(AvdModel):
            """Subclass of AvdModel."""

            class AttachedHost(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AttachedHost.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Connected(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.
                            _custom_data: _custom_data

                        """

            class Dynamic(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dynamic.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            _custom_data: _custom_data

                        """

            class Isis(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "isis_level": {"type": str},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool
                isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                """Redistribute IS-IS route level."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.
                            _custom_data: _custom_data

                        """

            class Ospf(AvdModel):
                """Subclass of AvdModel."""

                class MatchExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class MatchInternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class MatchNssaExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    nssa_type: Literal[1, 2] | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                """Redistribute OSPF routes."""
                match_external: MatchExternal
                """
                Redistribute OSPF routes learned from external sources.

                Subclass of AvdModel.
                """
                match_internal: MatchInternal
                """
                Redistribute OSPF routes learned from internal sources.

                Subclass of AvdModel.
                """
                match_nssa_external: MatchNssaExternal
                """
                Redistribute OSPF routes learned from external NSSA sources.

                Subclass of AvdModel.
                """
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.


                        Subclass of AvdModel.

                        Args:
                            enabled: Redistribute OSPF routes.
                            match_external:
                               Redistribute OSPF routes learned from external sources.

                               Subclass of AvdModel.
                            match_internal:
                               Redistribute OSPF routes learned from internal sources.

                               Subclass of AvdModel.
                            match_nssa_external:
                               Redistribute OSPF routes learned from external NSSA sources.

                               Subclass of AvdModel.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.
                            _custom_data: _custom_data

                        """

            class Ospfv3(AvdModel):
                """Subclass of AvdModel."""

                class MatchExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class MatchInternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class MatchNssaExternal(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    nssa_type: Literal[1, 2] | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                """Redistribute OSPFv3 routes."""
                match_external: MatchExternal
                """
                Redistribute OSPFv3 routes learned from external sources.

                Subclass of AvdModel.
                """
                match_internal: MatchInternal
                """
                Redistribute OSPFv3 routes learned from internal sources.

                Subclass of AvdModel.
                """
                match_nssa_external: MatchNssaExternal
                """
                Redistribute OSPFv3 routes learned from external NSSA sources.

                Subclass of AvdModel.
                """
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.


                        Subclass of AvdModel.

                        Args:
                            enabled: Redistribute OSPFv3 routes.
                            match_external:
                               Redistribute OSPFv3 routes learned from external sources.

                               Subclass of AvdModel.
                            match_internal:
                               Redistribute OSPFv3 routes learned from internal sources.

                               Subclass of AvdModel.
                            match_nssa_external:
                               Redistribute OSPFv3 routes learned from external NSSA sources.

                               Subclass of AvdModel.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.
                            _custom_data: _custom_data

                        """

            class Rip(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Rip.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Static(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.
                            _custom_data: _custom_data

                        """

            class User(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        User.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "attached_host": {"type": AttachedHost},
                "bgp": {"type": Bgp},
                "connected": {"type": Connected},
                "dynamic": {"type": Dynamic},
                "isis": {"type": Isis},
                "ospf": {"type": Ospf},
                "ospfv3": {"type": Ospfv3},
                "rip": {"type": Rip},
                "static": {"type": Static},
                "user": {"type": User},
                "_custom_data": {"type": dict},
            }
            attached_host: AttachedHost
            """Subclass of AvdModel."""
            bgp: Bgp
            """Subclass of AvdModel."""
            connected: Connected
            """Subclass of AvdModel."""
            dynamic: Dynamic
            """Subclass of AvdModel."""
            isis: Isis
            """Subclass of AvdModel."""
            ospf: Ospf
            """Subclass of AvdModel."""
            ospfv3: Ospfv3
            """Subclass of AvdModel."""
            rip: Rip
            """Subclass of AvdModel."""
            static: Static
            """Subclass of AvdModel."""
            user: User
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    rip: Rip | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    user: User | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.


                    Subclass of AvdModel.

                    Args:
                        attached_host: Subclass of AvdModel.
                        bgp: Subclass of AvdModel.
                        connected: Subclass of AvdModel.
                        dynamic: Subclass of AvdModel.
                        isis: Subclass of AvdModel.
                        ospf: Subclass of AvdModel.
                        ospfv3: Subclass of AvdModel.
                        rip: Subclass of AvdModel.
                        static: Subclass of AvdModel.
                        user: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class RedistributeRoutesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "rcf": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
                "_custom_data": {"type": dict},
            }
            source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
            route_map: str | None
            rcf: str | None
            """
            RCF function name with parenthesis.
            Example: MyFunction(myarg).
            `route_map` and `rcf` are mutually
            exclusive. `route_map` takes precedence.
            Only applicable if `source_protocol` is one of `connected`,
            `static`, `isis`, `user`, `dynamic`.
            """
            include_leaked: bool | None
            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
            """
            Routes learned by the OSPF protocol.
            The `ospf_route_type` is valid for source_protocols 'ospf' and
            'ospfv3'.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.


                    Subclass of AvdModel.

                    Args:
                        source_protocol: source_protocol
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        include_leaked: include_leaked
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.
                        _custom_data: _custom_data

                    """

        class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

        RedistributeRoutes._item_type = RedistributeRoutesItem

        class VlanAwareBundlesItem(AvdModel):
            """Subclass of AvdModel."""

            class RdEvpnDomain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"domain": {"type": str}, "rd": {"type": str}, "_custom_data": {"type": dict}}
                domain: Literal["remote", "all"] | None
                rd: str | None
                """Route distinguisher."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                        rd: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RdEvpnDomain.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            rd: Route distinguisher.
                            _custom_data: _custom_data

                        """

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class Both(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Both._item_type = str

                class Import(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Import._item_type = str

                class Export(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Export._item_type = str

                class ImportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ImportEvpnDomains(AvdList[ImportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportEvpnDomainsItem` items."""

                ImportEvpnDomains._item_type = ImportEvpnDomainsItem

                class ExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ExportEvpnDomains(AvdList[ExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ExportEvpnDomainsItem` items."""

                ExportEvpnDomains._item_type = ExportEvpnDomainsItem

                class ImportExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ImportExportEvpnDomains(AvdList[ImportExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                ImportExportEvpnDomains._item_type = ImportExportEvpnDomainsItem

                _fields: ClassVar[dict] = {
                    "both": {"type": Both},
                    "field_import": {"type": Import},
                    "export": {"type": Export},
                    "import_evpn_domains": {"type": ImportEvpnDomains},
                    "export_evpn_domains": {"type": ExportEvpnDomains},
                    "import_export_evpn_domains": {"type": ImportExportEvpnDomains},
                    "_custom_data": {"type": dict},
                }
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                both: Both
                """Subclass of AvdList with `str` items."""
                field_import: Import
                """Subclass of AvdList with `str` items."""
                export: Export
                """Subclass of AvdList with `str` items."""
                import_evpn_domains: ImportEvpnDomains
                """Subclass of AvdList with `ImportEvpnDomainsItem` items."""
                export_evpn_domains: ExportEvpnDomains
                """Subclass of AvdList with `ExportEvpnDomainsItem` items."""
                import_export_evpn_domains: ImportExportEvpnDomains
                """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        both: Both | UndefinedType = Undefined,
                        field_import: Import | UndefinedType = Undefined,
                        export: Export | UndefinedType = Undefined,
                        import_evpn_domains: ImportEvpnDomains | UndefinedType = Undefined,
                        export_evpn_domains: ExportEvpnDomains | UndefinedType = Undefined,
                        import_export_evpn_domains: ImportExportEvpnDomains | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            both: Subclass of AvdList with `str` items.
                            field_import: Subclass of AvdList with `str` items.
                            export: Subclass of AvdList with `str` items.
                            import_evpn_domains: Subclass of AvdList with `ImportEvpnDomainsItem` items.
                            export_evpn_domains: Subclass of AvdList with `ExportEvpnDomainsItem` items.
                            import_export_evpn_domains: Subclass of AvdList with `ImportExportEvpnDomainsItem` items.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            RedistributeRoutes._item_type = str

            class NoRedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoRedistributeRoutes._item_type = str

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "tenant": {"type": str},
                "description": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": RedistributeRoutes},
                "no_redistribute_routes": {"type": NoRedistributeRoutes},
                "vlan": {"type": str},
                "eos_cli": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """VLAN aware bundle name."""
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            """Subclass of AvdModel."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `str` items."""
            no_redistribute_routes: NoRedistributeRoutes
            """Subclass of AvdList with `str` items."""
            vlan: str | None
            """VLAN range as string. Example "100-200,300"."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
            configuration.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    tenant: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    no_redistribute_routes: NoRedistributeRoutes | UndefinedType = Undefined,
                    vlan: str | None | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanAwareBundlesItem.


                    Subclass of AvdModel.

                    Args:
                        name: VLAN aware bundle name.
                        tenant: Key only used for documentation or validation purposes.
                        description: Key only used for documentation or validation purposes.
                        rd: Route distinguisher.
                        rd_evpn_domain: Subclass of AvdModel.
                        route_targets: Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `str` items.
                        no_redistribute_routes: Subclass of AvdList with `str` items.
                        vlan: VLAN range as string. Example "100-200,300".
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
                           configuration.
                        _custom_data: _custom_data

                    """

        class VlanAwareBundles(AvdIndexedList[str, VlanAwareBundlesItem]):
            """Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        VlanAwareBundles._item_type = VlanAwareBundlesItem

        class VlansItem(AvdModel):
            """Subclass of AvdModel."""

            class RdEvpnDomain(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"domain": {"type": str}, "rd": {"type": str}, "_custom_data": {"type": dict}}
                domain: Literal["remote", "all"] | None
                rd: str | None
                """Route distinguisher."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                        rd: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RdEvpnDomain.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            rd: Route distinguisher.
                            _custom_data: _custom_data

                        """

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class Both(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Both._item_type = str

                class Import(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Import._item_type = str

                class Export(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Export._item_type = str

                class ImportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ImportEvpnDomains(AvdList[ImportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportEvpnDomainsItem` items."""

                ImportEvpnDomains._item_type = ImportEvpnDomainsItem

                class ExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ExportEvpnDomains(AvdList[ExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ExportEvpnDomainsItem` items."""

                ExportEvpnDomains._item_type = ExportEvpnDomainsItem

                class ImportExportEvpnDomainsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"domain": {"type": str}, "route_target": {"type": str}, "_custom_data": {"type": dict}}
                    domain: Literal["remote", "all"] | None
                    route_target: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            domain: Literal["remote", "all"] | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportExportEvpnDomainsItem.


                            Subclass of AvdModel.

                            Args:
                                domain: domain
                                route_target: route_target
                                _custom_data: _custom_data

                            """

                class ImportExportEvpnDomains(AvdList[ImportExportEvpnDomainsItem]):
                    """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""

                ImportExportEvpnDomains._item_type = ImportExportEvpnDomainsItem

                _fields: ClassVar[dict] = {
                    "both": {"type": Both},
                    "field_import": {"type": Import},
                    "export": {"type": Export},
                    "import_evpn_domains": {"type": ImportEvpnDomains},
                    "export_evpn_domains": {"type": ExportEvpnDomains},
                    "import_export_evpn_domains": {"type": ImportExportEvpnDomains},
                    "_custom_data": {"type": dict},
                }
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                both: Both
                """Subclass of AvdList with `str` items."""
                field_import: Import
                """Subclass of AvdList with `str` items."""
                export: Export
                """Subclass of AvdList with `str` items."""
                import_evpn_domains: ImportEvpnDomains
                """Subclass of AvdList with `ImportEvpnDomainsItem` items."""
                export_evpn_domains: ExportEvpnDomains
                """Subclass of AvdList with `ExportEvpnDomainsItem` items."""
                import_export_evpn_domains: ImportExportEvpnDomains
                """Subclass of AvdList with `ImportExportEvpnDomainsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        both: Both | UndefinedType = Undefined,
                        field_import: Import | UndefinedType = Undefined,
                        export: Export | UndefinedType = Undefined,
                        import_evpn_domains: ImportEvpnDomains | UndefinedType = Undefined,
                        export_evpn_domains: ExportEvpnDomains | UndefinedType = Undefined,
                        import_export_evpn_domains: ImportExportEvpnDomains | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            both: Subclass of AvdList with `str` items.
                            field_import: Subclass of AvdList with `str` items.
                            export: Subclass of AvdList with `str` items.
                            import_evpn_domains: Subclass of AvdList with `ImportEvpnDomainsItem` items.
                            export_evpn_domains: Subclass of AvdList with `ExportEvpnDomainsItem` items.
                            import_export_evpn_domains: Subclass of AvdList with `ImportExportEvpnDomainsItem` items.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            RedistributeRoutes._item_type = str

            class NoRedistributeRoutes(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoRedistributeRoutes._item_type = str

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "tenant": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": RedistributeRoutes},
                "no_redistribute_routes": {"type": NoRedistributeRoutes},
                "eos_cli": {"type": str},
                "_custom_data": {"type": dict},
            }
            id: int
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            """Subclass of AvdModel."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `str` items."""
            no_redistribute_routes: NoRedistributeRoutes
            """Subclass of AvdList with `str` items."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
            configuration.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    tenant: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    no_redistribute_routes: NoRedistributeRoutes | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlansItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        tenant: Key only used for documentation or validation purposes.
                        rd: Route distinguisher.
                        rd_evpn_domain: Subclass of AvdModel.
                        route_targets: Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `str` items.
                        no_redistribute_routes: Subclass of AvdList with `str` items.
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
                           configuration.
                        _custom_data: _custom_data

                    """

        class Vlans(AvdIndexedList[int, VlansItem]):
            """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        class VpwsItem(AvdModel):
            """Subclass of AvdModel."""

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_export": {"type": str}, "_custom_data": {"type": dict}}
                import_export: str | None
                """Route Target."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, import_export: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            import_export: Route Target.
                            _custom_data: _custom_data

                        """

            class PseudowiresItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "id_local": {"type": int}, "id_remote": {"type": int}, "_custom_data": {"type": dict}}
                name: str
                """Pseudowire name."""
                id_local: int | None
                """Must match id_remote on other pe."""
                id_remote: int | None
                """Must match id_local on other pe."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        id_local: int | None | UndefinedType = Undefined,
                        id_remote: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PseudowiresItem.


                        Subclass of AvdModel.

                        Args:
                            name: Pseudowire name.
                            id_local: Must match id_remote on other pe.
                            id_remote: Must match id_local on other pe.
                            _custom_data: _custom_data

                        """

            class Pseudowires(AvdIndexedList[str, PseudowiresItem]):
                """Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Pseudowires._item_type = PseudowiresItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "rd": {"type": str},
                "route_targets": {"type": RouteTargets},
                "mpls_control_word": {"type": bool},
                "label_flow": {"type": bool},
                "mtu": {"type": int},
                "pseudowires": {"type": Pseudowires},
                "_custom_data": {"type": dict},
            }
            name: str
            """VPWS instance name."""
            rd: str | None
            """Route distinguisher."""
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            mpls_control_word: bool | None
            label_flow: bool | None
            mtu: int | None
            pseudowires: Pseudowires
            """Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    mpls_control_word: bool | None | UndefinedType = Undefined,
                    label_flow: bool | None | UndefinedType = Undefined,
                    mtu: int | None | UndefinedType = Undefined,
                    pseudowires: Pseudowires | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VpwsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VPWS instance name.
                        rd: Route distinguisher.
                        route_targets: Subclass of AvdModel.
                        mpls_control_word: mpls_control_word
                        label_flow: label_flow
                        mtu: mtu
                        pseudowires: Subclass of AvdIndexedList with `PseudowiresItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Vpws(AvdIndexedList[str, VpwsItem]):
            """Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vpws._item_type = VpwsItem

        class AddressFamilyEvpn(AvdModel):
            """Subclass of AvdModel."""

            class NeighborDefault(AvdModel):
                """Subclass of AvdModel."""

                class NextHopSelfReceivedEvpnRoutes(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "inter_domain": {"type": bool}, "_custom_data": {"type": dict}}
                    enable: bool | None
                    inter_domain: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enable: bool | None | UndefinedType = Undefined,
                            inter_domain: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NextHopSelfReceivedEvpnRoutes.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                inter_domain: inter_domain
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_received_evpn_routes": {"type": NextHopSelfReceivedEvpnRoutes},
                    "_custom_data": {"type": dict},
                }
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for neighbor."""
                next_hop_self_source_interface: str | None
                """Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`."""
                next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborDefault.


                        Subclass of AvdModel.

                        Args:
                            encapsulation: Transport encapsulation for neighbor.
                            next_hop_self_source_interface: Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`.
                            next_hop_self_received_evpn_routes: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class NextHopMplsResolutionRibsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rib_type": {"type": str}, "rib_name": {"type": str}, "_custom_data": {"type": dict}}
                rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"]
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"] | UndefinedType = Undefined,
                        rib_name: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopMplsResolutionRibsItem.


                        Subclass of AvdModel.

                        Args:
                            rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                            rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.
                            _custom_data: _custom_data

                        """

            class NextHopMplsResolutionRibs(AvdList[NextHopMplsResolutionRibsItem]):
                """Subclass of AvdList with `NextHopMplsResolutionRibsItem` items."""

            NextHopMplsResolutionRibs._item_type = NextHopMplsResolutionRibsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "additional_paths": {"type": AdditionalPaths},
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for the neighbor."""
                next_hop_self_source_interface: str | None
                """Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.
                            encapsulation: Transport encapsulation for the neighbor.
                            next_hop_self_source_interface: Source interface name for MPLS encapsulation. Requires `encapsulation` to be set as `mpls`.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "domain_remote": {"type": bool},
                    "encapsulation": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                domain_remote: bool | None
                encapsulation: Literal["vxlan", "mpls", "path-selection"] | None
                """Transport encapsulation for the peer-group."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        domain_remote: bool | None | UndefinedType = Undefined,
                        encapsulation: Literal["vxlan", "mpls", "path-selection"] | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            domain_remote: domain_remote
                            encapsulation: Transport encapsulation for the peer-group.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class EvpnHostflapDetection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "window": {"type": int},
                    "threshold": {"type": int},
                    "expiry_timeout": {"type": int},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                window: int | None
                """Time (in seconds) to detect a MAC duplication issue."""
                threshold: int | None
                """Minimum number of MAC moves that indicate a MAC Duplication issue."""
                expiry_timeout: int | None
                """Time (in seconds) to purge a MAC duplication issue."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        window: int | None | UndefinedType = Undefined,
                        threshold: int | None | UndefinedType = Undefined,
                        expiry_timeout: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnHostflapDetection.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            window: Time (in seconds) to detect a MAC duplication issue.
                            threshold: Minimum number of MAC moves that indicate a MAC Duplication issue.
                            expiry_timeout: Time (in seconds) to purge a MAC duplication issue.
                            _custom_data: _custom_data

                        """

            class NextHop(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"resolution_disabled": {"type": bool}, "_custom_data": {"type": dict}}
                resolution_disabled: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, resolution_disabled: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        NextHop.


                        Subclass of AvdModel.

                        Args:
                            resolution_disabled: resolution_disabled
                            _custom_data: _custom_data

                        """

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "import_match_failure_action": {"type": str},
                    "import_ethernet_segment_ip_mass_withdraw": {"type": bool},
                    "import_overlay_index_gateway": {"type": bool},
                    "export_ethernet_segment_ip_mass_withdraw": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                import_match_failure_action: Literal["discard"] | None
                import_ethernet_segment_ip_mass_withdraw: bool | None
                import_overlay_index_gateway: bool | None
                export_ethernet_segment_ip_mass_withdraw: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined,
                        import_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                        import_overlay_index_gateway: bool | None | UndefinedType = Undefined,
                        export_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action
                            import_ethernet_segment_ip_mass_withdraw: import_ethernet_segment_ip_mass_withdraw
                            import_overlay_index_gateway: import_overlay_index_gateway
                            export_ethernet_segment_ip_mass_withdraw: export_ethernet_segment_ip_mass_withdraw
                            _custom_data: _custom_data

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}, "_custom_data": {"type": dict}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Layer2FecInPlaceUpdate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool
                timeout: int | None
                """In-place FEC update tracking timeout in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        timeout: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Layer2FecInPlaceUpdate.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            timeout: In-place FEC update tracking timeout in seconds.
                            _custom_data: _custom_data

                        """

            class EvpnEthernetSegmentItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "domain": {"type": str},
                    "identifier": {"type": str},
                    "route_target_import": {"type": str},
                    "_custom_data": {"type": dict},
                }
                domain: Literal["all", "local", "remote"]
                identifier: str | None
                """EVPN Ethernet Segment Identifier (Type 1 format)."""
                route_target_import: str | None
                """Low-order 6 bytes of ES-Import Route Target."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        domain: Literal["all", "local", "remote"] | UndefinedType = Undefined,
                        identifier: str | None | UndefinedType = Undefined,
                        route_target_import: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnEthernetSegmentItem.


                        Subclass of AvdModel.

                        Args:
                            domain: domain
                            identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                            route_target_import: Low-order 6 bytes of ES-Import Route Target.
                            _custom_data: _custom_data

                        """

            class EvpnEthernetSegment(AvdIndexedList[str, EvpnEthernetSegmentItem]):
                """Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`)."""

                _primary_key: ClassVar[str] = "domain"

            EvpnEthernetSegment._item_type = EvpnEthernetSegmentItem

            class BgpAdditionalPaths(AvdModel):
                """Subclass of AvdModel."""

                class Send(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "any": {"type": bool},
                        "backup": {"type": bool},
                        "ecmp": {"type": bool},
                        "ecmp_limit": {"type": int},
                        "limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    any: bool | None
                    """Any eligible path."""
                    backup: bool | None
                    """Best path and installed backup path."""
                    ecmp: bool | None
                    """All paths in best path ECMP group."""
                    ecmp_limit: int | None
                    """Amount of ECMP paths to send."""
                    limit: int | None
                    """Amount of paths to send."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            any: bool | None | UndefinedType = Undefined,
                            backup: bool | None | UndefinedType = Undefined,
                            ecmp: bool | None | UndefinedType = Undefined,
                            ecmp_limit: int | None | UndefinedType = Undefined,
                            limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Send.


                            Subclass of AvdModel.

                            Args:
                                any: Any eligible path.
                                backup: Best path and installed backup path.
                                ecmp: All paths in best path ECMP group.
                                ecmp_limit: Amount of ECMP paths to send.
                                limit: Amount of paths to send.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": Send}, "_custom_data": {"type": dict}}
                receive: bool | None
                """Receive multiple paths."""
                send: Send
                """
                Send multiple paths.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        receive: bool | None | UndefinedType = Undefined,
                        send: Send | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BgpAdditionalPaths.


                        Subclass of AvdModel.

                        Args:
                            receive: Receive multiple paths.
                            send:
                               Send multiple paths.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "domain_identifier_remote": {"type": str},
                "neighbor_default": {"type": NeighborDefault},
                "next_hop_mpls_resolution_ribs": {"type": NextHopMplsResolutionRibs},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "evpn_hostflap_detection": {"type": EvpnHostflapDetection},
                "next_hop": {"type": NextHop},
                "route": {"type": Route},
                "next_hop_unchanged": {"type": bool},
                "bgp": {"type": Bgp},
                "layer_2_fec_in_place_update": {"type": Layer2FecInPlaceUpdate},
                "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
                "bgp_additional_paths": {"type": BgpAdditionalPaths},
                "_custom_data": {"type": dict},
            }
            domain_identifier: str | None
            domain_identifier_remote: str | None
            neighbor_default: NeighborDefault
            """Subclass of AvdModel."""
            next_hop_mpls_resolution_ribs: NextHopMplsResolutionRibs
            """
            Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
            lookups.

            Subclass of AvdList with `NextHopMplsResolutionRibsItem` items.
            """
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            evpn_hostflap_detection: EvpnHostflapDetection
            """Subclass of AvdModel."""
            next_hop: NextHop
            """Subclass of AvdModel."""
            route: Route
            """Subclass of AvdModel."""
            next_hop_unchanged: bool | None
            bgp: Bgp
            """Subclass of AvdModel."""
            layer_2_fec_in_place_update: Layer2FecInPlaceUpdate
            """
            BGP layer-2 in-place FEC operation.

            Subclass of AvdModel.
            """
            evpn_ethernet_segment: EvpnEthernetSegment
            """Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`)."""
            bgp_additional_paths: BgpAdditionalPaths
            """
            BGP additional-paths commands.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    domain_identifier_remote: str | None | UndefinedType = Undefined,
                    neighbor_default: NeighborDefault | UndefinedType = Undefined,
                    next_hop_mpls_resolution_ribs: NextHopMplsResolutionRibs | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    evpn_hostflap_detection: EvpnHostflapDetection | UndefinedType = Undefined,
                    next_hop: NextHop | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    layer_2_fec_in_place_update: Layer2FecInPlaceUpdate | UndefinedType = Undefined,
                    evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
                    bgp_additional_paths: BgpAdditionalPaths | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyEvpn.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        domain_identifier_remote: domain_identifier_remote
                        neighbor_default: Subclass of AvdModel.
                        next_hop_mpls_resolution_ribs:
                           Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
                           lookups.

                           Subclass of AvdList with `NextHopMplsResolutionRibsItem` items.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        evpn_hostflap_detection: Subclass of AvdModel.
                        next_hop: Subclass of AvdModel.
                        route: Subclass of AvdModel.
                        next_hop_unchanged: next_hop_unchanged
                        bgp: Subclass of AvdModel.
                        layer_2_fec_in_place_update:
                           BGP layer-2 in-place FEC operation.

                           Subclass of AvdModel.
                        evpn_ethernet_segment: Subclass of AvdIndexedList with `EvpnEthernetSegmentItem` items. Primary key is `domain` (`str`).
                        bgp_additional_paths:
                           BGP additional-paths commands.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class AddressFamilyRtc(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRouteTarget(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"only": {"type": bool}, "encoding_origin_as_omit": {"type": str}, "_custom_data": {"type": dict}}
                    only: bool | None
                    encoding_origin_as_omit: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            only: bool | None | UndefinedType = Undefined,
                            encoding_origin_as_omit: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRouteTarget.


                            Subclass of AvdModel.

                            Args:
                                only: only
                                encoding_origin_as_omit: encoding_origin_as_omit
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "default_route_target": {"type": DefaultRouteTarget},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                default_route_target: DefaultRouteTarget
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        default_route_target: DefaultRouteTarget | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            default_route_target: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"peer_groups": {"type": PeerGroups}, "_custom_data": {"type": dict}}
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, peer_groups: PeerGroups | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    AddressFamilyRtc.


                    Subclass of AvdModel.

                    Args:
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv4(AvdModel):
            """Subclass of AvdModel."""

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.
                            _custom_data: _custom_data

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "additional_paths": {"type": AdditionalPaths},
                    "redistribute_internal": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        redistribute_internal: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                            _custom_data: _custom_data

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"always": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    always: bool | None
                    route_map: str | None
                    """Route-map name."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            always: bool | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                always: always
                                route_map: Route-map name.
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                class NextHop(AvdModel):
                    """Subclass of AvdModel."""

                    class AddressFamilyIpv6(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "originate": {"type": bool}, "_custom_data": {"type": dict}}
                        enabled: bool
                        originate: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                originate: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AddressFamilyIpv6.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    originate: originate
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"address_family_ipv6": {"type": AddressFamilyIpv6}, "_custom_data": {"type": dict}}
                    address_family_ipv6: AddressFamilyIpv6
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NextHop.


                            Subclass of AvdModel.

                            Args:
                                address_family_ipv6: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "next_hop": {"type": NextHop},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                next_hop: NextHop
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        next_hop: NextHop | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_originate: Subclass of AvdModel.
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.
                            next_hop: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"always": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    always: bool | None
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            always: bool | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                always: always
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Prefix-list name."""
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Prefix-list name.
                            default_originate: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Rip(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Rip.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                    "_custom_data": {"type": dict},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                rip: Rip
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        rip: Rip | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            rip: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                        | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `static`, `isis`, `user`, `dynamic`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "_custom_data": {"type": dict},
            }
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    networks: Networks | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4.


                    Subclass of AvdModel.

                    Args:
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv4LabeledUnicast(AvdModel):
            """Subclass of AvdModel."""

            class AigpSession(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"confederation": {"type": bool}, "ebgp": {"type": bool}, "ibgp": {"type": bool}, "_custom_data": {"type": dict}}
                confederation: bool | None
                ebgp: bool | None
                ibgp: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        confederation: bool | None | UndefinedType = Undefined,
                        ebgp: bool | None | UndefinedType = Undefined,
                        ibgp: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AigpSession.


                        Subclass of AvdModel.

                        Args:
                            confederation: confederation
                            ebgp: ebgp
                            ibgp: ibgp
                            _custom_data: _custom_data

                        """

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}, "_custom_data": {"type": dict}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in: DirectionIn | UndefinedType = Undefined,
                            direction_out: DirectionOut | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "additional_paths": {"type": AdditionalPaths},
                    "missing_policy": {"type": MissingPolicy},
                    "next_hop_unchanged": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                missing_policy: MissingPolicy
                """
                Missing policy configuration for all address-families.

                Subclass of AvdModel.
                """
                next_hop_unchanged: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            missing_policy:
                               Missing policy configuration for all address-families.

                               Subclass of AvdModel.
                            next_hop_unchanged: next_hop_unchanged
                            _custom_data: _custom_data

                        """

            class NeighborDefault(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"next_hop_self": {"type": bool}, "_custom_data": {"type": dict}}
                next_hop_self: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, next_hop_self: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        NeighborDefault.


                        Subclass of AvdModel.

                        Args:
                            next_hop_self: next_hop_self
                            _custom_data: _custom_data

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                class GracefulRestartHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"stale_route_map": {"type": str}, "_custom_data": {"type": dict}}
                    stale_route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, stale_route_map: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            GracefulRestartHelper.


                            Subclass of AvdModel.

                            Args:
                                stale_route_map: stale_route_map
                                _custom_data: _custom_data

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}, "_custom_data": {"type": dict}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in: DirectionIn | UndefinedType = Undefined,
                            direction_out: DirectionOut | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                """Subclass of AvdModel."""
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """
                Missing policy configuration for BGP Labeled-Unicast neighbor.

                Subclass of AvdModel.
                """
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        aigp_session: bool | None | UndefinedType = Undefined,
                        graceful_restart: bool | None | UndefinedType = Undefined,
                        graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                        maximum_advertised_routes: int | None | UndefinedType = Undefined,
                        maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        multi_path: bool | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            aigp_session: aigp_session
                            graceful_restart: graceful_restart
                            graceful_restart_helper: Subclass of AvdModel.
                            maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                            maximum_advertised_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            missing_policy:
                               Missing policy configuration for BGP Labeled-Unicast neighbor.

                               Subclass of AvdModel.
                            multi_path: multi_path
                            next_hop_self: next_hop_self
                            next_hop_self_source_interface: Source interface name.
                            next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                            next_hop_unchanged: next_hop_unchanged
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                class GracefulRestartHelper(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"stale_route_map": {"type": str}, "_custom_data": {"type": dict}}
                    stale_route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, stale_route_map: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            GracefulRestartHelper.


                            Subclass of AvdModel.

                            Args:
                                stale_route_map: stale_route_map
                                _custom_data: _custom_data

                            """

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    class DirectionIn(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    class DirectionOut(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        action: Literal["deny", "permit", "deny-in-out"]
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                action: Literal["deny", "permit", "deny-in-out"] | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.


                                Subclass of AvdModel.

                                Args:
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}, "_custom_data": {"type": dict}}
                    direction_in: DirectionIn
                    """
                    Missing policy inbound direction.

                    Subclass of AvdModel.
                    """
                    direction_out: DirectionOut
                    """
                    Missing policy outbound direction.

                    Subclass of AvdModel.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in: DirectionIn | UndefinedType = Undefined,
                            direction_out: DirectionOut | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in:
                                   Missing policy inbound direction.

                                   Subclass of AvdModel.
                                direction_out:
                                   Missing policy outbound direction.

                                   Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                """Subclass of AvdModel."""
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """
                Missing policy configuration for BGP Labeled-Unicast neighbor.

                Subclass of AvdModel.
                """
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        aigp_session: bool | None | UndefinedType = Undefined,
                        graceful_restart: bool | None | UndefinedType = Undefined,
                        graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                        maximum_advertised_routes: int | None | UndefinedType = Undefined,
                        maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        multi_path: bool | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            aigp_session: aigp_session
                            graceful_restart: graceful_restart
                            graceful_restart_helper: Subclass of AvdModel.
                            maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                            maximum_advertised_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            missing_policy:
                               Missing policy configuration for BGP Labeled-Unicast neighbor.

                               Subclass of AvdModel.
                            multi_path: multi_path
                            next_hop_self: next_hop_self
                            next_hop_self_source_interface: Source interface name.
                            next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                            next_hop_unchanged: next_hop_unchanged
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.
                            _custom_data: _custom_data

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class NextHopsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "lfib_backup_ip_forwarding": {"type": bool}, "_custom_data": {"type": dict}}
                ip_address: str
                lfib_backup_ip_forwarding: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        lfib_backup_ip_forwarding: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            lfib_backup_ip_forwarding: lfib_backup_ip_forwarding
                            _custom_data: _custom_data

                        """

            class NextHops(AvdIndexedList[str, NextHopsItem]):
                """Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            NextHops._item_type = NextHopsItem

            class NextHopResolutionRibsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rib_type": {"type": str}, "rib_name": {"type": str}, "_custom_data": {"type": dict}}
                rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"]
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        rib_type: Literal["system-connected", "tunnel-rib-colored", "tunnel-rib"] | UndefinedType = Undefined,
                        rib_name: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopResolutionRibsItem.


                        Subclass of AvdModel.

                        Args:
                            rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                            rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.
                            _custom_data: _custom_data

                        """

            class NextHopResolutionRibs(AvdList[NextHopResolutionRibsItem]):
                """Subclass of AvdList with `NextHopResolutionRibsItem` items."""

            NextHopResolutionRibs._item_type = NextHopResolutionRibsItem

            class TunnelSourceProtocolsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protocol": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                protocol: Literal["isis segment-routing", "ldp"]
                rcf: str | None
                """
                Optional RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        protocol: Literal["isis segment-routing", "ldp"] | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TunnelSourceProtocolsItem.


                        Subclass of AvdModel.

                        Args:
                            protocol: protocol
                            rcf:
                               Optional RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            _custom_data: _custom_data

                        """

            class TunnelSourceProtocols(AvdIndexedList[str, TunnelSourceProtocolsItem]):
                """
                Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
                (`str`).
                """

                _primary_key: ClassVar[str] = "protocol"

            TunnelSourceProtocols._item_type = TunnelSourceProtocolsItem

            _fields: ClassVar[dict] = {
                "aigp_session": {"type": AigpSession},
                "bgp": {"type": Bgp},
                "graceful_restart": {"type": bool},
                "label_local_termination": {"type": str},
                "lfib_entry_installation_skipped": {"type": bool},
                "neighbor_default": {"type": NeighborDefault},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "networks": {"type": Networks},
                "next_hops": {"type": NextHops},
                "next_hop_resolution_ribs": {"type": NextHopResolutionRibs},
                "tunnel_source_protocols": {"type": TunnelSourceProtocols},
                "update_wait_for_convergence": {"type": bool},
                "_custom_data": {"type": dict},
            }
            aigp_session: AigpSession
            """Subclass of AvdModel."""
            bgp: Bgp
            """Subclass of AvdModel."""
            graceful_restart: bool | None
            label_local_termination: Literal["explicit-null", "implicit-null"] | None
            lfib_entry_installation_skipped: bool | None
            """Skip LFIB entry installation and next hop self route advertisements."""
            neighbor_default: NeighborDefault
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            next_hops: NextHops
            """Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`)."""
            next_hop_resolution_ribs: NextHopResolutionRibs
            """
            Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
            lookups.

            Subclass of AvdList with `NextHopResolutionRibsItem` items.
            """
            tunnel_source_protocols: TunnelSourceProtocols
            """
            Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
            (`str`).
            """
            update_wait_for_convergence: bool | None
            """Wait for BGP to converge before sending out any route updates."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    aigp_session: AigpSession | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    graceful_restart: bool | None | UndefinedType = Undefined,
                    label_local_termination: Literal["explicit-null", "implicit-null"] | None | UndefinedType = Undefined,
                    lfib_entry_installation_skipped: bool | None | UndefinedType = Undefined,
                    neighbor_default: NeighborDefault | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    next_hops: NextHops | UndefinedType = Undefined,
                    next_hop_resolution_ribs: NextHopResolutionRibs | UndefinedType = Undefined,
                    tunnel_source_protocols: TunnelSourceProtocols | UndefinedType = Undefined,
                    update_wait_for_convergence: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4LabeledUnicast.


                    Subclass of AvdModel.

                    Args:
                        aigp_session: Subclass of AvdModel.
                        bgp: Subclass of AvdModel.
                        graceful_restart: graceful_restart
                        label_local_termination: label_local_termination
                        lfib_entry_installation_skipped: Skip LFIB entry installation and next hop self route advertisements.
                        neighbor_default: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        next_hops: Subclass of AvdIndexedList with `NextHopsItem` items. Primary key is `ip_address` (`str`).
                        next_hop_resolution_ribs:
                           Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
                           lookups.

                           Subclass of AvdList with `NextHopResolutionRibsItem` items.
                        tunnel_source_protocols:
                           Subclass of AvdIndexedList with `TunnelSourceProtocolsItem` items. Primary key is `protocol`
                           (`str`).
                        update_wait_for_convergence: Wait for BGP to converge before sending out any route updates.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv4Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}, "_custom_data": {"type": dict}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "_custom_data": {"type": dict},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4Multicast.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv4SrTe(AvdModel):
            """Subclass of AvdModel."""

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}, "_custom_data": {"type": dict}}
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4SrTe.


                    Subclass of AvdModel.

                    Args:
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv6(AvdModel):
            """Subclass of AvdModel."""

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: Route-map name.
                            _custom_data: _custom_data

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "redistribute_internal": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        redistribute_internal: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix_list: str | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                prefix_list: Apply the configurations only to the routes matching the prefix list.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Dhcp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dhcp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dhcp": {"type": Dhcp},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "user": {"type": User},
                    "_custom_data": {"type": dict},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dhcp: Dhcp
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dhcp: Dhcp | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dhcp: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only used if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only used if `source_protocol` is one of `connected`,
                               `static`, `isis`, `user`, `dynamic`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "_custom_data": {"type": dict},
            }
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    networks: Networks | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6.


                    Subclass of AvdModel.

                    Args:
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv6Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "missing_policy": {"type": MissingPolicy},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: receive
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                prefix: str
                """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "_custom_data": {"type": dict},
                }
                connected: Connected
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            connected: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "include_leaked": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"]
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "networks": {"type": Networks},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6Multicast.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv6SrTe(AvdModel):
            """Subclass of AvdModel."""

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}, "_custom_data": {"type": dict}}
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6SrTe.


                    Subclass of AvdModel.

                    Args:
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyLinkState(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "_custom_data": {"type": dict}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "missing_policy": {"type": MissingPolicy},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            missing_policy: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "missing_policy": {"type": MissingPolicy},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            missing_policy: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PathSelection(AvdModel):
                """Subclass of AvdModel."""

                class Roles(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "producer": {"type": bool},
                        "consumer": {"type": bool},
                        "propagator": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    producer: bool | None
                    consumer: bool | None
                    propagator: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            producer: bool | None | UndefinedType = Undefined,
                            consumer: bool | None | UndefinedType = Undefined,
                            propagator: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Roles.


                            Subclass of AvdModel.

                            Args:
                                producer: producer
                                consumer: consumer
                                propagator: propagator
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"roles": {"type": Roles}, "_custom_data": {"type": dict}}
                roles: Roles
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, roles: Roles | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        PathSelection.


                        Subclass of AvdModel.

                        Args:
                            roles: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "path_selection": {"type": PathSelection},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            path_selection: PathSelection
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    path_selection: PathSelection | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyLinkState.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        path_selection: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class AddressFamilyFlowSpecIpv4(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "_custom_data": {"type": dict}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                ip_address: str
                activate: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                name: str
                """Peer-group name."""
                activate: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv4.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyFlowSpecIpv6(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class MissingPolicy(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                    direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                    direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.


                            Subclass of AvdModel.

                            Args:
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "_custom_data": {"type": dict}}
                missing_policy: MissingPolicy
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            missing_policy: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                ip_address: str
                activate: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                name: str
                """Peer-group name."""
                activate: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv6.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyPathSelection(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"additional_paths": {"type": AdditionalPaths}, "_custom_data": {"type": dict}}
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, additional_paths: AdditionalPaths | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "_custom_data": {"type": dict},
            }
            bgp: Bgp
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyPathSelection.


                    Subclass of AvdModel.

                    Args:
                        bgp: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class AddressFamilyVpnIpv4(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_match_failure_action": {"type": str}, "_custom_data": {"type": dict}}
                import_match_failure_action: Literal["discard"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_interface": {"type": str}, "_custom_data": {"type": dict}}
                source_interface: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, source_interface: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        NeighborDefaultEncapsulationMplsNextHopSelf.


                        Subclass of AvdModel.

                        Args:
                            source_interface: source_interface
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
                "_custom_data": {"type": dict},
            }
            domain_identifier: str | None
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            route: Route
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyVpnIpv4.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        route: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_default_encapsulation_mpls_next_hop_self: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class AddressFamilyVpnIpv6(AvdModel):
            """Subclass of AvdModel."""

            class PeerGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeerGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Peer-group name.
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class PeerGroups(AvdIndexedList[str, PeerGroupsItem]):
                """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"import_match_failure_action": {"type": str}, "_custom_data": {"type": dict}}
                import_match_failure_action: Literal["discard"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        import_match_failure_action: Literal["discard"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Route.


                        Subclass of AvdModel.

                        Args:
                            import_match_failure_action: import_match_failure_action
                            _custom_data: _custom_data

                        """

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultRoute(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultRoute.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        default_route: DefaultRoute | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            default_route: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_interface": {"type": str}, "_custom_data": {"type": dict}}
                source_interface: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, source_interface: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        NeighborDefaultEncapsulationMplsNextHopSelf.


                        Subclass of AvdModel.

                        Args:
                            source_interface: source_interface
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
                "_custom_data": {"type": dict},
            }
            domain_identifier: str | None
            peer_groups: PeerGroups
            """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
            route: Route
            """Subclass of AvdModel."""
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    domain_identifier: str | None | UndefinedType = Undefined,
                    peer_groups: PeerGroups | UndefinedType = Undefined,
                    route: Route | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyVpnIpv6.


                    Subclass of AvdModel.

                    Args:
                        domain_identifier: domain_identifier
                        peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                        route: Subclass of AvdModel.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_default_encapsulation_mpls_next_hop_self: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Bgp(AvdModel):
                """Subclass of AvdModel."""

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "redistribute_internal": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        redistribute_internal: bool | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.


                        Subclass of AvdModel.

                        Args:
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class EvpnMulticastAddressFamily(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"transit": {"type": bool}, "_custom_data": {"type": dict}}
                    transit: bool | None
                    """Enable EVPN multicast transit mode."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, transit: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Ipv4.


                            Subclass of AvdModel.

                            Args:
                                transit: Enable EVPN multicast transit mode.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
                ipv4: Ipv4
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        EvpnMulticastAddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class EvpnMulticastGatewayDrElection(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"algorithm": {"type": str}, "preference_value": {"type": int}, "_custom_data": {"type": dict}}
                algorithm: Literal["hrw", "modulus", "preference"]
                """
                DR election algorithms:
                  hrw: Default selection based on highest random weight.
                  modulus:
                Selection based on VLAN ID modulo number of candidates.
                  preference: Selection based on a
                configured preference value.
                """
                preference_value: int | None
                """Required when `algorithm` is `preference`."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        algorithm: Literal["hrw", "modulus", "preference"] | UndefinedType = Undefined,
                        preference_value: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnMulticastGatewayDrElection.


                        Subclass of AvdModel.

                        Args:
                            algorithm:
                               DR election algorithms:
                                 hrw: Default selection based on highest random weight.
                                 modulus:
                               Selection based on VLAN ID modulo number of candidates.
                                 preference: Selection based on a
                               configured preference value.
                            preference_value: Required when `algorithm` is `preference`.
                            _custom_data: _custom_data

                        """

            class DefaultRouteExportsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "address_family": {"type": str},
                    "always": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "_custom_data": {"type": dict},
                }
                address_family: Literal["evpn", "vpn-ipv4", "vpn-ipv6"]
                always: bool | None
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address_family: Literal["evpn", "vpn-ipv4", "vpn-ipv6"] | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRouteExportsItem.


                        Subclass of AvdModel.

                        Args:
                            address_family: address_family
                            always: always
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            _custom_data: _custom_data

                        """

            class DefaultRouteExports(AvdIndexedList[str, DefaultRouteExportsItem]):
                """
                Subclass of AvdIndexedList with `DefaultRouteExportsItem` items. Primary key is `address_family`
                (`str`).
                """

                _primary_key: ClassVar[str] = "address_family"

            DefaultRouteExports._item_type = DefaultRouteExportsItem

            class RouteTargets(AvdModel):
                """Subclass of AvdModel."""

                class ImportItem(AvdModel):
                    """Subclass of AvdModel."""

                    class RouteTargets(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    RouteTargets._item_type = str

                    _fields: ClassVar[dict] = {
                        "address_family": {"type": str},
                        "route_targets": {"type": RouteTargets},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vpn_route_filter_rcf": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    address_family: str
                    route_targets: RouteTargets
                    """Subclass of AvdList with `str` items."""
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address_family: str | UndefinedType = Undefined,
                            route_targets: RouteTargets | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            vpn_route_filter_rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ImportItem.


                            Subclass of AvdModel.

                            Args:
                                address_family: address_family
                                route_targets: Subclass of AvdList with `str` items.
                                route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   Only applicable if `address_family`
                                   is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                vpn_route_filter_rcf:
                                   RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                                   Example:  # fmt: skip
                                   MyFunction(myarg).
                                   Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                                _custom_data: _custom_data

                            """

                class Import(AvdIndexedList[str, ImportItem]):
                    """Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`)."""

                    _primary_key: ClassVar[str] = "address_family"

                Import._item_type = ImportItem

                class ExportItem(AvdModel):
                    """Subclass of AvdModel."""

                    class RouteTargets(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    RouteTargets._item_type = str

                    _fields: ClassVar[dict] = {
                        "address_family": {"type": str},
                        "route_targets": {"type": RouteTargets},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vrf_route_filter_rcf": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    address_family: str
                    route_targets: RouteTargets
                    """Subclass of AvdList with `str` items."""
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vrf_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VRF routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address_family: str | UndefinedType = Undefined,
                            route_targets: RouteTargets | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            vrf_route_filter_rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ExportItem.


                            Subclass of AvdModel.

                            Args:
                                address_family: address_family
                                route_targets: Subclass of AvdList with `str` items.
                                route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   Only applicable if `address_family`
                                   is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                                vrf_route_filter_rcf:
                                   RCF function name with parenthesis for filtering VRF routes. Also requires `rcf` to be set.
                                   Example:  # fmt: skip
                                   MyFunction(myarg).
                                   Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                                _custom_data: _custom_data

                            """

                class Export(AvdIndexedList[str, ExportItem]):
                    """Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`)."""

                    _primary_key: ClassVar[str] = "address_family"

                Export._item_type = ExportItem

                _fields: ClassVar[dict] = {"field_import": {"type": Import}, "export": {"type": Export}, "_custom_data": {"type": dict}}
                _field_to_key_map: ClassVar[dict] = {"field_import": "import"}
                _key_to_field_map: ClassVar[dict] = {"import": "field_import"}
                field_import: Import
                """Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`)."""
                export: Export
                """Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        field_import: Import | UndefinedType = Undefined,
                        export: Export | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouteTargets.


                        Subclass of AvdModel.

                        Args:
                            field_import: Subclass of AvdIndexedList with `ImportItem` items. Primary key is `address_family` (`str`).
                            export: Subclass of AvdIndexedList with `ExportItem` items. Primary key is `address_family` (`str`).
                            _custom_data: _custom_data

                        """

            class NetworksItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Networks(AvdIndexedList[str, NetworksItem]):
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class MaximumPaths(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"paths": {"type": int}, "ecmp": {"type": int}, "_custom_data": {"type": dict}}
                paths: int
                ecmp: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        paths: int | UndefinedType = Undefined,
                        ecmp: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MaximumPaths.


                        Subclass of AvdModel.

                        Args:
                            paths: paths
                            ecmp: ecmp
                            _custom_data: _custom_data

                        """

            class Updates(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}, "_custom_data": {"type": dict}}
                wait_for_convergence: bool | None
                """
                Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                convergence state is reached.
                """
                wait_install: bool | None
                """
                Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                This
                will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                that may not yet be installed into the forwarding plane.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        wait_for_convergence: bool | None | UndefinedType = Undefined,
                        wait_install: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Updates.


                        Subclass of AvdModel.

                        Args:
                            wait_for_convergence:
                               Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                               convergence state is reached.
                            wait_install:
                               Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                               This
                               will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                               that may not yet be installed into the forwarding plane.
                            _custom_data: _custom_data

                        """

            class ListenRangesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "prefix": {"type": str},
                    "peer_id_include_router_id": {"type": bool},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "remote_as": {"type": str},
                    "_custom_data": {"type": dict},
                }
                prefix: str | None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                peer_id_include_router_id: bool | None
                """Include router ID as part of peer filter."""
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """
                Peer-filter name.
                note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                If both
                are defined, peer_filter takes precedence.
                """
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | None | UndefinedType = Undefined,
                        peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        peer_filter: str | None | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ListenRangesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            peer_id_include_router_id: Include router ID as part of peer filter.
                            peer_group: Peer-group name.
                            peer_filter:
                               Peer-filter name.
                               note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                               If both
                               are defined, peer_filter takes precedence.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            _custom_data: _custom_data

                        """

            class ListenRanges(AvdList[ListenRangesItem]):
                """Subclass of AvdList with `ListenRangesItem` items."""

            ListenRanges._item_type = ListenRangesItem

            class NeighborsItem(AvdModel):
                """Subclass of AvdModel."""

                class RemovePrivateAs(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    all: bool | None
                    replace_as: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            all: bool | None | UndefinedType = Undefined,
                            replace_as: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RemovePrivateAs.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                all: all
                                replace_as: replace_as
                                _custom_data: _custom_data

                            """

                class RemovePrivateAsIngress(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "replace_as": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    replace_as: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            replace_as: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RemovePrivateAsIngress.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                replace_as: replace_as
                                _custom_data: _custom_data

                            """

                class AsPath(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}, "_custom_data": {"type": dict}}
                    remote_as_replace_out: bool | None
                    """Replace AS number with local AS number."""
                    prepend_own_disabled: bool | None
                    """Disable prepending own AS number to AS path."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            remote_as_replace_out: bool | None | UndefinedType = Undefined,
                            prepend_own_disabled: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AsPath.


                            Subclass of AvdModel.

                            Args:
                                remote_as_replace_out: Replace AS number with local AS number.
                                prepend_own_disabled: Disable prepending own AS number to AS path.
                                _custom_data: _custom_data

                            """

                class BfdTimers(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}, "_custom_data": {"type": dict}}
                    interval: int
                    """Interval in milliseconds."""
                    min_rx: int
                    """Rate in milliseconds."""
                    multiplier: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | UndefinedType = Undefined,
                            min_rx: int | UndefinedType = Undefined,
                            multiplier: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdTimers.


                            Subclass of AvdModel.

                            Args:
                                interval: Interval in milliseconds.
                                min_rx: Rate in milliseconds.
                                multiplier: multiplier
                                _custom_data: _custom_data

                            """

                class RibInPrePolicyRetain(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "all": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    all: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            all: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RibInPrePolicyRetain.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                all: all
                                _custom_data: _custom_data

                            """

                class AllowasIn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "times": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    times: int | None
                    """Number of local ASNs allowed in a BGP update."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            times: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AllowasIn.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                times: Number of local ASNs allowed in a BGP update.
                                _custom_data: _custom_data

                            """

                class DefaultOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    always: bool | None
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            always: bool | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultOriginate.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                always: always
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class AdditionalPaths(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}, "_custom_data": {"type": dict}}
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            receive: bool | None | UndefinedType = Undefined,
                            send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.


                            Subclass of AvdModel.

                            Args:
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ip_address": {"type": str},
                    "peer_group": {"type": str},
                    "remote_as": {"type": str},
                    "password": {"type": str},
                    "passive": {"type": bool},
                    "remove_private_as": {"type": RemovePrivateAs},
                    "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                    "weight": {"type": int},
                    "local_as": {"type": str},
                    "as_path": {"type": AsPath},
                    "description": {"type": str},
                    "route_reflector_client": {"type": bool},
                    "ebgp_multihop": {"type": int},
                    "next_hop_self": {"type": bool},
                    "shutdown": {"type": bool},
                    "bfd": {"type": bool},
                    "bfd_timers": {"type": BfdTimers},
                    "timers": {"type": str},
                    "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                    "send_community": {"type": str},
                    "maximum_routes": {"type": int},
                    "maximum_routes_warning_limit": {"type": str},
                    "maximum_routes_warning_only": {"type": bool},
                    "allowas_in": {"type": AllowasIn},
                    "default_originate": {"type": DefaultOriginate},
                    "update_source": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "_custom_data": {"type": dict},
                }
                ip_address: str
                peer_group: str | None
                """Peer-group name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                password: str | None
                passive: bool | None
                remove_private_as: RemovePrivateAs
                """
                Remove private AS numbers in outbound AS path.

                Subclass of AvdModel.
                """
                remove_private_as_ingress: RemovePrivateAsIngress
                """Subclass of AvdModel."""
                weight: int | None
                local_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                as_path: AsPath
                """
                BGP AS-PATH options.

                Subclass of AvdModel.
                """
                description: str | None
                route_reflector_client: bool | None
                ebgp_multihop: int | None
                """Time-to-live in range of hops."""
                next_hop_self: bool | None
                shutdown: bool | None
                bfd: bool | None
                """Enable BFD."""
                bfd_timers: BfdTimers
                """
                Override default BFD timers. BFD must be enabled with `bfd: true`.

                Subclass of AvdModel.
                """
                timers: str | None
                """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                rib_in_pre_policy_retain: RibInPrePolicyRetain
                """Subclass of AvdModel."""
                send_community: str | None
                """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                maximum_routes: int | None
                maximum_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                maximum_routes_warning_only: bool | None
                allowas_in: AllowasIn
                """Subclass of AvdModel."""
                default_originate: DefaultOriginate
                """Subclass of AvdModel."""
                update_source: str | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        passive: bool | None | UndefinedType = Undefined,
                        remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                        remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                        weight: int | None | UndefinedType = Undefined,
                        local_as: str | None | UndefinedType = Undefined,
                        as_path: AsPath | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        route_reflector_client: bool | None | UndefinedType = Undefined,
                        ebgp_multihop: int | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bfd_timers: BfdTimers | UndefinedType = Undefined,
                        timers: str | None | UndefinedType = Undefined,
                        rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                        send_community: str | None | UndefinedType = Undefined,
                        maximum_routes: int | None | UndefinedType = Undefined,
                        maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                        maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                        allowas_in: AllowasIn | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        update_source: str | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            peer_group: Peer-group name.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            password: password
                            passive: passive
                            remove_private_as:
                               Remove private AS numbers in outbound AS path.

                               Subclass of AvdModel.
                            remove_private_as_ingress: Subclass of AvdModel.
                            weight: weight
                            local_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            as_path:
                               BGP AS-PATH options.

                               Subclass of AvdModel.
                            description: description
                            route_reflector_client: route_reflector_client
                            ebgp_multihop: Time-to-live in range of hops.
                            next_hop_self: next_hop_self
                            shutdown: shutdown
                            bfd: Enable BFD.
                            bfd_timers:
                               Override default BFD timers. BFD must be enabled with `bfd: true`.

                               Subclass of AvdModel.
                            timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                            rib_in_pre_policy_retain: Subclass of AvdModel.
                            send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                            maximum_routes: maximum_routes
                            maximum_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            maximum_routes_warning_only: maximum_routes_warning_only
                            allowas_in: Subclass of AvdModel.
                            default_originate: Subclass of AvdModel.
                            update_source: update_source
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Neighbors(AvdIndexedList[str, NeighborsItem]):
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborInterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "remote_as": {"type": str},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "description": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Interface name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """Peer-filter name."""
                description: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        peer_group: str | None | UndefinedType = Undefined,
                        peer_filter: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborInterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Interface name.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            peer_group: Peer-group name.
                            peer_filter: Peer-filter name.
                            description: description
                            _custom_data: _custom_data

                        """

            class NeighborInterfaces(AvdIndexedList[str, NeighborInterfacesItem]):
                """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            NeighborInterfaces._item_type = NeighborInterfacesItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class AttachedHost(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                class Isis(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospf(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPF routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPF routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPF routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPF routes.
                                match_external:
                                   Redistribute OSPF routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPF routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPF routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Ospfv3(AvdModel):
                    """Subclass of AvdModel."""

                    class MatchExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchInternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class MatchNssaExternal(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        nssa_type: Literal[1, 2] | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """
                    Redistribute OSPFv3 routes learned from external sources.

                    Subclass of AvdModel.
                    """
                    match_internal: MatchInternal
                    """
                    Redistribute OSPFv3 routes learned from internal sources.

                    Subclass of AvdModel.
                    """
                    match_nssa_external: MatchNssaExternal
                    """
                    Redistribute OSPFv3 routes learned from external NSSA sources.

                    Subclass of AvdModel.
                    """
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.


                            Subclass of AvdModel.

                            Args:
                                enabled: Redistribute OSPFv3 routes.
                                match_external:
                                   Redistribute OSPFv3 routes learned from external sources.

                                   Subclass of AvdModel.
                                match_internal:
                                   Redistribute OSPFv3 routes learned from internal sources.

                                   Subclass of AvdModel.
                                match_nssa_external:
                                   Redistribute OSPFv3 routes learned from external NSSA sources.

                                   Subclass of AvdModel.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class Rip(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Rip.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.
                                _custom_data: _custom_data

                            """

                class User(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            User.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                    "_custom_data": {"type": dict},
                }
                attached_host: AttachedHost
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                dynamic: Dynamic
                """Subclass of AvdModel."""
                isis: Isis
                """Subclass of AvdModel."""
                ospf: Ospf
                """Subclass of AvdModel."""
                ospfv3: Ospfv3
                """Subclass of AvdModel."""
                rip: Rip
                """Subclass of AvdModel."""
                static: Static
                """Subclass of AvdModel."""
                user: User
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        rip: Rip | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            attached_host: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            dynamic: Subclass of AvdModel.
                            isis: Subclass of AvdModel.
                            ospf: Subclass of AvdModel.
                            ospfv3: Subclass of AvdModel.
                            rip: Subclass of AvdModel.
                            static: Subclass of AvdModel.
                            user: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                    "_custom_data": {"type": dict},
                }
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `dynamic`, `isis`, `static` and `user`.
                """
                ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                        | None
                        | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.
                            _custom_data: _custom_data

                        """

            class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                """Subclass of AvdList with `RedistributeRoutesItem` items."""

            RedistributeRoutes._item_type = RedistributeRoutesItem

            class AggregateAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "prefix": {"type": str},
                    "advertise_only": {"type": bool},
                    "as_set": {"type": bool},
                    "summary_only": {"type": bool},
                    "attribute_map": {"type": str},
                    "match_map": {"type": str},
                    "_custom_data": {"type": dict},
                }
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                advertise_only: bool | None
                as_set: bool | None
                summary_only: bool | None
                attribute_map: str | None
                match_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        advertise_only: bool | None | UndefinedType = Undefined,
                        as_set: bool | None | UndefinedType = Undefined,
                        summary_only: bool | None | UndefinedType = Undefined,
                        attribute_map: str | None | UndefinedType = Undefined,
                        match_map: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AggregateAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            advertise_only: advertise_only
                            as_set: as_set
                            summary_only: summary_only
                            attribute_map: attribute_map
                            match_map: match_map
                            _custom_data: _custom_data

                        """

            class AggregateAddresses(AvdIndexedList[str, AggregateAddressesItem]):
                """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            AggregateAddresses._item_type = AggregateAddressesItem

            class AddressFamilyIpv4(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                install: bool | None | UndefinedType = Undefined,
                                install_ecmp_primary: bool | None | UndefinedType = Undefined,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    install: Install BGP backup path.
                                    install_ecmp_primary: Allow additional path with ECMP primary path.
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            redistribute_internal: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class NextHop(AvdModel):
                        """Subclass of AvdModel."""

                        class AddressFamilyIpv6(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "originate": {"type": bool}, "_custom_data": {"type": dict}}
                            enabled: bool
                            originate: bool | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    originate: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    AddressFamilyIpv6.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        originate: originate
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {"address_family_ipv6": {"type": AddressFamilyIpv6}, "_custom_data": {"type": dict}}
                        address_family_ipv6: AddressFamilyIpv6
                        """Subclass of AvdModel."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                NextHop.


                                Subclass of AvdModel.

                                Args:
                                    address_family_ipv6: Subclass of AvdModel.
                                    _custom_data: _custom_data

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "next_hop": {"type": NextHop},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    next_hop: NextHop
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            rcf_in: str | None | UndefinedType = Undefined,
                            rcf_out: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                            next_hop: NextHop | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                rcf_in:
                                   Inbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                rcf_out:
                                   Outbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.
                                next_hop: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    prefix: str
                    """IPv4 prefix "A.B.C.D/E"."""
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix: str | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv4 prefix "A.B.C.D/E".
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Bgp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Dynamic(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dynamic.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    _custom_data: _custom_data

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Rip(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Rip.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class User(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                User.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "rip": {"type": Rip},
                        "static": {"type": Static},
                        "user": {"type": User},
                        "_custom_data": {"type": dict},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    bgp: Bgp
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    dynamic: Dynamic
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    rip: Rip
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    user: User
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            dynamic: Dynamic | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            rip: Rip | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            user: User | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                bgp: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                dynamic: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                rip: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                user: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                            | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: include_leaked
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is one of `connected`,
                                   `dynamic`, `isis`, `static` and `user`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                    "_custom_data": {"type": dict},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv4.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                            _custom_data: _custom_data

                        """

            class AddressFamilyIpv6(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                install: bool | None | UndefinedType = Undefined,
                                install_ecmp_primary: bool | None | UndefinedType = Undefined,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    install: Install BGP backup path.
                                    install_ecmp_primary: Allow additional path with ECMP primary path.
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            redistribute_internal: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                            "_custom_data": {"type": dict},
                        }
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                receive: bool | None | UndefinedType = Undefined,
                                send: Literal["any", "backup", "ecmp", "limit", "disabled"] | None | UndefinedType = Undefined,
                                send_limit: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: Enable or disable reception of additional-paths.
                                    send:
                                       Select an option to send multiple paths for same prefix through bgp updates.
                                       any: Send any eligible
                                       path.
                                       backup: Best path and installed backup path.
                                       ecmp: All paths in best path ECMP group.
                                       limit:
                                       Limit to n eligible paths.
                                       disabled: Disable sending any paths.
                                    send_limit:
                                       Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                       `ecmp`.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            rcf_in: str | None | UndefinedType = Undefined,
                            rcf_out: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                rcf_in:
                                   Inbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                rcf_out:
                                   Outbound RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix: str | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Bgp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Dhcp(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dhcp.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Dynamic(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dynamic.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    _custom_data: _custom_data

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class User(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                User.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dhcp": {"type": Dhcp},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                        "user": {"type": User},
                        "_custom_data": {"type": dict},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    bgp: Bgp
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    dhcp: Dhcp
                    """Subclass of AvdModel."""
                    dynamic: Dynamic
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    user: User
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            dhcp: Dhcp | UndefinedType = Undefined,
                            dynamic: Dynamic | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            user: User | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                bgp: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                dhcp: Subclass of AvdModel.
                                dynamic: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                user: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    source_protocol: Literal["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]
                            | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: include_leaked
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is one of `connected`,
                                   `dynamic`, `isis`, `static` and `user`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                    "_custom_data": {"type": dict},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv6.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                            _custom_data: _custom_data

                        """

            class AddressFamilyIpv4Multicast(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                        receive: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                        receive: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    prefix: str
                    """IPv6 prefix "A.B.C.D/E"."""
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix: str | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A.B.C.D/E".
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class AttachedHost(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AttachedHost.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    include_leaked: bool | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        include_leaked: Include following routes while redistributing.
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "attached_host": {"type": AttachedHost},
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                        "_custom_data": {"type": dict},
                    }
                    attached_host: AttachedHost
                    """Subclass of AvdModel."""
                    connected: Connected
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            attached_host: AttachedHost | UndefinedType = Undefined,
                            connected: Connected | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                attached_host: Subclass of AvdModel.
                                connected: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    source_protocol: Literal["attached-host", "connected", "isis", "ospf", "ospfv3", "static"]
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["attached-host", "connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: Only applicable if `source_protocol` is `isis`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is `isis`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                    "_custom_data": {"type": dict},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv4Multicast.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                            _custom_data: _custom_data

                        """

            class AddressFamilyIpv6Multicast(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                        receive: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class AdditionalPaths(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"receive": {"type": bool}, "_custom_data": {"type": dict}}
                        receive: bool | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, receive: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                AdditionalPaths.


                                Subclass of AvdModel.

                                Args:
                                    receive: receive
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                        "_custom_data": {"type": dict},
                    }
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            additional_paths: AdditionalPaths | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                additional_paths: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"prefix": {"type": str}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefix: str | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NetworksItem.


                            Subclass of AvdModel.

                            Args:
                                prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                                route_map: route_map
                                _custom_data: _custom_data

                            """

                class Networks(AvdIndexedList[str, NetworksItem]):
                    """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""

                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    """Subclass of AvdModel."""

                    class Connected(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Connected.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Isis(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool
                        isis_level: Literal["level-1", "level-2", "level-1-2"] | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                isis_level: Literal["level-1", "level-2", "level-1-2"] | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                rcf: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Isis.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    isis_level: Redistribute IS-IS route level.
                                    route_map: route_map
                                    rcf:
                                       RCF function name with parenthesis.
                                       Example: MyFunction(myarg).
                                       `route_map` and `rcf` are mutually
                                       exclusive. `route_map` takes precedence.
                                    include_leaked: Include following routes while redistributing.
                                    _custom_data: _custom_data

                                """

                    class Ospf(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPF routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPF routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPF routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPF routes.
                                    match_external:
                                       Redistribute OSPF routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPF routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPF routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Ospfv3(AvdModel):
                        """Subclass of AvdModel."""

                        class MatchExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchInternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                            enabled: bool
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchInternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        class MatchNssaExternal(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "_custom_data": {"type": dict},
                            }
                            enabled: bool
                            nssa_type: Literal[1, 2] | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    enabled: bool | UndefinedType = Undefined,
                                    nssa_type: Literal[1, 2] | None | UndefinedType = Undefined,
                                    route_map: str | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MatchNssaExternal.


                                    Subclass of AvdModel.

                                    Args:
                                        enabled: enabled
                                        nssa_type: NSSA External Type Number.
                                        route_map: route_map
                                        _custom_data: _custom_data

                                    """

                        _fields: ClassVar[dict] = {
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """
                        Redistribute OSPFv3 routes learned from external sources.

                        Subclass of AvdModel.
                        """
                        match_internal: MatchInternal
                        """
                        Redistribute OSPFv3 routes learned from internal sources.

                        Subclass of AvdModel.
                        """
                        match_nssa_external: MatchNssaExternal
                        """
                        Redistribute OSPFv3 routes learned from external NSSA sources.

                        Subclass of AvdModel.
                        """
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | None | UndefinedType = Undefined,
                                match_external: MatchExternal | UndefinedType = Undefined,
                                match_internal: MatchInternal | UndefinedType = Undefined,
                                match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospfv3.


                                Subclass of AvdModel.

                                Args:
                                    enabled: Redistribute OSPFv3 routes.
                                    match_external:
                                       Redistribute OSPFv3 routes learned from external sources.

                                       Subclass of AvdModel.
                                    match_internal:
                                       Redistribute OSPFv3 routes learned from internal sources.

                                       Subclass of AvdModel.
                                    match_nssa_external:
                                       Redistribute OSPFv3 routes learned from external NSSA sources.

                                       Subclass of AvdModel.
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    class Static(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "route_map": {"type": str}, "_custom_data": {"type": dict}}
                        enabled: bool
                        route_map: str | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Static.


                                Subclass of AvdModel.

                                Args:
                                    enabled: enabled
                                    route_map: route_map
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                        "_custom_data": {"type": dict},
                    }
                    connected: Connected
                    """Subclass of AvdModel."""
                    isis: Isis
                    """Subclass of AvdModel."""
                    ospf: Ospf
                    """Subclass of AvdModel."""
                    ospfv3: Ospfv3
                    """Subclass of AvdModel."""
                    static: Static
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            connected: Connected | UndefinedType = Undefined,
                            isis: Isis | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            ospfv3: Ospfv3 | UndefinedType = Undefined,
                            static: Static | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Redistribute.


                            Subclass of AvdModel.

                            Args:
                                connected: Subclass of AvdModel.
                                isis: Subclass of AvdModel.
                                ospf: Subclass of AvdModel.
                                ospfv3: Subclass of AvdModel.
                                static: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"]
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"] | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_protocol: Literal["connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            ospf_route_type: Literal["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]
                            | None
                            | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RedistributeRoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_protocol: source_protocol
                                route_map: route_map
                                include_leaked: Only applicable if `source_protocol` is `isis`.
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                   Only applicable if `source_protocol` is `isis`.
                                ospf_route_type:
                                   Routes learned by the OSPF protocol.
                                   The `ospf_route_type` is valid for source_protocols 'ospf' and
                                   'ospfv3'.
                                _custom_data: _custom_data

                            """

                class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
                    """Subclass of AvdList with `RedistributeRoutesItem` items."""

                RedistributeRoutes._item_type = RedistributeRoutesItem

                _fields: ClassVar[dict] = {
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": RedistributeRoutes},
                    "_custom_data": {"type": dict},
                }
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                networks: Networks
                """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
                redistribute: Redistribute
                """
                Redistribute routes in to BGP.

                Subclass of AvdModel.
                """
                redistribute_routes: RedistributeRoutes
                """Subclass of AvdList with `RedistributeRoutesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        networks: Networks | UndefinedType = Undefined,
                        redistribute: Redistribute | UndefinedType = Undefined,
                        redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyIpv6Multicast.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                            redistribute:
                               Redistribute routes in to BGP.

                               Subclass of AvdModel.
                            redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                            _custom_data: _custom_data

                        """

            class AddressFamilyFlowSpecIpv4(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "_custom_data": {"type": dict}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                    ip_address: str
                    activate: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}, "_custom_data": {"type": dict}}
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyFlowSpecIpv4.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            _custom_data: _custom_data

                        """

            class AddressFamilyFlowSpecIpv6(AvdModel):
                """Subclass of AvdModel."""

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    class MissingPolicy(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"direction_in_action": {"type": str}, "direction_out_action": {"type": str}, "_custom_data": {"type": dict}}
                        direction_in_action: Literal["deny", "deny-in-out", "permit"] | None
                        direction_out_action: Literal["deny", "deny-in-out", "permit"] | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                direction_in_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                direction_out_action: Literal["deny", "deny-in-out", "permit"] | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.


                                Subclass of AvdModel.

                                Args:
                                    direction_in_action: direction_in_action
                                    direction_out_action: direction_out_action
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"missing_policy": {"type": MissingPolicy}, "_custom_data": {"type": dict}}
                    missing_policy: MissingPolicy
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, missing_policy: MissingPolicy | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                missing_policy: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class NeighborsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"ip_address": {"type": str}, "activate": {"type": bool}, "_custom_data": {"type": dict}}
                    ip_address: str
                    activate: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            ip_address: str | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NeighborsItem.


                            Subclass of AvdModel.

                            Args:
                                ip_address: ip_address
                                activate: activate
                                _custom_data: _custom_data

                            """

                class Neighbors(AvdIndexedList[str, NeighborsItem]):
                    """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""

                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}, "_custom_data": {"type": dict}}
                bgp: Bgp
                """Subclass of AvdModel."""
                neighbors: Neighbors
                """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bgp: Bgp | UndefinedType = Undefined,
                        neighbors: Neighbors | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamilyFlowSpecIpv6.


                        Subclass of AvdModel.

                        Args:
                            bgp: Subclass of AvdModel.
                            neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "bgp": {"type": Bgp},
                "rd": {"type": str},
                "evpn_multicast": {"type": bool},
                "evpn_multicast_address_family": {"type": EvpnMulticastAddressFamily},
                "evpn_multicast_gateway_dr_election": {"type": EvpnMulticastGatewayDrElection},
                "default_route_exports": {"type": DefaultRouteExports},
                "route_targets": {"type": RouteTargets},
                "router_id": {"type": str},
                "timers": {"type": str},
                "networks": {"type": Networks},
                "maximum_paths": {"type": MaximumPaths},
                "updates": {"type": Updates},
                "listen_ranges": {"type": ListenRanges},
                "neighbors": {"type": Neighbors},
                "neighbor_interfaces": {"type": NeighborInterfaces},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": RedistributeRoutes},
                "aggregate_addresses": {"type": AggregateAddresses},
                "address_family_ipv4": {"type": AddressFamilyIpv4},
                "address_family_ipv6": {"type": AddressFamilyIpv6},
                "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
                "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
                "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
                "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
                "eos_cli": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """VRF name."""
            bgp: Bgp
            """Subclass of AvdModel."""
            rd: str | None
            """Route distinguisher."""
            evpn_multicast: bool | None
            evpn_multicast_address_family: EvpnMulticastAddressFamily
            """
            Enable per-AF EVPN multicast settings.

            Subclass of AvdModel.
            """
            evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection
            """Subclass of AvdModel."""
            default_route_exports: DefaultRouteExports
            """
            Enable default-originate per VRF/address-family.

            Subclass of AvdIndexedList with
            `DefaultRouteExportsItem` items. Primary key is `address_family` (`str`).
            """
            route_targets: RouteTargets
            """Subclass of AvdModel."""
            router_id: str | None
            """in IP address format A.B.C.D."""
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            networks: Networks
            """Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`)."""
            maximum_paths: MaximumPaths
            """Subclass of AvdModel."""
            updates: Updates
            """Subclass of AvdModel."""
            listen_ranges: ListenRanges
            """
            Improved "listen_ranges" data model to support multiple listen ranges and additional filter
            capabilities.


            Subclass of AvdList with `ListenRangesItem` items.
            """
            neighbors: Neighbors
            """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
            neighbor_interfaces: NeighborInterfaces
            """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""
            redistribute: Redistribute
            """
            Redistribute routes in to BGP.

            Subclass of AvdModel.
            """
            redistribute_routes: RedistributeRoutes
            """Subclass of AvdList with `RedistributeRoutesItem` items."""
            aggregate_addresses: AggregateAddresses
            """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""
            address_family_ipv4: AddressFamilyIpv4
            """Subclass of AvdModel."""
            address_family_ipv6: AddressFamilyIpv6
            """Subclass of AvdModel."""
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast
            """Subclass of AvdModel."""
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast
            """Subclass of AvdModel."""
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
            """Subclass of AvdModel."""
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
            configuration.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                    evpn_multicast: bool | None | UndefinedType = Undefined,
                    evpn_multicast_address_family: EvpnMulticastAddressFamily | UndefinedType = Undefined,
                    evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection | UndefinedType = Undefined,
                    default_route_exports: DefaultRouteExports | UndefinedType = Undefined,
                    route_targets: RouteTargets | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    maximum_paths: MaximumPaths | UndefinedType = Undefined,
                    updates: Updates | UndefinedType = Undefined,
                    listen_ranges: ListenRanges | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                    aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
                    address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                    address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                    address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
                    address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
                    address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
                    address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        bgp: Subclass of AvdModel.
                        rd: Route distinguisher.
                        evpn_multicast: evpn_multicast
                        evpn_multicast_address_family:
                           Enable per-AF EVPN multicast settings.

                           Subclass of AvdModel.
                        evpn_multicast_gateway_dr_election: Subclass of AvdModel.
                        default_route_exports:
                           Enable default-originate per VRF/address-family.

                           Subclass of AvdIndexedList with
                           `DefaultRouteExportsItem` items. Primary key is `address_family` (`str`).
                        route_targets: Subclass of AvdModel.
                        router_id: in IP address format A.B.C.D.
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        networks: Subclass of AvdIndexedList with `NetworksItem` items. Primary key is `prefix` (`str`).
                        maximum_paths: Subclass of AvdModel.
                        updates: Subclass of AvdModel.
                        listen_ranges:
                           Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                           capabilities.


                           Subclass of AvdList with `ListenRangesItem` items.
                        neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                        neighbor_interfaces: Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`).
                        redistribute:
                           Redistribute routes in to BGP.

                           Subclass of AvdModel.
                        redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                        aggregate_addresses: Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`).
                        address_family_ipv4: Subclass of AvdModel.
                        address_family_ipv6: Subclass of AvdModel.
                        address_family_ipv4_multicast: Subclass of AvdModel.
                        address_family_ipv6_multicast: Subclass of AvdModel.
                        address_family_flow_spec_ipv4: Subclass of AvdModel.
                        address_family_flow_spec_ipv6: Subclass of AvdModel.
                        eos_cli:
                           Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
                           configuration.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class SessionTrackersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "recovery_delay": {"type": int}, "_custom_data": {"type": dict}}
            name: str
            """Name of session tracker."""
            recovery_delay: int | None
            """Recovery delay in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    recovery_delay: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SessionTrackersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Name of session tracker.
                        recovery_delay: Recovery delay in seconds.
                        _custom_data: _custom_data

                    """

        class SessionTrackers(AvdIndexedList[str, SessionTrackersItem]):
            """Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        SessionTrackers._item_type = SessionTrackersItem

        _fields: ClassVar[dict] = {
            "field_as": {"type": str},
            "as_notation": {"type": str},
            "router_id": {"type": str},
            "timers": {"type": Timers},
            "distance": {"type": Distance},
            "graceful_restart": {"type": GracefulRestart},
            "graceful_restart_helper": {"type": GracefulRestartHelper},
            "maximum_paths": {"type": MaximumPaths},
            "updates": {"type": Updates},
            "bgp_cluster_id": {"type": str},
            "bgp_defaults": {"type": BgpDefaults},
            "bgp": {"type": Bgp},
            "listen_ranges": {"type": ListenRanges},
            "neighbor_default": {"type": NeighborDefault},
            "peer_groups": {"type": PeerGroups},
            "neighbors": {"type": Neighbors},
            "neighbor_interfaces": {"type": NeighborInterfaces},
            "aggregate_addresses": {"type": AggregateAddresses},
            "redistribute": {"type": Redistribute},
            "redistribute_routes": {"type": RedistributeRoutes},
            "vlan_aware_bundles": {"type": VlanAwareBundles},
            "vlans": {"type": Vlans},
            "vpws": {"type": Vpws},
            "address_family_evpn": {"type": AddressFamilyEvpn},
            "address_family_rtc": {"type": AddressFamilyRtc},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv4_labeled_unicast": {"type": AddressFamilyIpv4LabeledUnicast},
            "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
            "address_family_ipv4_sr_te": {"type": AddressFamilyIpv4SrTe},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
            "address_family_ipv6_sr_te": {"type": AddressFamilyIpv6SrTe},
            "address_family_link_state": {"type": AddressFamilyLinkState},
            "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
            "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
            "address_family_path_selection": {"type": AddressFamilyPathSelection},
            "address_family_vpn_ipv4": {"type": AddressFamilyVpnIpv4},
            "address_family_vpn_ipv6": {"type": AddressFamilyVpnIpv6},
            "vrfs": {"type": Vrfs},
            "session_trackers": {"type": SessionTrackers},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        _field_to_key_map: ClassVar[dict] = {"field_as": "as"}
        _key_to_field_map: ClassVar[dict] = {"as": "field_as"}
        field_as: str | None
        """
        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
        For asdot notation in
        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
        number.
        """
        as_notation: Literal["asdot", "asplain"] | None
        """
        BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
        flag indicates which mode is preferred - asplain is the default.
        """
        router_id: str | None
        """In IP address format A.B.C.D."""
        timers: Timers
        """Subclass of AvdModel."""
        distance: Distance
        """Subclass of AvdModel."""
        graceful_restart: GracefulRestart
        """Subclass of AvdModel."""
        graceful_restart_helper: GracefulRestartHelper
        """Subclass of AvdModel."""
        maximum_paths: MaximumPaths
        """Subclass of AvdModel."""
        updates: Updates
        """Subclass of AvdModel."""
        bgp_cluster_id: str | None
        """IP Address A.B.C.D."""
        bgp_defaults: BgpDefaults
        """
        BGP command as string.

        Subclass of AvdList with `str` items.
        """
        bgp: Bgp
        """Subclass of AvdModel."""
        listen_ranges: ListenRanges
        """
        Improved "listen_ranges" data model to support multiple listen ranges and additional filter
        capabilities.


        Subclass of AvdList with `ListenRangesItem` items.
        """
        neighbor_default: NeighborDefault
        """Subclass of AvdModel."""
        peer_groups: PeerGroups
        """Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`)."""
        neighbors: Neighbors
        """Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`)."""
        neighbor_interfaces: NeighborInterfaces
        """Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`)."""
        aggregate_addresses: AggregateAddresses
        """Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`)."""
        redistribute: Redistribute
        """
        Redistribute routes in to BGP.

        Subclass of AvdModel.
        """
        redistribute_routes: RedistributeRoutes
        """Subclass of AvdList with `RedistributeRoutesItem` items."""
        vlan_aware_bundles: VlanAwareBundles
        """Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`)."""
        vlans: Vlans
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
        vpws: Vpws
        """Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`)."""
        address_family_evpn: AddressFamilyEvpn
        """Subclass of AvdModel."""
        address_family_rtc: AddressFamilyRtc
        """Subclass of AvdModel."""
        address_family_ipv4: AddressFamilyIpv4
        """Subclass of AvdModel."""
        address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast
        """Subclass of AvdModel."""
        address_family_ipv4_multicast: AddressFamilyIpv4Multicast
        """Subclass of AvdModel."""
        address_family_ipv4_sr_te: AddressFamilyIpv4SrTe
        """Subclass of AvdModel."""
        address_family_ipv6: AddressFamilyIpv6
        """Subclass of AvdModel."""
        address_family_ipv6_multicast: AddressFamilyIpv6Multicast
        """Subclass of AvdModel."""
        address_family_ipv6_sr_te: AddressFamilyIpv6SrTe
        """Subclass of AvdModel."""
        address_family_link_state: AddressFamilyLinkState
        """Subclass of AvdModel."""
        address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
        """Subclass of AvdModel."""
        address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
        """Subclass of AvdModel."""
        address_family_path_selection: AddressFamilyPathSelection
        """Subclass of AvdModel."""
        address_family_vpn_ipv4: AddressFamilyVpnIpv4
        """Subclass of AvdModel."""
        address_family_vpn_ipv6: AddressFamilyVpnIpv6
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        session_trackers: SessionTrackers
        """Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`)."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                field_as: str | None | UndefinedType = Undefined,
                as_notation: Literal["asdot", "asplain"] | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                distance: Distance | UndefinedType = Undefined,
                graceful_restart: GracefulRestart | UndefinedType = Undefined,
                graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                maximum_paths: MaximumPaths | UndefinedType = Undefined,
                updates: Updates | UndefinedType = Undefined,
                bgp_cluster_id: str | None | UndefinedType = Undefined,
                bgp_defaults: BgpDefaults | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                listen_ranges: ListenRanges | UndefinedType = Undefined,
                neighbor_default: NeighborDefault | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
                aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                vlan_aware_bundles: VlanAwareBundles | UndefinedType = Undefined,
                vlans: Vlans | UndefinedType = Undefined,
                vpws: Vpws | UndefinedType = Undefined,
                address_family_evpn: AddressFamilyEvpn | UndefinedType = Undefined,
                address_family_rtc: AddressFamilyRtc | UndefinedType = Undefined,
                address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast | UndefinedType = Undefined,
                address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
                address_family_ipv4_sr_te: AddressFamilyIpv4SrTe | UndefinedType = Undefined,
                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
                address_family_ipv6_sr_te: AddressFamilyIpv6SrTe | UndefinedType = Undefined,
                address_family_link_state: AddressFamilyLinkState | UndefinedType = Undefined,
                address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
                address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
                address_family_path_selection: AddressFamilyPathSelection | UndefinedType = Undefined,
                address_family_vpn_ipv4: AddressFamilyVpnIpv4 | UndefinedType = Undefined,
                address_family_vpn_ipv6: AddressFamilyVpnIpv6 | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                session_trackers: SessionTrackers | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterBgp.


                Subclass of AvdModel.

                Args:
                    field_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    as_notation:
                       BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
                       flag indicates which mode is preferred - asplain is the default.
                    router_id: In IP address format A.B.C.D.
                    timers: Subclass of AvdModel.
                    distance: Subclass of AvdModel.
                    graceful_restart: Subclass of AvdModel.
                    graceful_restart_helper: Subclass of AvdModel.
                    maximum_paths: Subclass of AvdModel.
                    updates: Subclass of AvdModel.
                    bgp_cluster_id: IP Address A.B.C.D.
                    bgp_defaults:
                       BGP command as string.

                       Subclass of AvdList with `str` items.
                    bgp: Subclass of AvdModel.
                    listen_ranges:
                       Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                       capabilities.


                       Subclass of AvdList with `ListenRangesItem` items.
                    neighbor_default: Subclass of AvdModel.
                    peer_groups: Subclass of AvdIndexedList with `PeerGroupsItem` items. Primary key is `name` (`str`).
                    neighbors: Subclass of AvdIndexedList with `NeighborsItem` items. Primary key is `ip_address` (`str`).
                    neighbor_interfaces: Subclass of AvdIndexedList with `NeighborInterfacesItem` items. Primary key is `name` (`str`).
                    aggregate_addresses: Subclass of AvdIndexedList with `AggregateAddressesItem` items. Primary key is `prefix` (`str`).
                    redistribute:
                       Redistribute routes in to BGP.

                       Subclass of AvdModel.
                    redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                    vlan_aware_bundles: Subclass of AvdIndexedList with `VlanAwareBundlesItem` items. Primary key is `name` (`str`).
                    vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                    vpws: Subclass of AvdIndexedList with `VpwsItem` items. Primary key is `name` (`str`).
                    address_family_evpn: Subclass of AvdModel.
                    address_family_rtc: Subclass of AvdModel.
                    address_family_ipv4: Subclass of AvdModel.
                    address_family_ipv4_labeled_unicast: Subclass of AvdModel.
                    address_family_ipv4_multicast: Subclass of AvdModel.
                    address_family_ipv4_sr_te: Subclass of AvdModel.
                    address_family_ipv6: Subclass of AvdModel.
                    address_family_ipv6_multicast: Subclass of AvdModel.
                    address_family_ipv6_sr_te: Subclass of AvdModel.
                    address_family_link_state: Subclass of AvdModel.
                    address_family_flow_spec_ipv4: Subclass of AvdModel.
                    address_family_flow_spec_ipv6: Subclass of AvdModel.
                    address_family_path_selection: Subclass of AvdModel.
                    address_family_vpn_ipv4: Subclass of AvdModel.
                    address_family_vpn_ipv6: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    session_trackers: Subclass of AvdIndexedList with `SessionTrackersItem` items. Primary key is `name` (`str`).
                    eos_cli: Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class RouterGeneral(AvdModel):
        """Subclass of AvdModel."""

        class RouterId(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}, "_custom_data": {"type": dict}}
            ipv4: str | None
            """IPv4 Address."""
            ipv6: str | None
            """IPv6 Address."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: str | None | UndefinedType = Undefined,
                    ipv6: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouterId.


                    Subclass of AvdModel.

                    Args:
                        ipv4: IPv4 Address.
                        ipv6: IPv6 Address.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class LeakRoutesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_vrf": {"type": str}, "subscribe_policy": {"type": str}, "_custom_data": {"type": dict}}
                source_vrf: str | None
                subscribe_policy: str | None
                """Route-Map Policy."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_vrf: str | None | UndefinedType = Undefined,
                        subscribe_policy: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LeakRoutesItem.


                        Subclass of AvdModel.

                        Args:
                            source_vrf: source_vrf
                            subscribe_policy: Route-Map Policy.
                            _custom_data: _custom_data

                        """

            class LeakRoutes(AvdList[LeakRoutesItem]):
                """Subclass of AvdList with `LeakRoutesItem` items."""

            LeakRoutes._item_type = LeakRoutesItem

            class Routes(AvdModel):
                """Subclass of AvdModel."""

                class DynamicPrefixListsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                    name: str | None
                    """Dynamic Prefix List Name."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            DynamicPrefixListsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Dynamic Prefix List Name.
                                _custom_data: _custom_data

                            """

                class DynamicPrefixLists(AvdList[DynamicPrefixListsItem]):
                    """Subclass of AvdList with `DynamicPrefixListsItem` items."""

                DynamicPrefixLists._item_type = DynamicPrefixListsItem

                _fields: ClassVar[dict] = {"dynamic_prefix_lists": {"type": DynamicPrefixLists}, "_custom_data": {"type": dict}}
                dynamic_prefix_lists: DynamicPrefixLists
                """Subclass of AvdList with `DynamicPrefixListsItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, dynamic_prefix_lists: DynamicPrefixLists | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Routes.


                        Subclass of AvdModel.

                        Args:
                            dynamic_prefix_lists: Subclass of AvdList with `DynamicPrefixListsItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "leak_routes": {"type": LeakRoutes}, "routes": {"type": Routes}, "_custom_data": {"type": dict}}
            name: str
            """Destination-VRF."""
            leak_routes: LeakRoutes
            """Subclass of AvdList with `LeakRoutesItem` items."""
            routes: Routes
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    leak_routes: LeakRoutes | UndefinedType = Undefined,
                    routes: Routes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Destination-VRF.
                        leak_routes: Subclass of AvdList with `LeakRoutesItem` items.
                        routes: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ControlFunctions(AvdModel):
            """Subclass of AvdModel."""

            class CodeUnitsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "content": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                """Name of the code unit."""
                content: str
                """
                Content of route control function.
                e.g.
                function ACCEPT_ALL() {
                  return true;
                  }
                EOF
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        content: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        CodeUnitsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Name of the code unit.
                            content:
                               Content of route control function.
                               e.g.
                               function ACCEPT_ALL() {
                                 return true;
                                 }
                               EOF
                            _custom_data: _custom_data

                        """

            class CodeUnits(AvdIndexedList[str, CodeUnitsItem]):
                """Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            CodeUnits._item_type = CodeUnitsItem

            _fields: ClassVar[dict] = {"code_units": {"type": CodeUnits}, "_custom_data": {"type": dict}}
            code_units: CodeUnits
            """Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, code_units: CodeUnits | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    ControlFunctions.


                    Subclass of AvdModel.

                    Args:
                        code_units: Subclass of AvdIndexedList with `CodeUnitsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "router_id": {"type": RouterId},
            "nexthop_fast_failover": {"type": bool, "default": False},
            "vrfs": {"type": Vrfs},
            "control_functions": {"type": ControlFunctions},
            "_custom_data": {"type": dict},
        }
        router_id: RouterId
        """Subclass of AvdModel."""
        nexthop_fast_failover: bool
        """Default value: `False`"""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        control_functions: ControlFunctions
        """
        Routing control functions (RCF) used to filter and update routes from a peer or during
        redistributions.
        Warning:
        This configuration cannot be pushed with `eos_config_deploy_eapi`, because
        of limitations in `arista.eos` and `ansible.netcommon` plugins.
        The configuration can be pushed via
        CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                router_id: RouterId | UndefinedType = Undefined,
                nexthop_fast_failover: bool | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                control_functions: ControlFunctions | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterGeneral.


                Subclass of AvdModel.

                Args:
                    router_id: Subclass of AvdModel.
                    nexthop_fast_failover: nexthop_fast_failover
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    control_functions:
                       Routing control functions (RCF) used to filter and update routes from a peer or during
                       redistributions.

                Warning:
                       This configuration cannot be pushed with `eos_config_deploy_eapi`, because
                       of limitations in `arista.eos` and `ansible.netcommon` plugins.
                       The configuration can be pushed via
                       CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class RouterIgmp(AvdModel):
        """Subclass of AvdModel."""

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "host_proxy_match_mroute": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """VRF name."""
            host_proxy_match_mroute: Literal["all", "iif"] | None
            """
            Specify conditions for sending IGMP joins for host-proxy.
            'iif' will enable igmp host-proxy to work
            in iif aware.
            'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    host_proxy_match_mroute: Literal["all", "iif"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        host_proxy_match_mroute:
                           Specify conditions for sending IGMP joins for host-proxy.
                           'iif' will enable igmp host-proxy to work
                           in iif aware.
                           'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "host_proxy_match_mroute": {"type": str},
            "ssm_aware": {"type": bool},
            "vrfs": {"type": Vrfs},
            "_custom_data": {"type": dict},
        }
        host_proxy_match_mroute: Literal["all", "iif"] | None
        """
        Specify conditions for sending IGMP joins for host-proxy.
        'iif' will enable igmp host-proxy to work
        in iif aware.
        'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
        """
        ssm_aware: bool | None
        vrfs: Vrfs
        """
        Configure IGMP in a VRF.
        VRF 'default' is not supported in EOS, please see keys directly under
        'router_igmp'.

        Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                host_proxy_match_mroute: Literal["all", "iif"] | None | UndefinedType = Undefined,
                ssm_aware: bool | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterIgmp.


                Subclass of AvdModel.

                Args:
                    host_proxy_match_mroute:
                       Specify conditions for sending IGMP joins for host-proxy.
                       'iif' will enable igmp host-proxy to work
                       in iif aware.
                       'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
                    ssm_aware: ssm_aware
                    vrfs:
                       Configure IGMP in a VRF.
                       VRF 'default' is not supported in EOS, please see keys directly under
                       'router_igmp'.

                       Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterInternetExit(AvdModel):
        """Subclass of AvdModel."""

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class ExitGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        ExitGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            _custom_data: _custom_data

                        """

            class ExitGroups(AvdList[ExitGroupsItem]):
                """Subclass of AvdList with `ExitGroupsItem` items."""

            ExitGroups._item_type = ExitGroupsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "exit_groups": {"type": ExitGroups}, "_custom_data": {"type": dict}}
            name: str
            exit_groups: ExitGroups
            """
            The exit groups that are configured under a policy are strictly ordered, meaning an exit group
            appearing first has more priority than the exit group that follows it.

            Subclass of AvdList with
            `ExitGroupsItem` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    exit_groups: ExitGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        exit_groups:
                           The exit groups that are configured under a policy are strictly ordered, meaning an exit group
                           appearing first has more priority than the exit group that follows it.

                           Subclass of AvdList with
                           `ExitGroupsItem` items.
                        _custom_data: _custom_data

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class ExitGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class LocalConnectionsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        LocalConnectionsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            _custom_data: _custom_data

                        """

            class LocalConnections(AvdList[LocalConnectionsItem]):
                """Subclass of AvdList with `LocalConnectionsItem` items."""

            LocalConnections._item_type = LocalConnectionsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "fib_default": {"type": bool},
                "local_connections": {"type": LocalConnections},
                "_custom_data": {"type": dict},
            }
            name: str
            fib_default: bool | None
            """
            Fib default exit indicates that the flows that select this exit will follow the default route
            available in the VRF of the flow.
            """
            local_connections: LocalConnections
            """
            Local connections refer to connections configured under the `router_service_insertion`.
            The service-
            insertion module reports the health of the connection and the exit will qualify for use only when it
            is healthy.

            Subclass of AvdList with `LocalConnectionsItem` items.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    fib_default: bool | None | UndefinedType = Undefined,
                    local_connections: LocalConnections | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ExitGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        fib_default:
                           Fib default exit indicates that the flows that select this exit will follow the default route
                           available in the VRF of the flow.
                        local_connections:
                           Local connections refer to connections configured under the `router_service_insertion`.
                           The service-
                           insertion module reports the health of the connection and the exit will qualify for use only when it
                           is healthy.

                           Subclass of AvdList with `LocalConnectionsItem` items.
                        _custom_data: _custom_data

                    """

        class ExitGroups(AvdIndexedList[str, ExitGroupsItem]):
            """Subclass of AvdIndexedList with `ExitGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        ExitGroups._item_type = ExitGroupsItem

        _fields: ClassVar[dict] = {"policies": {"type": Policies}, "exit_groups": {"type": ExitGroups}, "_custom_data": {"type": dict}}
        policies: Policies
        """
        Internet-exit policy represent a policy which can be attached to a virtual topology profile.
        Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        exit_groups: ExitGroups
        """
        Exit groups represent a group of exit options (connections).
        Traffic flows are load balanced in a
        round robin fashion across all the members (exits) of the exit-group.

        Subclass of AvdIndexedList
        with `ExitGroupsItem` items. Primary key is `name` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                policies: Policies | UndefinedType = Undefined,
                exit_groups: ExitGroups | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterInternetExit.


                Subclass of AvdModel.

                Args:
                    policies:
                       Internet-exit policy represent a policy which can be attached to a virtual topology profile.
                       Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    exit_groups:
                       Exit groups represent a group of exit options (connections).
                       Traffic flows are load balanced in a
                       round robin fashion across all the members (exits) of the exit-group.

                       Subclass of AvdIndexedList
                       with `ExitGroupsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterIsis(AvdModel):
        """Subclass of AvdModel."""

        class Timers(AvdModel):
            """Subclass of AvdModel."""

            class LocalConvergence(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"protected_prefixes": {"type": bool}, "delay": {"type": int, "default": 10000}, "_custom_data": {"type": dict}}
                protected_prefixes: bool | None
                delay: int
                """
                Delay in milliseconds.

                Default value: `10000`
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        protected_prefixes: bool | None | UndefinedType = Undefined,
                        delay: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalConvergence.


                        Subclass of AvdModel.

                        Args:
                            protected_prefixes: protected_prefixes
                            delay: Delay in milliseconds.
                            _custom_data: _custom_data

                        """

            class Lsp(AvdModel):
                """Subclass of AvdModel."""

                class Generation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "interval": {"type": int},
                        "initial_wait_time": {"type": int},
                        "wait_time": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    interval: int
                    """Maximum interval (in seconds) between generating two LSPs."""
                    initial_wait_time: int | None
                    """Initial wait time (in milliseconds) before generating LSPs."""
                    wait_time: int | None
                    """Wait time (in milliseconds) between generating the first and second LSPs."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | UndefinedType = Undefined,
                            initial_wait_time: int | None | UndefinedType = Undefined,
                            wait_time: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Generation.


                            Subclass of AvdModel.

                            Args:
                                interval: Maximum interval (in seconds) between generating two LSPs.
                                initial_wait_time: Initial wait time (in milliseconds) before generating LSPs.
                                wait_time: Wait time (in milliseconds) between generating the first and second LSPs.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "generation": {"type": Generation},
                    "out_delay": {"type": int},
                    "refresh_interval": {"type": int},
                    "min_remaining_lifetime": {"type": int},
                    "_custom_data": {"type": dict},
                }
                generation: Generation
                """Subclass of AvdModel."""
                out_delay: int | None
                """Transmit delay (in milliseconds) for link state packets."""
                refresh_interval: int | None
                """Interval (in seconds) between two LSP refreshes."""
                min_remaining_lifetime: int | None
                """Minimum remaining lifetime for LSPs (in seconds)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        generation: Generation | UndefinedType = Undefined,
                        out_delay: int | None | UndefinedType = Undefined,
                        refresh_interval: int | None | UndefinedType = Undefined,
                        min_remaining_lifetime: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lsp.


                        Subclass of AvdModel.

                        Args:
                            generation: Subclass of AvdModel.
                            out_delay: Transmit delay (in milliseconds) for link state packets.
                            refresh_interval: Interval (in seconds) between two LSP refreshes.
                            min_remaining_lifetime: Minimum remaining lifetime for LSPs (in seconds).
                            _custom_data: _custom_data

                        """

            class Csnp(AvdModel):
                """Subclass of AvdModel."""

                class Generation(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"interval": {"type": int}, "p2p_disabled": {"type": bool}, "_custom_data": {"type": dict}}
                    interval: int | None
                    """Transmit frequency (in seconds) for CSN packets."""
                    p2p_disabled: bool | None
                    """Disable periodic CSN packets for P2P links."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | None | UndefinedType = Undefined,
                            p2p_disabled: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Generation.


                            Subclass of AvdModel.

                            Args:
                                interval: Transmit frequency (in seconds) for CSN packets.
                                p2p_disabled: Disable periodic CSN packets for P2P links.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"generation": {"type": Generation}, "_custom_data": {"type": dict}}
                generation: Generation
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, generation: Generation | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Csnp.


                        Subclass of AvdModel.

                        Args:
                            generation: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "local_convergence": {"type": LocalConvergence},
                "lsp": {"type": Lsp},
                "csnp": {"type": Csnp},
                "_custom_data": {"type": dict},
            }
            local_convergence: LocalConvergence
            """Subclass of AvdModel."""
            lsp: Lsp
            """
            Link State Packet timers.

            Subclass of AvdModel.
            """
            csnp: Csnp
            """
            CSN Packet timers.

            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_convergence: LocalConvergence | UndefinedType = Undefined,
                    lsp: Lsp | UndefinedType = Undefined,
                    csnp: Csnp | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timers.


                    Subclass of AvdModel.

                    Args:
                        local_convergence: Subclass of AvdModel.
                        lsp:
                           Link State Packet timers.

                           Subclass of AvdModel.
                        csnp:
                           CSN Packet timers.

                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class SetOverloadBit(AvdModel):
            """Subclass of AvdModel."""

            class OnStartup(AvdModel):
                """Subclass of AvdModel."""

                class WaitForBgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "timeout": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    timeout: int | None
                    """Number of seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            timeout: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WaitForBgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                timeout: Number of seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"delay": {"type": int}, "wait_for_bgp": {"type": WaitForBgp}, "_custom_data": {"type": dict}}
                delay: int | None
                """Number of seconds."""
                wait_for_bgp: WaitForBgp
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        delay: int | None | UndefinedType = Undefined,
                        wait_for_bgp: WaitForBgp | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        OnStartup.


                        Subclass of AvdModel.

                        Args:
                            delay: Number of seconds.
                            wait_for_bgp: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "on_startup": {"type": OnStartup}, "_custom_data": {"type": dict}}
            enabled: bool | None
            on_startup: OnStartup
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    on_startup: OnStartup | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SetOverloadBit.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        on_startup: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Authentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}, "_custom_data": {"type": dict}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    both: Both | UndefinedType = Undefined,
                    level_1: Level1 | UndefinedType = Undefined,
                    level_2: Level2 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Authentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Advertise(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"passive_only": {"type": bool}, "_custom_data": {"type": dict}}
            passive_only: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, passive_only: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Advertise.


                    Subclass of AvdModel.

                    Args:
                        passive_only: passive_only
                        _custom_data: _custom_data

                    """

        class RedistributeRoutesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
                "_custom_data": {"type": dict},
            }
            source_protocol: Literal["bgp", "connected", "isis", "ospf", "ospfv3", "static"]
            route_map: str | None
            """Route-map name."""
            include_leaked: bool | None
            ospf_route_type: Literal["external", "internal", "nssa-external"] | None
            """ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    source_protocol: Literal["bgp", "connected", "isis", "ospf", "ospfv3", "static"] | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    ospf_route_type: Literal["external", "internal", "nssa-external"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.


                    Subclass of AvdModel.

                    Args:
                        source_protocol: source_protocol
                        route_map: Route-map name.
                        include_leaked: include_leaked
                        ospf_route_type: ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'.
                        _custom_data: _custom_data

                    """

        class RedistributeRoutes(AvdList[RedistributeRoutesItem]):
            """Subclass of AvdList with `RedistributeRoutesItem` items."""

        RedistributeRoutes._item_type = RedistributeRoutesItem

        class AddressFamilyIpv4(AvdModel):
            """Subclass of AvdModel."""

            class FastRerouteTiLfa(AvdModel):
                """Subclass of AvdModel."""

                class Srlg(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "strict": {"type": bool}, "_custom_data": {"type": dict}}
                    enable: bool | None
                    strict: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enable: bool | None | UndefinedType = Undefined,
                            strict: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Srlg.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                strict: strict
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}, "_custom_data": {"type": dict}}
                mode: Literal["link-protection", "node-protection"] | None
                level: Literal["level-1", "level-2"] | None
                srlg: Srlg
                """
                Shared Risk Link Group.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection"] | None | UndefinedType = Undefined,
                        level: Literal["level-1", "level-2"] | None | UndefinedType = Undefined,
                        srlg: Srlg | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastRerouteTiLfa.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            level: level
                            srlg:
                               Shared Risk Link Group.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class TunnelSourceLabeledUnicast(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "rcf": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                rcf: str | None
                """Route Control Function."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TunnelSourceLabeledUnicast.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            rcf: Route Control Function.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
                "tunnel_source_labeled_unicast": {"type": TunnelSourceLabeledUnicast},
                "_custom_data": {"type": dict},
            }
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa
            """Subclass of AvdModel."""
            tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                    fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
                    tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        maximum_paths: maximum_paths
                        bfd_all_interfaces: Enable BFD on all interfaces.
                        fast_reroute_ti_lfa: Subclass of AvdModel.
                        tunnel_source_labeled_unicast: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class AddressFamilyIpv6(AvdModel):
            """Subclass of AvdModel."""

            class FastRerouteTiLfa(AvdModel):
                """Subclass of AvdModel."""

                class Srlg(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enable": {"type": bool}, "strict": {"type": bool}, "_custom_data": {"type": dict}}
                    enable: bool | None
                    strict: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enable: bool | None | UndefinedType = Undefined,
                            strict: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Srlg.


                            Subclass of AvdModel.

                            Args:
                                enable: enable
                                strict: strict
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}, "_custom_data": {"type": dict}}
                mode: Literal["link-protection", "node-protection"] | None
                level: Literal["level-1", "level-2"] | None
                """Optional, default is to protect all levels."""
                srlg: Srlg
                """
                Shared Risk Link Group.

                Subclass of AvdModel.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        mode: Literal["link-protection", "node-protection"] | None | UndefinedType = Undefined,
                        level: Literal["level-1", "level-2"] | None | UndefinedType = Undefined,
                        srlg: Srlg | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        FastRerouteTiLfa.


                        Subclass of AvdModel.

                        Args:
                            mode: mode
                            level: Optional, default is to protect all levels.
                            srlg:
                               Shared Risk Link Group.

                               Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
                "_custom_data": {"type": dict},
            }
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                    fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        maximum_paths: maximum_paths
                        bfd_all_interfaces: Enable BFD on all interfaces.
                        fast_reroute_ti_lfa: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class SegmentRoutingMpls(AvdModel):
            """Subclass of AvdModel."""

            class PrefixSegmentsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"prefix": {"type": str}, "index": {"type": int}, "_custom_data": {"type": dict}}
                prefix: str | None
                index: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | None | UndefinedType = Undefined,
                        index: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PrefixSegmentsItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: prefix
                            index: index
                            _custom_data: _custom_data

                        """

            class PrefixSegments(AvdList[PrefixSegmentsItem]):
                """Subclass of AvdList with `PrefixSegmentsItem` items."""

            PrefixSegments._item_type = PrefixSegmentsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "router_id": {"type": str},
                "prefix_segments": {"type": PrefixSegments},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            router_id: str | None
            prefix_segments: PrefixSegments
            """Subclass of AvdList with `PrefixSegmentsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    prefix_segments: PrefixSegments | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SegmentRoutingMpls.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        router_id: router_id
                        prefix_segments: Subclass of AvdList with `PrefixSegmentsItem` items.
                        _custom_data: _custom_data

                    """

        class SpfInterval(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "interval": {"type": int},
                "interval_unit": {"type": str},
                "wait_interval": {"type": int},
                "hold_interval": {"type": int},
                "_custom_data": {"type": dict},
            }
            interval: int | None
            """
            Maximum interval between two SPFs in seconds or milliseconds.
            Range in seconds: <1-300>
            Range in
            milliseconds: <1-300000>
            """
            interval_unit: Literal["seconds", "milliseconds"] | None
            """If interval unit is not defined EOS takes `seconds` by default."""
            wait_interval: int | None
            """Initial wait interval for SPF in milliseconds."""
            hold_interval: int | None
            """Hold interval between the first and second SPF runs in milliseconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    interval: int | None | UndefinedType = Undefined,
                    interval_unit: Literal["seconds", "milliseconds"] | None | UndefinedType = Undefined,
                    wait_interval: int | None | UndefinedType = Undefined,
                    hold_interval: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SpfInterval.


                    Subclass of AvdModel.

                    Args:
                        interval:
                           Maximum interval between two SPFs in seconds or milliseconds.
                           Range in seconds: <1-300>
                           Range in
                           milliseconds: <1-300000>
                        interval_unit: If interval unit is not defined EOS takes `seconds` by default.
                        wait_interval: Initial wait interval for SPF in milliseconds.
                        hold_interval: Hold interval between the first and second SPF runs in milliseconds.
                        _custom_data: _custom_data

                    """

        class GracefulRestart(AvdModel):
            """Subclass of AvdModel."""

            class T2(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"level_1_wait_time": {"type": int}, "level_2_wait_time": {"type": int}, "_custom_data": {"type": dict}}
                level_1_wait_time: int | None
                """Level-1 LSP database sync wait time in seconds."""
                level_2_wait_time: int | None
                """Level-2 LSP database sync wait time in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        level_1_wait_time: int | None | UndefinedType = Undefined,
                        level_2_wait_time: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        T2.


                        Subclass of AvdModel.

                        Args:
                            level_1_wait_time: Level-1 LSP database sync wait time in seconds.
                            level_2_wait_time: Level-2 LSP database sync wait time in seconds.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "restart_hold_time": {"type": int}, "t2": {"type": T2}, "_custom_data": {"type": dict}}
            enabled: bool | None
            restart_hold_time: int | None
            """Number of seconds."""
            t2: T2
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    restart_hold_time: int | None | UndefinedType = Undefined,
                    t2: T2 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    GracefulRestart.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        restart_hold_time: Number of seconds.
                        t2: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "instance": {"type": str},
            "net": {"type": str},
            "router_id": {"type": str},
            "is_hostname": {"type": str},
            "is_type": {"type": str},
            "log_adjacency_changes": {"type": bool},
            "mpls_ldp_sync_default": {"type": bool},
            "timers": {"type": Timers},
            "set_overload_bit": {"type": SetOverloadBit},
            "authentication": {"type": Authentication},
            "advertise": {"type": Advertise},
            "redistribute_routes": {"type": RedistributeRoutes},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "segment_routing_mpls": {"type": SegmentRoutingMpls},
            "spf_interval": {"type": SpfInterval},
            "graceful_restart": {"type": GracefulRestart},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        instance: str
        """ISIS Instance Name."""
        net: str | None
        """CLNS Address like "49.0001.0001.0000.0001.00"."""
        router_id: str | None
        """IPv4 Address."""
        is_hostname: str | None
        """Hostname of Intermediate System."""
        is_type: Literal["level-1", "level-1-2", "level-2"] | None
        log_adjacency_changes: bool | None
        mpls_ldp_sync_default: bool | None
        timers: Timers
        """Subclass of AvdModel."""
        set_overload_bit: SetOverloadBit
        """Subclass of AvdModel."""
        authentication: Authentication
        """Subclass of AvdModel."""
        advertise: Advertise
        """Subclass of AvdModel."""
        redistribute_routes: RedistributeRoutes
        """Subclass of AvdList with `RedistributeRoutesItem` items."""
        address_family_ipv4: AddressFamilyIpv4
        """Subclass of AvdModel."""
        address_family_ipv6: AddressFamilyIpv6
        """Subclass of AvdModel."""
        segment_routing_mpls: SegmentRoutingMpls
        """Subclass of AvdModel."""
        spf_interval: SpfInterval
        """Subclass of AvdModel."""
        graceful_restart: GracefulRestart
        """Subclass of AvdModel."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the router isis in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                instance: str | UndefinedType = Undefined,
                net: str | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                is_hostname: str | None | UndefinedType = Undefined,
                is_type: Literal["level-1", "level-1-2", "level-2"] | None | UndefinedType = Undefined,
                log_adjacency_changes: bool | None | UndefinedType = Undefined,
                mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                set_overload_bit: SetOverloadBit | UndefinedType = Undefined,
                authentication: Authentication | UndefinedType = Undefined,
                advertise: Advertise | UndefinedType = Undefined,
                redistribute_routes: RedistributeRoutes | UndefinedType = Undefined,
                address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                segment_routing_mpls: SegmentRoutingMpls | UndefinedType = Undefined,
                spf_interval: SpfInterval | UndefinedType = Undefined,
                graceful_restart: GracefulRestart | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterIsis.


                Subclass of AvdModel.

                Args:
                    instance: ISIS Instance Name.
                    net: CLNS Address like "49.0001.0001.0000.0001.00".
                    router_id: IPv4 Address.
                    is_hostname: Hostname of Intermediate System.
                    is_type: is_type
                    log_adjacency_changes: log_adjacency_changes
                    mpls_ldp_sync_default: mpls_ldp_sync_default
                    timers: Subclass of AvdModel.
                    set_overload_bit: Subclass of AvdModel.
                    authentication: Subclass of AvdModel.
                    advertise: Subclass of AvdModel.
                    redistribute_routes: Subclass of AvdList with `RedistributeRoutesItem` items.
                    address_family_ipv4: Subclass of AvdModel.
                    address_family_ipv6: Subclass of AvdModel.
                    segment_routing_mpls: Subclass of AvdModel.
                    spf_interval: Subclass of AvdModel.
                    graceful_restart: Subclass of AvdModel.
                    eos_cli: Multiline EOS CLI rendered directly on the router isis in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class RouterL2Vpn(AvdModel):
        """Subclass of AvdModel."""

        class ArpProxy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "_custom_data": {"type": dict}}
            prefix_list: str | None
            """Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, prefix_list: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    ArpProxy.


                    Subclass of AvdModel.

                    Args:
                        prefix_list: Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list.
                        _custom_data: _custom_data

                    """

        class NdProxy(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"prefix_list": {"type": str}, "_custom_data": {"type": dict}}
            prefix_list: str | None
            """
            Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
            list.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, prefix_list: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    NdProxy.


                    Subclass of AvdModel.

                    Args:
                        prefix_list:
                           Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
                           list.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "arp_learning_bridged": {"type": bool},
            "arp_proxy": {"type": ArpProxy},
            "arp_selective_install": {"type": bool},
            "nd_learning_bridged": {"type": bool},
            "nd_proxy": {"type": NdProxy},
            "nd_rs_flooding_disabled": {"type": bool},
            "virtual_router_nd_ra_flooding_disabled": {"type": bool},
            "_custom_data": {"type": dict},
        }
        arp_learning_bridged: bool | None
        arp_proxy: ArpProxy
        """Subclass of AvdModel."""
        arp_selective_install: bool | None
        nd_learning_bridged: bool | None
        nd_proxy: NdProxy
        """Subclass of AvdModel."""
        nd_rs_flooding_disabled: bool | None
        virtual_router_nd_ra_flooding_disabled: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                arp_learning_bridged: bool | None | UndefinedType = Undefined,
                arp_proxy: ArpProxy | UndefinedType = Undefined,
                arp_selective_install: bool | None | UndefinedType = Undefined,
                nd_learning_bridged: bool | None | UndefinedType = Undefined,
                nd_proxy: NdProxy | UndefinedType = Undefined,
                nd_rs_flooding_disabled: bool | None | UndefinedType = Undefined,
                virtual_router_nd_ra_flooding_disabled: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterL2Vpn.


                Subclass of AvdModel.

                Args:
                    arp_learning_bridged: arp_learning_bridged
                    arp_proxy: Subclass of AvdModel.
                    arp_selective_install: arp_selective_install
                    nd_learning_bridged: nd_learning_bridged
                    nd_proxy: Subclass of AvdModel.
                    nd_rs_flooding_disabled: nd_rs_flooding_disabled
                    virtual_router_nd_ra_flooding_disabled: virtual_router_nd_ra_flooding_disabled
                    _custom_data: _custom_data

                """

    class RouterMsdp(AvdModel):
        """Subclass of AvdModel."""

        class GroupLimitsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "limit": {"type": int}, "_custom_data": {"type": dict}}
            source_prefix: str
            """Source address prefix."""
            limit: int
            """Limit for SAs matching the source address prefix."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    source_prefix: str | UndefinedType = Undefined,
                    limit: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupLimitsItem.


                    Subclass of AvdModel.

                    Args:
                        source_prefix: Source address prefix.
                        limit: Limit for SAs matching the source address prefix.
                        _custom_data: _custom_data

                    """

        class GroupLimits(AvdIndexedList[str, GroupLimitsItem]):
            """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "source_prefix"

        GroupLimits._item_type = GroupLimitsItem

        class PeersItem(AvdModel):
            """Subclass of AvdModel."""

            class DefaultPeer(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "prefix_list": {"type": str}, "_custom_data": {"type": dict}}
                enabled: bool | None
                prefix_list: str | None
                """Prefix list to filter source of SA messages."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultPeer.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            prefix_list: Prefix list to filter source of SA messages.
                            _custom_data: _custom_data

                        """

            class MeshGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                """Mesh group name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        MeshGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Mesh group name.
                            _custom_data: _custom_data

                        """

            class MeshGroups(AvdIndexedList[str, MeshGroupsItem]):
                """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            MeshGroups._item_type = MeshGroupsItem

            class Keepalive(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"keepalive_timer": {"type": int}, "hold_timer": {"type": int}, "_custom_data": {"type": dict}}
                keepalive_timer: int
                hold_timer: int
                """Must be greater than keepalive timer."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        keepalive_timer: int | UndefinedType = Undefined,
                        hold_timer: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Keepalive.


                        Subclass of AvdModel.

                        Args:
                            keepalive_timer: keepalive_timer
                            hold_timer: Must be greater than keepalive timer.
                            _custom_data: _custom_data

                        """

            class SaFilter(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"in_list": {"type": str}, "out_list": {"type": str}, "_custom_data": {"type": dict}}
                in_list: str | None
                """ACL to filter inbound SA messages."""
                out_list: str | None
                """ACL to filter outbound SA messages."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        in_list: str | None | UndefinedType = Undefined,
                        out_list: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SaFilter.


                        Subclass of AvdModel.

                        Args:
                            in_list: ACL to filter inbound SA messages.
                            out_list: ACL to filter outbound SA messages.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "ipv4_address": {"type": str},
                "default_peer": {"type": DefaultPeer},
                "local_interface": {"type": str},
                "description": {"type": str},
                "disabled": {"type": bool},
                "sa_limit": {"type": int},
                "mesh_groups": {"type": MeshGroups},
                "keepalive": {"type": Keepalive},
                "sa_filter": {"type": SaFilter},
                "_custom_data": {"type": dict},
            }
            ipv4_address: str
            """Peer IP Address."""
            default_peer: DefaultPeer
            """Subclass of AvdModel."""
            local_interface: str | None
            description: str | None
            disabled: bool | None
            """Disable the MSDP peer."""
            sa_limit: int | None
            """Maximum number of SA messages allowed in cache."""
            mesh_groups: MeshGroups
            """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""
            keepalive: Keepalive
            """Subclass of AvdModel."""
            sa_filter: SaFilter
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_address: str | UndefinedType = Undefined,
                    default_peer: DefaultPeer | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    disabled: bool | None | UndefinedType = Undefined,
                    sa_limit: int | None | UndefinedType = Undefined,
                    mesh_groups: MeshGroups | UndefinedType = Undefined,
                    keepalive: Keepalive | UndefinedType = Undefined,
                    sa_filter: SaFilter | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeersItem.


                    Subclass of AvdModel.

                    Args:
                        ipv4_address: Peer IP Address.
                        default_peer: Subclass of AvdModel.
                        local_interface: local_interface
                        description: description
                        disabled: Disable the MSDP peer.
                        sa_limit: Maximum number of SA messages allowed in cache.
                        mesh_groups: Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`).
                        keepalive: Subclass of AvdModel.
                        sa_filter: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Peers(AvdIndexedList[str, PeersItem]):
            """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""

            _primary_key: ClassVar[str] = "ipv4_address"

        Peers._item_type = PeersItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class GroupLimitsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "limit": {"type": int}, "_custom_data": {"type": dict}}
                source_prefix: str
                """Source address prefix."""
                limit: int
                """Limit for SAs matching the source address prefix."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_prefix: str | UndefinedType = Undefined,
                        limit: int | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupLimitsItem.


                        Subclass of AvdModel.

                        Args:
                            source_prefix: Source address prefix.
                            limit: Limit for SAs matching the source address prefix.
                            _custom_data: _custom_data

                        """

            class GroupLimits(AvdIndexedList[str, GroupLimitsItem]):
                """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""

                _primary_key: ClassVar[str] = "source_prefix"

            GroupLimits._item_type = GroupLimitsItem

            class PeersItem(AvdModel):
                """Subclass of AvdModel."""

                class DefaultPeer(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "prefix_list": {"type": str}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    prefix_list: str | None
                    """Prefix list to filter source of SA messages."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | None | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultPeer.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                prefix_list: Prefix list to filter source of SA messages.
                                _custom_data: _custom_data

                            """

                class MeshGroupsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                    name: str
                    """Mesh group name."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, name: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            MeshGroupsItem.


                            Subclass of AvdModel.

                            Args:
                                name: Mesh group name.
                                _custom_data: _custom_data

                            """

                class MeshGroups(AvdIndexedList[str, MeshGroupsItem]):
                    """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                MeshGroups._item_type = MeshGroupsItem

                class Keepalive(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"keepalive_timer": {"type": int}, "hold_timer": {"type": int}, "_custom_data": {"type": dict}}
                    keepalive_timer: int
                    hold_timer: int
                    """Must be greater than keepalive timer."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            keepalive_timer: int | UndefinedType = Undefined,
                            hold_timer: int | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Keepalive.


                            Subclass of AvdModel.

                            Args:
                                keepalive_timer: keepalive_timer
                                hold_timer: Must be greater than keepalive timer.
                                _custom_data: _custom_data

                            """

                class SaFilter(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"in_list": {"type": str}, "out_list": {"type": str}, "_custom_data": {"type": dict}}
                    in_list: str | None
                    """ACL to filter inbound SA messages."""
                    out_list: str | None
                    """ACL to filter outbound SA messages."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            in_list: str | None | UndefinedType = Undefined,
                            out_list: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SaFilter.


                            Subclass of AvdModel.

                            Args:
                                in_list: ACL to filter inbound SA messages.
                                out_list: ACL to filter outbound SA messages.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "ipv4_address": {"type": str},
                    "default_peer": {"type": DefaultPeer},
                    "local_interface": {"type": str},
                    "description": {"type": str},
                    "disabled": {"type": bool},
                    "sa_limit": {"type": int},
                    "mesh_groups": {"type": MeshGroups},
                    "keepalive": {"type": Keepalive},
                    "sa_filter": {"type": SaFilter},
                    "_custom_data": {"type": dict},
                }
                ipv4_address: str
                """Peer IP Address."""
                default_peer: DefaultPeer
                """Subclass of AvdModel."""
                local_interface: str | None
                description: str | None
                disabled: bool | None
                """Disable the MSDP peer."""
                sa_limit: int | None
                """Maximum number of SA messages allowed in cache."""
                mesh_groups: MeshGroups
                """Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`)."""
                keepalive: Keepalive
                """Subclass of AvdModel."""
                sa_filter: SaFilter
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4_address: str | UndefinedType = Undefined,
                        default_peer: DefaultPeer | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        disabled: bool | None | UndefinedType = Undefined,
                        sa_limit: int | None | UndefinedType = Undefined,
                        mesh_groups: MeshGroups | UndefinedType = Undefined,
                        keepalive: Keepalive | UndefinedType = Undefined,
                        sa_filter: SaFilter | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PeersItem.


                        Subclass of AvdModel.

                        Args:
                            ipv4_address: Peer IP Address.
                            default_peer: Subclass of AvdModel.
                            local_interface: local_interface
                            description: description
                            disabled: Disable the MSDP peer.
                            sa_limit: Maximum number of SA messages allowed in cache.
                            mesh_groups: Subclass of AvdIndexedList with `MeshGroupsItem` items. Primary key is `name` (`str`).
                            keepalive: Subclass of AvdModel.
                            sa_filter: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Peers(AvdIndexedList[str, PeersItem]):
                """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""

                _primary_key: ClassVar[str] = "ipv4_address"

            Peers._item_type = PeersItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "originator_id_local_interface": {"type": str},
                "rejected_limit": {"type": int},
                "forward_register_packets": {"type": bool},
                "connection_retry_interval": {"type": int},
                "group_limits": {"type": GroupLimits},
                "peers": {"type": Peers},
                "_custom_data": {"type": dict},
            }
            name: str
            """VRF name."""
            originator_id_local_interface: str | None
            """Interface to use for originator ID."""
            rejected_limit: int | None
            """Maximum number of rejected SA messages allowed in cache."""
            forward_register_packets: bool | None
            connection_retry_interval: int | None
            group_limits: GroupLimits
            """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""
            peers: Peers
            """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    originator_id_local_interface: str | None | UndefinedType = Undefined,
                    rejected_limit: int | None | UndefinedType = Undefined,
                    forward_register_packets: bool | None | UndefinedType = Undefined,
                    connection_retry_interval: int | None | UndefinedType = Undefined,
                    group_limits: GroupLimits | UndefinedType = Undefined,
                    peers: Peers | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        originator_id_local_interface: Interface to use for originator ID.
                        rejected_limit: Maximum number of rejected SA messages allowed in cache.
                        forward_register_packets: forward_register_packets
                        connection_retry_interval: connection_retry_interval
                        group_limits: Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`).
                        peers: Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "originator_id_local_interface": {"type": str},
            "rejected_limit": {"type": int},
            "forward_register_packets": {"type": bool},
            "connection_retry_interval": {"type": int},
            "group_limits": {"type": GroupLimits},
            "peers": {"type": Peers},
            "vrfs": {"type": Vrfs},
            "_custom_data": {"type": dict},
        }
        originator_id_local_interface: str | None
        """Interface to use for originator ID."""
        rejected_limit: int | None
        """Maximum number of rejected SA messages allowed in cache."""
        forward_register_packets: bool | None
        connection_retry_interval: int | None
        group_limits: GroupLimits
        """Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`)."""
        peers: Peers
        """Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`)."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                originator_id_local_interface: str | None | UndefinedType = Undefined,
                rejected_limit: int | None | UndefinedType = Undefined,
                forward_register_packets: bool | None | UndefinedType = Undefined,
                connection_retry_interval: int | None | UndefinedType = Undefined,
                group_limits: GroupLimits | UndefinedType = Undefined,
                peers: Peers | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterMsdp.


                Subclass of AvdModel.

                Args:
                    originator_id_local_interface: Interface to use for originator ID.
                    rejected_limit: Maximum number of rejected SA messages allowed in cache.
                    forward_register_packets: forward_register_packets
                    connection_retry_interval: connection_retry_interval
                    group_limits: Subclass of AvdIndexedList with `GroupLimitsItem` items. Primary key is `source_prefix` (`str`).
                    peers: Subclass of AvdIndexedList with `PeersItem` items. Primary key is `ipv4_address` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterMulticast(AvdModel):
        """Subclass of AvdModel."""

        class Ipv4(AvdModel):
            """Subclass of AvdModel."""

            class Counters(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"rate_period_decay": {"type": int}, "_custom_data": {"type": dict}}
                rate_period_decay: int | None
                """Rate in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, rate_period_decay: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Counters.


                        Subclass of AvdModel.

                        Args:
                            rate_period_decay: Rate in seconds.
                            _custom_data: _custom_data

                        """

            class Rpf(AvdModel):
                """Subclass of AvdModel."""

                class RoutesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class DestinationsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"nexthop": {"type": str}, "distance": {"type": int}, "_custom_data": {"type": dict}}
                        nexthop: str
                        """Next-hop IP address or interface name."""
                        distance: int | None
                        """Administrative distance for this route."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                nexthop: str | UndefinedType = Undefined,
                                distance: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DestinationsItem.


                                Subclass of AvdModel.

                                Args:
                                    nexthop: Next-hop IP address or interface name.
                                    distance: Administrative distance for this route.
                                    _custom_data: _custom_data

                                """

                    class Destinations(AvdList[DestinationsItem]):
                        """Subclass of AvdList with `DestinationsItem` items."""

                    Destinations._item_type = DestinationsItem

                    _fields: ClassVar[dict] = {"source_prefix": {"type": str}, "destinations": {"type": Destinations}, "_custom_data": {"type": dict}}
                    source_prefix: str
                    """Source address A.B.C.D or Source prefix A.B.C.D/E."""
                    destinations: Destinations
                    """Subclass of AvdList with `DestinationsItem` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            source_prefix: str | UndefinedType = Undefined,
                            destinations: Destinations | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RoutesItem.


                            Subclass of AvdModel.

                            Args:
                                source_prefix: Source address A.B.C.D or Source prefix A.B.C.D/E.
                                destinations: Subclass of AvdList with `DestinationsItem` items.
                                _custom_data: _custom_data

                            """

                class Routes(AvdList[RoutesItem]):
                    """Subclass of AvdList with `RoutesItem` items."""

                Routes._item_type = RoutesItem

                _fields: ClassVar[dict] = {"routes": {"type": Routes}, "_custom_data": {"type": dict}}
                routes: Routes
                """Subclass of AvdList with `RoutesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, routes: Routes | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Rpf.


                        Subclass of AvdModel.

                        Args:
                            routes: Subclass of AvdList with `RoutesItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "activity_polling_interval": {"type": int},
                "counters": {"type": Counters},
                "routing": {"type": bool},
                "multipath": {"type": str},
                "software_forwarding": {"type": str},
                "rpf": {"type": Rpf},
                "_custom_data": {"type": dict},
            }
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""
            counters: Counters
            """Subclass of AvdModel."""
            routing: bool | None
            multipath: Literal["none", "deterministic", "deterministic color", "deterministic router-id"] | None
            software_forwarding: Literal["kernel", "sfe"] | None
            rpf: Rpf
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    activity_polling_interval: int | None | UndefinedType = Undefined,
                    counters: Counters | UndefinedType = Undefined,
                    routing: bool | None | UndefinedType = Undefined,
                    multipath: Literal["none", "deterministic", "deterministic color", "deterministic router-id"] | None | UndefinedType = Undefined,
                    software_forwarding: Literal["kernel", "sfe"] | None | UndefinedType = Undefined,
                    rpf: Rpf | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.


                    Subclass of AvdModel.

                    Args:
                        activity_polling_interval: MFIB entry activity polling interval.
                        counters: Subclass of AvdModel.
                        routing: routing
                        multipath: multipath
                        software_forwarding: software_forwarding
                        rpf: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Ipv6(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"activity_polling_interval": {"type": int}, "_custom_data": {"type": dict}}
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, activity_polling_interval: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Ipv6.


                    Subclass of AvdModel.

                    Args:
                        activity_polling_interval: MFIB entry activity polling interval.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"routing": {"type": bool}, "_custom_data": {"type": dict}}
                routing: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, routing: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            routing: routing
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
            name: str
            ipv4: Ipv4
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        ipv4: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "vrfs": {"type": Vrfs}, "_custom_data": {"type": dict}}
        ipv4: Ipv4
        """Subclass of AvdModel."""
        ipv6: Ipv6
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterMulticast.


                Subclass of AvdModel.

                Args:
                    ipv4: Subclass of AvdModel.
                    ipv6: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterOspf(AvdModel):
        """Subclass of AvdModel."""

        class ProcessIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Distance(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"external": {"type": int}, "inter_area": {"type": int}, "intra_area": {"type": int}, "_custom_data": {"type": dict}}
                external: int | None
                inter_area: int | None
                intra_area: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        external: int | None | UndefinedType = Undefined,
                        inter_area: int | None | UndefinedType = Undefined,
                        intra_area: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Distance.


                        Subclass of AvdModel.

                        Args:
                            external: external
                            inter_area: inter_area
                            intra_area: intra_area
                            _custom_data: _custom_data

                        """

            class NetworkPrefixesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4_prefix": {"type": str}, "area": {"type": str}, "_custom_data": {"type": dict}}
                ipv4_prefix: str
                area: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4_prefix: str | UndefinedType = Undefined,
                        area: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworkPrefixesItem.


                        Subclass of AvdModel.

                        Args:
                            ipv4_prefix: ipv4_prefix
                            area: area
                            _custom_data: _custom_data

                        """

            class NetworkPrefixes(AvdIndexedList[str, NetworkPrefixesItem]):
                """Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`)."""

                _primary_key: ClassVar[str] = "ipv4_prefix"

            NetworkPrefixes._item_type = NetworkPrefixesItem

            class NoPassiveInterfaces(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            NoPassiveInterfaces._item_type = str

            class DistributeListIn(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"route_map": {"type": str}, "_custom_data": {"type": dict}}
                route_map: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, route_map: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        DistributeListIn.


                        Subclass of AvdModel.

                        Args:
                            route_map: route_map
                            _custom_data: _custom_data

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Lsa(AvdModel):
                    """Subclass of AvdModel."""

                    class TxDelay(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"initial": {"type": int}, "min": {"type": int}, "max": {"type": int}, "_custom_data": {"type": dict}}
                        initial: int | None
                        """Delay to generate first occurrence of LSA in msecs."""
                        min: int | None
                        """Min delay between originating the same LSA in msecs."""
                        max: int | None
                        """1-600000 Maximum delay between originating the same LSA in msec."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                initial: int | None | UndefinedType = Undefined,
                                min: int | None | UndefinedType = Undefined,
                                max: int | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                TxDelay.


                                Subclass of AvdModel.

                                Args:
                                    initial: Delay to generate first occurrence of LSA in msecs.
                                    min: Min delay between originating the same LSA in msecs.
                                    max: 1-600000 Maximum delay between originating the same LSA in msec.
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {"rx_min_interval": {"type": int}, "tx_delay": {"type": TxDelay}, "_custom_data": {"type": dict}}
                    rx_min_interval: int | None
                    """Min interval in msecs between accepting the same LSA."""
                    tx_delay: TxDelay
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            rx_min_interval: int | None | UndefinedType = Undefined,
                            tx_delay: TxDelay | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Lsa.


                            Subclass of AvdModel.

                            Args:
                                rx_min_interval: Min interval in msecs between accepting the same LSA.
                                tx_delay: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                class SpfDelay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"initial": {"type": int}, "min": {"type": int}, "max": {"type": int}, "_custom_data": {"type": dict}}
                    initial: int | None
                    """Initial SPF schedule delay in msecs."""
                    min: int | None
                    """Min Hold time between two SPFs in msecs."""
                    max: int | None
                    """Max wait time between two SPFs in msecs."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            initial: int | None | UndefinedType = Undefined,
                            min: int | None | UndefinedType = Undefined,
                            max: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SpfDelay.


                            Subclass of AvdModel.

                            Args:
                                initial: Initial SPF schedule delay in msecs.
                                min: Min Hold time between two SPFs in msecs.
                                max: Max wait time between two SPFs in msecs.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"lsa": {"type": Lsa}, "spf_delay": {"type": SpfDelay}, "_custom_data": {"type": dict}}
                lsa: Lsa
                """Subclass of AvdModel."""
                spf_delay: SpfDelay
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        lsa: Lsa | UndefinedType = Undefined,
                        spf_delay: SpfDelay | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            lsa: Subclass of AvdModel.
                            spf_delay: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class DefaultInformationOriginate(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"always": {"type": bool}, "metric": {"type": int}, "metric_type": {"type": int}, "_custom_data": {"type": dict}}
                always: bool | None
                metric: int | None
                """Metric for default route."""
                metric_type: Literal[1, 2] | None
                """OSPF metric type for default route."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        always: bool | None | UndefinedType = Undefined,
                        metric: int | None | UndefinedType = Undefined,
                        metric_type: Literal[1, 2] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultInformationOriginate.


                        Subclass of AvdModel.

                        Args:
                            always: always
                            metric: Metric for default route.
                            metric_type: OSPF metric type for default route.
                            _custom_data: _custom_data

                        """

            class SummaryAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "prefix": {"type": str},
                    "tag": {"type": int},
                    "attribute_map": {"type": str},
                    "not_advertise": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                prefix: str
                """Summary Prefix Address."""
                tag: int | None
                attribute_map: str | None
                not_advertise: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        prefix: str | UndefinedType = Undefined,
                        tag: int | None | UndefinedType = Undefined,
                        attribute_map: str | None | UndefinedType = Undefined,
                        not_advertise: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SummaryAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            prefix: Summary Prefix Address.
                            tag: tag
                            attribute_map: attribute_map
                            not_advertise: not_advertise
                            _custom_data: _custom_data

                        """

            class SummaryAddresses(AvdIndexedList[str, SummaryAddressesItem]):
                """Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`)."""

                _primary_key: ClassVar[str] = "prefix"

            SummaryAddresses._item_type = SummaryAddressesItem

            class Redistribute(AvdModel):
                """Subclass of AvdModel."""

                class Static(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked
                                _custom_data: _custom_data

                            """

                class Connected(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked
                                _custom_data: _custom_data

                            """

                class Bgp(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                route_map: Route Map Name.
                                include_leaked: include_leaked
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"static": {"type": Static}, "connected": {"type": Connected}, "bgp": {"type": Bgp}, "_custom_data": {"type": dict}}
                static: Static
                """Subclass of AvdModel."""
                connected: Connected
                """Subclass of AvdModel."""
                bgp: Bgp
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        static: Static | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.


                        Subclass of AvdModel.

                        Args:
                            static: Subclass of AvdModel.
                            connected: Subclass of AvdModel.
                            bgp: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class AreasItem(AvdModel):
                """Subclass of AvdModel."""

                class Filter(AvdModel):
                    """Subclass of AvdModel."""

                    class Networks(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Networks._item_type = str

                    _fields: ClassVar[dict] = {"networks": {"type": Networks}, "prefix_list": {"type": str}, "_custom_data": {"type": dict}}
                    networks: Networks
                    """Subclass of AvdList with `str` items."""
                    prefix_list: str | None
                    """Prefix-List Name."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            networks: Networks | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.


                            Subclass of AvdModel.

                            Args:
                                networks: Subclass of AvdList with `str` items.
                                prefix_list: Prefix-List Name.
                                _custom_data: _custom_data

                            """

                class DefaultInformationOriginate(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"metric": {"type": int}, "metric_type": {"type": int}, "_custom_data": {"type": dict}}
                    metric: int | None
                    """Metric for default route."""
                    metric_type: Literal[1, 2] | None
                    """OSPF metric type for default route."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            metric: int | None | UndefinedType = Undefined,
                            metric_type: Literal[1, 2] | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultInformationOriginate.


                            Subclass of AvdModel.

                            Args:
                                metric: Metric for default route.
                                metric_type: OSPF metric type for default route.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "id": {"type": str},
                    "filter": {"type": Filter},
                    "type": {"type": str, "default": "normal"},
                    "no_summary": {"type": bool},
                    "nssa_only": {"type": bool},
                    "default_information_originate": {"type": DefaultInformationOriginate},
                    "_custom_data": {"type": dict},
                }
                id: str
                filter: Filter
                """Subclass of AvdModel."""
                type: Literal["normal", "stub", "nssa"]
                """Default value: `"normal"`"""
                no_summary: bool | None
                nssa_only: bool | None
                default_information_originate: DefaultInformationOriginate
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        type: Literal["normal", "stub", "nssa"] | UndefinedType = Undefined,
                        no_summary: bool | None | UndefinedType = Undefined,
                        nssa_only: bool | None | UndefinedType = Undefined,
                        default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AreasItem.


                        Subclass of AvdModel.

                        Args:
                            id: id
                            filter: Subclass of AvdModel.
                            type: type
                            no_summary: no_summary
                            nssa_only: nssa_only
                            default_information_originate: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Areas(AvdIndexedList[str, AreasItem]):
                """Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`)."""

                _primary_key: ClassVar[str] = "id"

            Areas._item_type = AreasItem

            class MaxMetric(AvdModel):
                """Subclass of AvdModel."""

                class RouterLsa(AvdModel):
                    """Subclass of AvdModel."""

                    class ExternalLsa(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"override_metric": {"type": int}, "_custom_data": {"type": dict}}
                        override_metric: int | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, override_metric: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                ExternalLsa.


                                Subclass of AvdModel.

                                Args:
                                    override_metric: override_metric
                                    _custom_data: _custom_data

                                """

                    class SummaryLsa(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {"override_metric": {"type": int}, "_custom_data": {"type": dict}}
                        override_metric: int | None
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self, *, override_metric: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                            ) -> None:
                                """
                                SummaryLsa.


                                Subclass of AvdModel.

                                Args:
                                    override_metric: override_metric
                                    _custom_data: _custom_data

                                """

                    _fields: ClassVar[dict] = {
                        "external_lsa": {"type": ExternalLsa},
                        "include_stub": {"type": bool},
                        "on_startup": {"type": str},
                        "summary_lsa": {"type": SummaryLsa},
                        "_custom_data": {"type": dict},
                    }
                    external_lsa: ExternalLsa
                    """Subclass of AvdModel."""
                    include_stub: bool | None
                    on_startup: str | None
                    """
                    "wait-for-bgp" or Integer 5-86400.
                    Example: "wait-for-bgp" Or "222"
                    """
                    summary_lsa: SummaryLsa
                    """Subclass of AvdModel."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            external_lsa: ExternalLsa | UndefinedType = Undefined,
                            include_stub: bool | None | UndefinedType = Undefined,
                            on_startup: str | None | UndefinedType = Undefined,
                            summary_lsa: SummaryLsa | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RouterLsa.


                            Subclass of AvdModel.

                            Args:
                                external_lsa: Subclass of AvdModel.
                                include_stub: include_stub
                                on_startup:
                                   "wait-for-bgp" or Integer 5-86400.
                                   Example: "wait-for-bgp" Or "222"
                                summary_lsa: Subclass of AvdModel.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"router_lsa": {"type": RouterLsa}, "_custom_data": {"type": dict}}
                router_lsa: RouterLsa
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, router_lsa: RouterLsa | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        MaxMetric.


                        Subclass of AvdModel.

                        Args:
                            router_lsa: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class GracefulRestart(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "grace_period": {"type": int}, "_custom_data": {"type": dict}}
                enabled: bool
                grace_period: int | None
                """Specify maximum time in seconds to wait for graceful-restart to complete."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        grace_period: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GracefulRestart.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            grace_period: Specify maximum time in seconds to wait for graceful-restart to complete.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "vrf": {"type": str},
                "passive_interface_default": {"type": bool},
                "router_id": {"type": str},
                "distance": {"type": Distance},
                "log_adjacency_changes_detail": {"type": bool},
                "network_prefixes": {"type": NetworkPrefixes},
                "bfd_enable": {"type": bool},
                "bfd_adjacency_state_any": {"type": bool},
                "no_passive_interfaces": {"type": NoPassiveInterfaces},
                "distribute_list_in": {"type": DistributeListIn},
                "max_lsa": {"type": int},
                "timers": {"type": Timers},
                "default_information_originate": {"type": DefaultInformationOriginate},
                "summary_addresses": {"type": SummaryAddresses},
                "redistribute": {"type": Redistribute},
                "auto_cost_reference_bandwidth": {"type": int},
                "areas": {"type": Areas},
                "maximum_paths": {"type": int},
                "max_metric": {"type": MaxMetric},
                "graceful_restart": {"type": GracefulRestart},
                "graceful_restart_helper": {"type": bool},
                "mpls_ldp_sync_default": {"type": bool},
                "eos_cli": {"type": str},
                "_custom_data": {"type": dict},
            }
            id: int
            """OSPF Process ID."""
            vrf: str | None
            """VRF Name for OSPF Process."""
            passive_interface_default: bool | None
            router_id: str | None
            """IPv4 Address."""
            distance: Distance
            """Subclass of AvdModel."""
            log_adjacency_changes_detail: bool | None
            network_prefixes: NetworkPrefixes
            """Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`)."""
            bfd_enable: bool | None
            bfd_adjacency_state_any: bool | None
            no_passive_interfaces: NoPassiveInterfaces
            """Subclass of AvdList with `str` items."""
            distribute_list_in: DistributeListIn
            """Subclass of AvdModel."""
            max_lsa: int | None
            timers: Timers
            """Subclass of AvdModel."""
            default_information_originate: DefaultInformationOriginate
            """Subclass of AvdModel."""
            summary_addresses: SummaryAddresses
            """Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`)."""
            redistribute: Redistribute
            """Subclass of AvdModel."""
            auto_cost_reference_bandwidth: int | None
            """Bandwidth in mbps."""
            areas: Areas
            """Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`)."""
            maximum_paths: int | None
            max_metric: MaxMetric
            """Subclass of AvdModel."""
            graceful_restart: GracefulRestart
            """Subclass of AvdModel."""
            graceful_restart_helper: bool | None
            mpls_ldp_sync_default: bool | None
            eos_cli: str | None
            """Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    passive_interface_default: bool | None | UndefinedType = Undefined,
                    router_id: str | None | UndefinedType = Undefined,
                    distance: Distance | UndefinedType = Undefined,
                    log_adjacency_changes_detail: bool | None | UndefinedType = Undefined,
                    network_prefixes: NetworkPrefixes | UndefinedType = Undefined,
                    bfd_enable: bool | None | UndefinedType = Undefined,
                    bfd_adjacency_state_any: bool | None | UndefinedType = Undefined,
                    no_passive_interfaces: NoPassiveInterfaces | UndefinedType = Undefined,
                    distribute_list_in: DistributeListIn | UndefinedType = Undefined,
                    max_lsa: int | None | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                    summary_addresses: SummaryAddresses | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    auto_cost_reference_bandwidth: int | None | UndefinedType = Undefined,
                    areas: Areas | UndefinedType = Undefined,
                    maximum_paths: int | None | UndefinedType = Undefined,
                    max_metric: MaxMetric | UndefinedType = Undefined,
                    graceful_restart: GracefulRestart | UndefinedType = Undefined,
                    graceful_restart_helper: bool | None | UndefinedType = Undefined,
                    mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProcessIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: OSPF Process ID.
                        vrf: VRF Name for OSPF Process.
                        passive_interface_default: passive_interface_default
                        router_id: IPv4 Address.
                        distance: Subclass of AvdModel.
                        log_adjacency_changes_detail: log_adjacency_changes_detail
                        network_prefixes: Subclass of AvdIndexedList with `NetworkPrefixesItem` items. Primary key is `ipv4_prefix` (`str`).
                        bfd_enable: bfd_enable
                        bfd_adjacency_state_any: bfd_adjacency_state_any
                        no_passive_interfaces: Subclass of AvdList with `str` items.
                        distribute_list_in: Subclass of AvdModel.
                        max_lsa: max_lsa
                        timers: Subclass of AvdModel.
                        default_information_originate: Subclass of AvdModel.
                        summary_addresses: Subclass of AvdIndexedList with `SummaryAddressesItem` items. Primary key is `prefix` (`str`).
                        redistribute: Subclass of AvdModel.
                        auto_cost_reference_bandwidth: Bandwidth in mbps.
                        areas: Subclass of AvdIndexedList with `AreasItem` items. Primary key is `id` (`str`).
                        maximum_paths: maximum_paths
                        max_metric: Subclass of AvdModel.
                        graceful_restart: Subclass of AvdModel.
                        graceful_restart_helper: graceful_restart_helper
                        mpls_ldp_sync_default: mpls_ldp_sync_default
                        eos_cli: Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration.
                        _custom_data: _custom_data

                    """

        class ProcessIds(AvdIndexedList[int, ProcessIdsItem]):
            """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        ProcessIds._item_type = ProcessIdsItem

        _fields: ClassVar[dict] = {"process_ids": {"type": ProcessIds}, "_custom_data": {"type": dict}}
        process_ids: ProcessIds
        """Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, process_ids: ProcessIds | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                RouterOspf.


                Subclass of AvdModel.

                Args:
                    process_ids: Subclass of AvdIndexedList with `ProcessIdsItem` items. Primary key is `id` (`int`).
                    _custom_data: _custom_data

                """

    class RouterPathSelection(AvdModel):
        """Subclass of AvdModel."""

        class PathGroupsItem(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterfacesItem(AvdModel):
                """Subclass of AvdModel."""

                class Stun(AvdModel):
                    """Subclass of AvdModel."""

                    class ServerProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ServerProfiles._item_type = str

                    _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}, "_custom_data": {"type": dict}}
                    server_profiles: ServerProfiles
                    """
                    STUN server-profile names.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, server_profiles: ServerProfiles | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Stun.


                            Subclass of AvdModel.

                            Args:
                                server_profiles:
                                   STUN server-profile names.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"name": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}, "_custom_data": {"type": dict}}
                name: str
                """Local interface name."""
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        public_address: str | None | UndefinedType = Undefined,
                        stun: Stun | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalInterfacesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Local interface name.
                            public_address: Public IP assigned by NAT.
                            stun: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class LocalInterfaces(AvdIndexedList[str, LocalInterfacesItem]):
                """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            LocalInterfaces._item_type = LocalInterfacesItem

            class LocalIpsItem(AvdModel):
                """Subclass of AvdModel."""

                class Stun(AvdModel):
                    """Subclass of AvdModel."""

                    class ServerProfiles(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    ServerProfiles._item_type = str

                    _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}, "_custom_data": {"type": dict}}
                    server_profiles: ServerProfiles
                    """
                    STUN server-profile names.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, server_profiles: ServerProfiles | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Stun.


                            Subclass of AvdModel.

                            Args:
                                server_profiles:
                                   STUN server-profile names.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ip_address": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}, "_custom_data": {"type": dict}}
                ip_address: str
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ip_address: str | UndefinedType = Undefined,
                        public_address: str | None | UndefinedType = Undefined,
                        stun: Stun | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalIpsItem.


                        Subclass of AvdModel.

                        Args:
                            ip_address: ip_address
                            public_address: Public IP assigned by NAT.
                            stun: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class LocalIps(AvdIndexedList[str, LocalIpsItem]):
                """Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`)."""

                _primary_key: ClassVar[str] = "ip_address"

            LocalIps._item_type = LocalIpsItem

            class DynamicPeers(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "ip_local": {"type": bool}, "ipsec": {"type": bool}, "_custom_data": {"type": dict}}
                enabled: bool | None
                """Enable `peer dynamic`."""
                ip_local: bool | None
                """Prefer local IP address."""
                ipsec: bool | None
                """IPsec configuration for dynamic peers."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        ip_local: bool | None | UndefinedType = Undefined,
                        ipsec: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicPeers.


                        Subclass of AvdModel.

                        Args:
                            enabled: Enable `peer dynamic`.
                            ip_local: Prefer local IP address.
                            ipsec: IPsec configuration for dynamic peers.
                            _custom_data: _custom_data

                        """

            class StaticPeersItem(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4Addresses(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Ipv4Addresses._item_type = str

                _fields: ClassVar[dict] = {
                    "router_ip": {"type": str},
                    "name": {"type": str},
                    "ipv4_addresses": {"type": Ipv4Addresses},
                    "_custom_data": {"type": dict},
                }
                router_ip: str
                """Peer router IP."""
                name: str | None
                """Name of the site."""
                ipv4_addresses: Ipv4Addresses
                """
                Static IPv4 addresses.

                Subclass of AvdList with `str` items.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        router_ip: str | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        ipv4_addresses: Ipv4Addresses | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticPeersItem.


                        Subclass of AvdModel.

                        Args:
                            router_ip: Peer router IP.
                            name: Name of the site.
                            ipv4_addresses:
                               Static IPv4 addresses.

                               Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class StaticPeers(AvdIndexedList[str, StaticPeersItem]):
                """Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`)."""

                _primary_key: ClassVar[str] = "router_ip"

            StaticPeers._item_type = StaticPeersItem

            class Keepalive(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "auto": {"type": bool, "default": False},
                    "interval": {"type": int},
                    "failure_threshold": {"type": int},
                    "_custom_data": {"type": dict},
                }
                auto: bool
                """
                Enable adaptive keepalive and feedback interval.

                Default value: `False`
                """
                interval: int | None
                """Interval in milliseconds."""
                failure_threshold: int | None
                """Failure threshold in number of intervals. Required when `interval` is set."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        auto: bool | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                        failure_threshold: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Keepalive.


                        Subclass of AvdModel.

                        Args:
                            auto: Enable adaptive keepalive and feedback interval.
                            interval: Interval in milliseconds.
                            failure_threshold: Failure threshold in number of intervals. Required when `interval` is set.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "id": {"type": int},
                "ipsec_profile": {"type": str},
                "flow_assignment": {"type": str},
                "local_interfaces": {"type": LocalInterfaces},
                "local_ips": {"type": LocalIps},
                "dynamic_peers": {"type": DynamicPeers},
                "static_peers": {"type": StaticPeers},
                "keepalive": {"type": Keepalive},
                "_custom_data": {"type": dict},
            }
            name: str
            """Path group name."""
            id: int | None
            """Path group ID."""
            ipsec_profile: str | None
            """IPSec profile for the path group."""
            flow_assignment: Literal["lan"] | None
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            local_interfaces: LocalInterfaces
            """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""
            local_ips: LocalIps
            """Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`)."""
            dynamic_peers: DynamicPeers
            """
            Flow assignment `lan` can not be configured in a path group with dynamic peers.

            Subclass of
            AvdModel.
            """
            static_peers: StaticPeers
            """Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`)."""
            keepalive: Keepalive
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    id: int | None | UndefinedType = Undefined,
                    ipsec_profile: str | None | UndefinedType = Undefined,
                    flow_assignment: Literal["lan"] | None | UndefinedType = Undefined,
                    local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                    local_ips: LocalIps | UndefinedType = Undefined,
                    dynamic_peers: DynamicPeers | UndefinedType = Undefined,
                    static_peers: StaticPeers | UndefinedType = Undefined,
                    keepalive: Keepalive | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathGroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Path group name.
                        id: Path group ID.
                        ipsec_profile: IPSec profile for the path group.
                        flow_assignment: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                        local_interfaces: Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`).
                        local_ips: Subclass of AvdIndexedList with `LocalIpsItem` items. Primary key is `ip_address` (`str`).
                        dynamic_peers:
                           Flow assignment `lan` can not be configured in a path group with dynamic peers.

                           Subclass of
                           AvdModel.
                        static_peers: Subclass of AvdIndexedList with `StaticPeersItem` items. Primary key is `router_ip` (`str`).
                        keepalive: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class PathGroups(AvdIndexedList[str, PathGroupsItem]):
            """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        PathGroups._item_type = PathGroupsItem

        class LoadBalancePoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class PathGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "priority": {"type": int}, "_custom_data": {"type": dict}}
                name: str
                """Path-group name."""
                priority: int | None
                """
                Priority for this path-group.
                The EOS default value is 1.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Path-group name.
                            priority:
                               Priority for this path-group.
                               The EOS default value is 1.
                            _custom_data: _custom_data

                        """

            class PathGroups(AvdIndexedList[str, PathGroupsItem]):
                """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            PathGroups._item_type = PathGroupsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "lowest_hop_count": {"type": bool},
                "jitter": {"type": int},
                "latency": {"type": int},
                "loss_rate": {"type": str},
                "path_groups": {"type": PathGroups},
                "_custom_data": {"type": dict},
            }
            name: str
            """Load-balance policy name."""
            lowest_hop_count: bool | None
            """Prefer paths with lowest hop-count."""
            jitter: int | None
            """Jitter requirement for this load balance policy in milliseconds."""
            latency: int | None
            """One way delay requirement for this load balance policy in milliseconds."""
            loss_rate: str | None
            """
            Loss Rate requirement in percentage for this load balance policy.
            Value between 0.00 and 100.00.
            """
            path_groups: PathGroups
            """
            List of path-groups to use for this load balance policy.

            Subclass of AvdIndexedList with
            `PathGroupsItem` items. Primary key is `name` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    lowest_hop_count: bool | None | UndefinedType = Undefined,
                    jitter: int | None | UndefinedType = Undefined,
                    latency: int | None | UndefinedType = Undefined,
                    loss_rate: str | None | UndefinedType = Undefined,
                    path_groups: PathGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LoadBalancePoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Load-balance policy name.
                        lowest_hop_count: Prefer paths with lowest hop-count.
                        jitter: Jitter requirement for this load balance policy in milliseconds.
                        latency: One way delay requirement for this load balance policy in milliseconds.
                        loss_rate:
                           Loss Rate requirement in percentage for this load balance policy.
                           Value between 0.00 and 100.00.
                        path_groups:
                           List of path-groups to use for this load balance policy.

                           Subclass of AvdIndexedList with
                           `PathGroupsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class LoadBalancePolicies(AvdIndexedList[str, LoadBalancePoliciesItem]):
            """Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LoadBalancePolicies._item_type = LoadBalancePoliciesItem

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class DefaultMatch(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"load_balance": {"type": str}, "_custom_data": {"type": dict}}
                load_balance: str | None
                """Name of the load-balance policy."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, load_balance: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        DefaultMatch.


                        Subclass of AvdModel.

                        Args:
                            load_balance: Name of the load-balance policy.
                            _custom_data: _custom_data

                        """

            class RulesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "id": {"type": int},
                    "application_profile": {"type": str},
                    "load_balance": {"type": str},
                    "_custom_data": {"type": dict},
                }
                id: int
                """Rule ID."""
                application_profile: str
                load_balance: str | None
                """Name of the load-balance policy."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: int | UndefinedType = Undefined,
                        application_profile: str | UndefinedType = Undefined,
                        load_balance: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RulesItem.


                        Subclass of AvdModel.

                        Args:
                            id: Rule ID.
                            application_profile: application_profile
                            load_balance: Name of the load-balance policy.
                            _custom_data: _custom_data

                        """

            class Rules(AvdIndexedList[int, RulesItem]):
                """Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`)."""

                _primary_key: ClassVar[str] = "id"

            Rules._item_type = RulesItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "default_match": {"type": DefaultMatch}, "rules": {"type": Rules}, "_custom_data": {"type": dict}}
            name: str
            """DPS policy name."""
            default_match: DefaultMatch
            """Subclass of AvdModel."""
            rules: Rules
            """Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    default_match: DefaultMatch | UndefinedType = Undefined,
                    rules: Rules | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: DPS policy name.
                        default_match: Subclass of AvdModel.
                        rules: Subclass of AvdIndexedList with `RulesItem` items. Primary key is `id` (`int`).
                        _custom_data: _custom_data

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "path_selection_policy": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """VRF name."""
            path_selection_policy: str | None
            """DPS policy name to use for this VRF."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    path_selection_policy: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        path_selection_policy: DPS policy name to use for this VRF.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4_segment_size": {"type": str}, "direction": {"type": str, "default": "ingress"}, "_custom_data": {"type": dict}}
            ipv4_segment_size: str | None
            """
            Segment Size for IPv4.
            Can be an integer in the range 64-65515 or "auto".
            "auto" will enable auto-
            discovery which clamps the TCP MSS value to the minimum of all the direct paths
            and multi-hop path
            MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
            """
            direction: Literal["ingress"]
            """
            Enforce on packets through DPS tunnel for a specific direction.
            Only 'ingress' direction is
            supported.

            Default value: `"ingress"`
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4_segment_size: str | None | UndefinedType = Undefined,
                    direction: Literal["ingress"] | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4_segment_size:
                           Segment Size for IPv4.
                           Can be an integer in the range 64-65515 or "auto".
                           "auto" will enable auto-
                           discovery which clamps the TCP MSS value to the minimum of all the direct paths
                           and multi-hop path
                           MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
                        direction:
                           Enforce on packets through DPS tunnel for a specific direction.
                           Only 'ingress' direction is
                           supported.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "peer_dynamic_source": {"type": str},
            "path_groups": {"type": PathGroups},
            "load_balance_policies": {"type": LoadBalancePolicies},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "_custom_data": {"type": dict},
        }
        peer_dynamic_source: Literal["stun"] | None
        """Source of dynamic peer discovery."""
        path_groups: PathGroups
        """Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`)."""
        load_balance_policies: LoadBalancePolicies
        """Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`)."""
        policies: Policies
        """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                peer_dynamic_source: Literal["stun"] | None | UndefinedType = Undefined,
                path_groups: PathGroups | UndefinedType = Undefined,
                load_balance_policies: LoadBalancePolicies | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterPathSelection.


                Subclass of AvdModel.

                Args:
                    peer_dynamic_source: Source of dynamic peer discovery.
                    path_groups: Subclass of AvdIndexedList with `PathGroupsItem` items. Primary key is `name` (`str`).
                    load_balance_policies: Subclass of AvdIndexedList with `LoadBalancePoliciesItem` items. Primary key is `name` (`str`).
                    policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    tcp_mss_ceiling: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class RouterPimSparseMode(AvdModel):
        """Subclass of AvdModel."""

        class Ipv4(AvdModel):
            """Subclass of AvdModel."""

            class RpAddressesItem(AvdModel):
                """Subclass of AvdModel."""

                class Groups(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Groups._item_type = str

                class AccessLists(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                AccessLists._item_type = str

                _fields: ClassVar[dict] = {
                    "address": {"type": str},
                    "groups": {"type": Groups},
                    "access_lists": {"type": AccessLists},
                    "priority": {"type": int},
                    "hashmask": {"type": int},
                    "override": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                address: str
                """RP Address."""
                groups: Groups
                """Subclass of AvdList with `str` items."""
                access_lists: AccessLists
                """Subclass of AvdList with `str` items."""
                priority: int | None
                hashmask: int | None
                override: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        groups: Groups | UndefinedType = Undefined,
                        access_lists: AccessLists | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        hashmask: int | None | UndefinedType = Undefined,
                        override: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RpAddressesItem.


                        Subclass of AvdModel.

                        Args:
                            address: RP Address.
                            groups: Subclass of AvdList with `str` items.
                            access_lists: Subclass of AvdList with `str` items.
                            priority: priority
                            hashmask: hashmask
                            override: override
                            _custom_data: _custom_data

                        """

            class RpAddresses(AvdList[RpAddressesItem]):
                """Subclass of AvdList with `RpAddressesItem` items."""

            RpAddresses._item_type = RpAddressesItem

            class AnycastRpsItem(AvdModel):
                """Subclass of AvdModel."""

                class OtherAnycastRpAddressesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"address": {"type": str}, "register_count": {"type": int}, "_custom_data": {"type": dict}}
                    address: str
                    """Other Anycast RP Address."""
                    register_count: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address: str | UndefinedType = Undefined,
                            register_count: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            OtherAnycastRpAddressesItem.


                            Subclass of AvdModel.

                            Args:
                                address: Other Anycast RP Address.
                                register_count: register_count
                                _custom_data: _custom_data

                            """

                class OtherAnycastRpAddresses(AvdIndexedList[str, OtherAnycastRpAddressesItem]):
                    """
                    Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                    (`str`).
                    """

                    _primary_key: ClassVar[str] = "address"

                OtherAnycastRpAddresses._item_type = OtherAnycastRpAddressesItem

                _fields: ClassVar[dict] = {
                    "address": {"type": str},
                    "other_anycast_rp_addresses": {"type": OtherAnycastRpAddresses},
                    "_custom_data": {"type": dict},
                }
                address: str
                """Anycast RP Address."""
                other_anycast_rp_addresses: OtherAnycastRpAddresses
                """
                Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                (`str`).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        other_anycast_rp_addresses: OtherAnycastRpAddresses | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AnycastRpsItem.


                        Subclass of AvdModel.

                        Args:
                            address: Anycast RP Address.
                            other_anycast_rp_addresses:
                               Subclass of AvdIndexedList with `OtherAnycastRpAddressesItem` items. Primary key is `address`
                               (`str`).
                            _custom_data: _custom_data

                        """

            class AnycastRps(AvdIndexedList[str, AnycastRpsItem]):
                """Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`)."""

                _primary_key: ClassVar[str] = "address"

            AnycastRps._item_type = AnycastRpsItem

            _fields: ClassVar[dict] = {
                "bfd": {"type": bool},
                "make_before_break": {"type": bool},
                "ssm_range": {"type": str},
                "rp_addresses": {"type": RpAddresses},
                "anycast_rps": {"type": AnycastRps},
                "_custom_data": {"type": dict},
            }
            bfd: bool | None
            """Enable/Disable BFD."""
            make_before_break: bool | None
            """Enable/Disable Make-Before-Break."""
            ssm_range: str | None
            """IPv4 Prefix associated with SSM."""
            rp_addresses: RpAddresses
            """Subclass of AvdList with `RpAddressesItem` items."""
            anycast_rps: AnycastRps
            """Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bfd: bool | None | UndefinedType = Undefined,
                    make_before_break: bool | None | UndefinedType = Undefined,
                    ssm_range: str | None | UndefinedType = Undefined,
                    rp_addresses: RpAddresses | UndefinedType = Undefined,
                    anycast_rps: AnycastRps | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.


                    Subclass of AvdModel.

                    Args:
                        bfd: Enable/Disable BFD.
                        make_before_break: Enable/Disable Make-Before-Break.
                        ssm_range: IPv4 Prefix associated with SSM.
                        rp_addresses: Subclass of AvdList with `RpAddressesItem` items.
                        anycast_rps: Subclass of AvdIndexedList with `AnycastRpsItem` items. Primary key is `address` (`str`).
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class RpAddressesItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Groups(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Groups._item_type = str

                    class AccessLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    AccessLists._item_type = str

                    _fields: ClassVar[dict] = {
                        "address": {"type": str},
                        "groups": {"type": Groups},
                        "access_lists": {"type": AccessLists},
                        "priority": {"type": int},
                        "hashmask": {"type": int},
                        "override": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    address: str
                    """RP Address."""
                    groups: Groups
                    """Subclass of AvdList with `str` items."""
                    access_lists: AccessLists
                    """Subclass of AvdList with `str` items."""
                    priority: int | None
                    hashmask: int | None
                    override: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            address: str | UndefinedType = Undefined,
                            groups: Groups | UndefinedType = Undefined,
                            access_lists: AccessLists | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            hashmask: int | None | UndefinedType = Undefined,
                            override: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RpAddressesItem.


                            Subclass of AvdModel.

                            Args:
                                address: RP Address.
                                groups: Subclass of AvdList with `str` items.
                                access_lists: Subclass of AvdList with `str` items.
                                priority: priority
                                hashmask: hashmask
                                override: override
                                _custom_data: _custom_data

                            """

                class RpAddresses(AvdList[RpAddressesItem]):
                    """Subclass of AvdList with `RpAddressesItem` items."""

                RpAddresses._item_type = RpAddressesItem

                _fields: ClassVar[dict] = {
                    "bfd": {"type": bool},
                    "make_before_break": {"type": bool},
                    "rp_addresses": {"type": RpAddresses},
                    "_custom_data": {"type": dict},
                }
                bfd: bool | None
                """Enable/Disable BFD."""
                make_before_break: bool | None
                """Enable/Disable Make-Before-Break."""
                rp_addresses: RpAddresses
                """Subclass of AvdList with `RpAddressesItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        bfd: bool | None | UndefinedType = Undefined,
                        make_before_break: bool | None | UndefinedType = Undefined,
                        rp_addresses: RpAddresses | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            bfd: Enable/Disable BFD.
                            make_before_break: Enable/Disable Make-Before-Break.
                            rp_addresses: Subclass of AvdList with `RpAddressesItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"name": {"type": str}, "ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
            name: str
            """VRF Name."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF Name.
                        ipv4: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "vrfs": {"type": Vrfs}, "_custom_data": {"type": dict}}
        ipv4: Ipv4
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                ipv4: Ipv4 | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterPimSparseMode.


                Subclass of AvdModel.

                Args:
                    ipv4: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterSegmentSecurity(AvdModel):
        """Subclass of AvdModel."""

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class SequenceNumbersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "sequence": {"type": int},
                    "application": {"type": str},
                    "action": {"type": str},
                    "log": {"type": bool},
                    "stateless": {"type": bool, "default": True},
                    "next_hop": {"type": str},
                    "_custom_data": {"type": dict},
                }
                sequence: int
                """Sequence ID."""
                application: str
                """The name of the application."""
                action: Literal["forward", "drop", "redirect"]
                """
                The action to take - note that platform support for the redirect action is limited. The "redirect"
                action also requires the 'next_hop' to be configured.
                """
                log: bool | None
                """Enable logging - note that platform support is limited."""
                stateless: bool
                """
                Take action, regardless of state. Should be set to 'true' for MSS-G.

                Default value: `True`
                """
                next_hop: str | None
                """When the action is 'redirect', this indicates the IPv4 next hop to redirect to."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        sequence: int | UndefinedType = Undefined,
                        application: str | UndefinedType = Undefined,
                        action: Literal["forward", "drop", "redirect"] | UndefinedType = Undefined,
                        log: bool | None | UndefinedType = Undefined,
                        stateless: bool | UndefinedType = Undefined,
                        next_hop: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SequenceNumbersItem.


                        Subclass of AvdModel.

                        Args:
                            sequence: Sequence ID.
                            application: The name of the application.
                            action:
                               The action to take - note that platform support for the redirect action is limited. The "redirect"
                               action also requires the 'next_hop' to be configured.
                            log: Enable logging - note that platform support is limited.
                            stateless: Take action, regardless of state. Should be set to 'true' for MSS-G.
                            next_hop: When the action is 'redirect', this indicates the IPv4 next hop to redirect to.
                            _custom_data: _custom_data

                        """

            class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
                """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}, "_custom_data": {"type": dict}}
            name: str
            """Policy name."""
            sequence_numbers: SequenceNumbers
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Policy name.
                        sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                        _custom_data: _custom_data

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class SegmentsItem(AvdModel):
                """Subclass of AvdModel."""

                class Definition(AvdModel):
                    """Subclass of AvdModel."""

                    class Interfaces(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Interfaces._item_type = str

                    class MatchListsItem(AvdModel):
                        """Subclass of AvdModel."""

                        _fields: ClassVar[dict] = {
                            "address_family": {"type": str},
                            "covered_prefix_list": {"type": str},
                            "prefix": {"type": str},
                            "_custom_data": {"type": dict},
                        }
                        address_family: Literal["ipv4", "ipv6"]
                        """Indicate which address-family the match list belongs to e.g. ipv4 or ipv6."""
                        covered_prefix_list: str | None
                        """
                        The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of match_list.  If both are configured prefix takes precedence.
                        """
                        prefix: str | None
                        """
                        The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of covered_prefix_list. If both are configured prefix takes precedence.
                        """
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                address_family: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                                covered_prefix_list: str | None | UndefinedType = Undefined,
                                prefix: str | None | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchListsItem.


                                Subclass of AvdModel.

                                Args:
                                    address_family: Indicate which address-family the match list belongs to e.g. ipv4 or ipv6.
                                    covered_prefix_list:
                                       The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                                       the use of match_list.  If both are configured prefix takes precedence.
                                    prefix:
                                       The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                                       the use of covered_prefix_list. If both are configured prefix takes precedence.
                                    _custom_data: _custom_data

                                """

                    class MatchLists(AvdIndexedList[str, MatchListsItem]):
                        """Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`)."""

                        _primary_key: ClassVar[str] = "address_family"

                    MatchLists._item_type = MatchListsItem

                    _fields: ClassVar[dict] = {"interfaces": {"type": Interfaces}, "match_lists": {"type": MatchLists}, "_custom_data": {"type": dict}}
                    interfaces: Interfaces
                    """
                    The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                    Subclass of AvdList with `str` items.
                    """
                    match_lists: MatchLists
                    """
                    The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.
                    Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`).
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interfaces: Interfaces | UndefinedType = Undefined,
                            match_lists: MatchLists | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Definition.


                            Subclass of AvdModel.

                            Args:
                                interfaces:
                                   The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                                   Subclass of AvdList with `str` items.
                                match_lists:
                                   The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.
                                   Subclass of AvdIndexedList with `MatchListsItem` items. Primary key is `address_family` (`str`).
                                _custom_data: _custom_data

                            """

                class PoliciesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"field_from": {"type": str}, "policy": {"type": str}, "_custom_data": {"type": dict}}
                    _field_to_key_map: ClassVar[dict] = {"field_from": "from"}
                    _key_to_field_map: ClassVar[dict] = {"from": "field_from"}
                    field_from: str
                    """The name of the source segment or 'forwarding-segments' for all segments."""
                    policy: str | None
                    """
                    The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                    all'.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            field_from: str | UndefinedType = Undefined,
                            policy: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PoliciesItem.


                            Subclass of AvdModel.

                            Args:
                                field_from: The name of the source segment or 'forwarding-segments' for all segments.
                                policy:
                                   The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                                   all'.
                                _custom_data: _custom_data

                            """

                class Policies(AvdIndexedList[str, PoliciesItem]):
                    """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `field_from` (`str`)."""

                    _primary_key: ClassVar[str] = "field_from"

                Policies._item_type = PoliciesItem

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "definition": {"type": Definition},
                    "policies": {"type": Policies},
                    "fallback_policy": {"type": str},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Segment name."""
                definition: Definition
                """Subclass of AvdModel."""
                policies: Policies
                """
                The policies controlling traffic into the segment.

                Subclass of AvdIndexedList with `PoliciesItem`
                items. Primary key is `field_from` (`str`).
                """
                fallback_policy: str | None
                """
                Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                by name.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        definition: Definition | UndefinedType = Undefined,
                        policies: Policies | UndefinedType = Undefined,
                        fallback_policy: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SegmentsItem.


                        Subclass of AvdModel.

                        Args:
                            name: Segment name.
                            definition: Subclass of AvdModel.
                            policies:
                               The policies controlling traffic into the segment.

                               Subclass of AvdIndexedList with `PoliciesItem`
                               items. Primary key is `field_from` (`str`).
                            fallback_policy:
                               Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                               by name.
                            _custom_data: _custom_data

                        """

            class Segments(AvdIndexedList[str, SegmentsItem]):
                """Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Segments._item_type = SegmentsItem

            _fields: ClassVar[dict] = {"name": {"type": str}, "segments": {"type": Segments}, "_custom_data": {"type": dict}}
            name: str
            segments: Segments
            """Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    segments: Segments | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        segments: Subclass of AvdIndexedList with `SegmentsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "policies": {"type": Policies}, "vrfs": {"type": Vrfs}, "_custom_data": {"type": dict}}
        enabled: bool | None
        policies: Policies
        """
        Customised application policies.
        Using the Application Traffic Recognition L4 profiles, custom
        policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
        Note that this is stateless, so both the source and destination flows need to be considered.
        Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
        """
        vrfs: Vrfs
        """
        The name of the VRF that the segments and policies are defined in.

        Subclass of AvdIndexedList with
        `VrfsItem` items. Primary key is `name` (`str`).
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | None | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterSegmentSecurity.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    policies:
                       Customised application policies.
                       Using the Application Traffic Recognition L4 profiles, custom
                       policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
                       Note that this is stateless, so both the source and destination flows need to be considered.
                       Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    vrfs:
                       The name of the VRF that the segments and policies are defined in.

                       Subclass of AvdIndexedList with
                       `VrfsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterServiceInsertion(AvdModel):
        """Subclass of AvdModel."""

        class ConnectionsItem(AvdModel):
            """Subclass of AvdModel."""

            class EthernetInterface(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "next_hop": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                """e.g. Ethernet2 or Ethernet2/2.2"""
                next_hop: str
                """Next-hop IPv4 address (without mask)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        next_hop: str | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EthernetInterface.


                        Subclass of AvdModel.

                        Args:
                            name: e.g. Ethernet2 or Ethernet2/2.2
                            next_hop: Next-hop IPv4 address (without mask).
                            _custom_data: _custom_data

                        """

            class TunnelInterface(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"primary": {"type": str}, "secondary": {"type": str}, "_custom_data": {"type": dict}}
                primary: str | None
                """e.g. Tunnel2"""
                secondary: str | None
                """e.g. Tunnel3"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        primary: str | None | UndefinedType = Undefined,
                        secondary: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TunnelInterface.


                        Subclass of AvdModel.

                        Args:
                            primary: e.g. Tunnel2
                            secondary: e.g. Tunnel3
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "ethernet_interface": {"type": EthernetInterface},
                "tunnel_interface": {"type": TunnelInterface},
                "monitor_connectivity_host": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Connection name."""
            ethernet_interface: EthernetInterface
            """
            Outgoing physical interface or subinterface to use for the connection.
            If both `ethernet_interface`
            and `tunnel_interface` are configured, `ethernet_interface` will be used.

            Subclass of AvdModel.
            """
            tunnel_interface: TunnelInterface
            """
            Outgoing tunnel interface(s) to use for this connection.
            If both `ethernet_interface` and
            `tunnel_interface` are configured, `ethernet_interface` will be used.

            Subclass of AvdModel.
            """
            monitor_connectivity_host: str | None
            """
            Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
            connection.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    ethernet_interface: EthernetInterface | UndefinedType = Undefined,
                    tunnel_interface: TunnelInterface | UndefinedType = Undefined,
                    monitor_connectivity_host: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConnectionsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Connection name.
                        ethernet_interface:
                           Outgoing physical interface or subinterface to use for the connection.
                           If both `ethernet_interface`
                           and `tunnel_interface` are configured, `ethernet_interface` will be used.

                           Subclass of AvdModel.
                        tunnel_interface:
                           Outgoing tunnel interface(s) to use for this connection.
                           If both `ethernet_interface` and
                           `tunnel_interface` are configured, `ethernet_interface` will be used.

                           Subclass of AvdModel.
                        monitor_connectivity_host:
                           Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
                           connection.
                        _custom_data: _custom_data

                    """

        class Connections(AvdIndexedList[str, ConnectionsItem]):
            """Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Connections._item_type = ConnectionsItem

        _fields: ClassVar[dict] = {"enabled": {"type": bool}, "connections": {"type": Connections}, "_custom_data": {"type": dict}}
        enabled: bool | None
        connections: Connections
        """Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | None | UndefinedType = Undefined,
                connections: Connections | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterServiceInsertion.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    connections: Subclass of AvdIndexedList with `ConnectionsItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class RouterTrafficEngineering(AvdModel):
        """Subclass of AvdModel."""

        class RouterId(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": str}, "ipv6": {"type": str}, "_custom_data": {"type": dict}}
            ipv4: str | None
            ipv6: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: str | None | UndefinedType = Undefined,
                    ipv6: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouterId.


                    Subclass of AvdModel.

                    Args:
                        ipv4: ipv4
                        ipv6: ipv6
                        _custom_data: _custom_data

                    """

        class SegmentRouting(AvdModel):
            """Subclass of AvdModel."""

            class PolicyEndpointsItem(AvdModel):
                """Subclass of AvdModel."""

                class ColorsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class PathGroupItem(AvdModel):
                        """Subclass of AvdModel."""

                        class SegmentListItem(AvdModel):
                            """Subclass of AvdModel."""

                            _fields: ClassVar[dict] = {
                                "label_stack": {"type": str},
                                "weight": {"type": int},
                                "index": {"type": int},
                                "_custom_data": {"type": dict},
                            }
                            label_stack: str | None
                            """
                            Label Stack as string.
                            Example: "100 2000 30"
                            """
                            weight: int | None
                            index: int | None
                            _custom_data: dict[str, Any]

                            if TYPE_CHECKING:

                                def __init__(
                                    self,
                                    *,
                                    label_stack: str | None | UndefinedType = Undefined,
                                    weight: int | None | UndefinedType = Undefined,
                                    index: int | None | UndefinedType = Undefined,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    SegmentListItem.


                                    Subclass of AvdModel.

                                    Args:
                                        label_stack:
                                           Label Stack as string.
                                           Example: "100 2000 30"
                                        weight: weight
                                        index: index
                                        _custom_data: _custom_data

                                    """

                        class SegmentList(AvdList[SegmentListItem]):
                            """Subclass of AvdList with `SegmentListItem` items."""

                        SegmentList._item_type = SegmentListItem

                        _fields: ClassVar[dict] = {
                            "preference": {"type": int},
                            "explicit_null": {"type": str},
                            "segment_list": {"type": SegmentList},
                            "_custom_data": {"type": dict},
                        }
                        preference: int | None
                        explicit_null: Literal["ipv4", "ipv6", "ipv4 ipv6", "none"] | None
                        segment_list: SegmentList
                        """Subclass of AvdList with `SegmentListItem` items."""
                        _custom_data: dict[str, Any]

                        if TYPE_CHECKING:

                            def __init__(
                                self,
                                *,
                                preference: int | None | UndefinedType = Undefined,
                                explicit_null: Literal["ipv4", "ipv6", "ipv4 ipv6", "none"] | None | UndefinedType = Undefined,
                                segment_list: SegmentList | UndefinedType = Undefined,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PathGroupItem.


                                Subclass of AvdModel.

                                Args:
                                    preference: preference
                                    explicit_null: explicit_null
                                    segment_list: Subclass of AvdList with `SegmentListItem` items.
                                    _custom_data: _custom_data

                                """

                    class PathGroup(AvdList[PathGroupItem]):
                        """Subclass of AvdList with `PathGroupItem` items."""

                    PathGroup._item_type = PathGroupItem

                    _fields: ClassVar[dict] = {
                        "value": {"type": int},
                        "binding_sid": {"type": int},
                        "description": {"type": str},
                        "name": {"type": str},
                        "sbfd_remote_discriminator": {"type": str},
                        "path_group": {"type": PathGroup},
                        "_custom_data": {"type": dict},
                    }
                    value: int
                    binding_sid: int | None
                    description: str | None
                    name: str | None
                    sbfd_remote_discriminator: str | None
                    """IPv4 address or 32 bit integer."""
                    path_group: PathGroup
                    """Subclass of AvdList with `PathGroupItem` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            value: int | UndefinedType = Undefined,
                            binding_sid: int | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            sbfd_remote_discriminator: str | None | UndefinedType = Undefined,
                            path_group: PathGroup | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ColorsItem.


                            Subclass of AvdModel.

                            Args:
                                value: value
                                binding_sid: binding_sid
                                description: description
                                name: name
                                sbfd_remote_discriminator: IPv4 address or 32 bit integer.
                                path_group: Subclass of AvdList with `PathGroupItem` items.
                                _custom_data: _custom_data

                            """

                class Colors(AvdIndexedList[int, ColorsItem]):
                    """Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`)."""

                    _primary_key: ClassVar[str] = "value"

                Colors._item_type = ColorsItem

                _fields: ClassVar[dict] = {"address": {"type": str}, "colors": {"type": Colors}, "_custom_data": {"type": dict}}
                address: str | None
                """IPv4 or IPv6 address."""
                colors: Colors
                """Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | None | UndefinedType = Undefined,
                        colors: Colors | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PolicyEndpointsItem.


                        Subclass of AvdModel.

                        Args:
                            address: IPv4 or IPv6 address.
                            colors: Subclass of AvdIndexedList with `ColorsItem` items. Primary key is `value` (`int`).
                            _custom_data: _custom_data

                        """

            class PolicyEndpoints(AvdList[PolicyEndpointsItem]):
                """Subclass of AvdList with `PolicyEndpointsItem` items."""

            PolicyEndpoints._item_type = PolicyEndpointsItem

            _fields: ClassVar[dict] = {"colored_tunnel_rib": {"type": bool}, "policy_endpoints": {"type": PolicyEndpoints}, "_custom_data": {"type": dict}}
            colored_tunnel_rib: bool | None
            policy_endpoints: PolicyEndpoints
            """Subclass of AvdList with `PolicyEndpointsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    colored_tunnel_rib: bool | None | UndefinedType = Undefined,
                    policy_endpoints: PolicyEndpoints | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SegmentRouting.


                    Subclass of AvdModel.

                    Args:
                        colored_tunnel_rib: colored_tunnel_rib
                        policy_endpoints: Subclass of AvdList with `PolicyEndpointsItem` items.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "enabled": {"type": bool},
            "router_id": {"type": RouterId},
            "segment_routing": {"type": SegmentRouting},
            "_custom_data": {"type": dict},
        }
        enabled: bool
        router_id: RouterId
        """Subclass of AvdModel."""
        segment_routing: SegmentRouting
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                enabled: bool | UndefinedType = Undefined,
                router_id: RouterId | UndefinedType = Undefined,
                segment_routing: SegmentRouting | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                RouterTrafficEngineering.


                Subclass of AvdModel.

                Args:
                    enabled: enabled
                    router_id: Subclass of AvdModel.
                    segment_routing: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class ServiceRoutingConfigurationBgp(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"no_equals_default": {"type": bool}, "_custom_data": {"type": dict}}
        no_equals_default: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, no_equals_default: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                ServiceRoutingConfigurationBgp.


                Subclass of AvdModel.

                Args:
                    no_equals_default: no_equals_default
                    _custom_data: _custom_data

                """

    class ServiceUnsupportedTransceiver(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"license_name": {"type": str}, "license_key": {"type": str}, "_custom_data": {"type": dict}}
        license_name: str | None
        license_key: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                license_name: str | None | UndefinedType = Undefined,
                license_key: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                ServiceUnsupportedTransceiver.


                Subclass of AvdModel.

                Args:
                    license_name: license_name
                    license_key: license_key
                    _custom_data: _custom_data

                """

    class Sflow(AvdModel):
        """Subclass of AvdModel."""

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            class DestinationsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"destination": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
                destination: str
                """Sflow Destination IP Address."""
                port: int | None
                """Port Number"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        destination: str | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DestinationsItem.


                        Subclass of AvdModel.

                        Args:
                            destination: Sflow Destination IP Address.
                            port: Port Number
                            _custom_data: _custom_data

                        """

            class Destinations(AvdIndexedList[str, DestinationsItem]):
                """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

                _primary_key: ClassVar[str] = "destination"

            Destinations._item_type = DestinationsItem

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "destinations": {"type": Destinations},
                "source": {"type": str},
                "source_interface": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            destinations: Destinations
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""
            source: str | None
            """
            Source IP Address.
            "source" and "source_interface" are mutually exclusive. If both are defined,
            "source_interface" takes precedence.
            """
            source_interface: str | None
            """Source Interface."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    destinations: Destinations | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: name
                        destinations: Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`).
                        source:
                           Source IP Address.
                           "source" and "source_interface" are mutually exclusive. If both are defined,
                           "source_interface" takes precedence.
                        source_interface: Source Interface.
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class DestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"destination": {"type": str}, "port": {"type": int}, "_custom_data": {"type": dict}}
            destination: str
            """Sflow Destination IP Address."""
            port: int | None
            """Port Number."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    destination: str | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    DestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        destination: Sflow Destination IP Address.
                        port: Port Number.
                        _custom_data: _custom_data

                    """

        class Destinations(AvdIndexedList[str, DestinationsItem]):
            """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""

            _primary_key: ClassVar[str] = "destination"

        Destinations._item_type = DestinationsItem

        class ExtensionsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool}, "_custom_data": {"type": dict}}
            name: str
            """Extension Name."""
            enabled: bool
            """Enable or Disable Extension."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ExtensionsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Extension Name.
                        enabled: Enable or Disable Extension.
                        _custom_data: _custom_data

                    """

        class Extensions(AvdIndexedList[str, ExtensionsItem]):
            """Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Extensions._item_type = ExtensionsItem

        class Interface(AvdModel):
            """Subclass of AvdModel."""

            class Disable(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"default": {"type": bool}, "_custom_data": {"type": dict}}
                default: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, default: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Disable.


                        Subclass of AvdModel.

                        Args:
                            default: default
                            _custom_data: _custom_data

                        """

            class Egress(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"enable_default": {"type": bool}, "unmodified": {"type": bool}, "_custom_data": {"type": dict}}
                enable_default: bool | None
                """Enable egress sFlow by default."""
                unmodified: bool | None
                """
                Enable egress sFlow unmodified.
                Platform dependent feature.
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enable_default: bool | None | UndefinedType = Undefined,
                        unmodified: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Egress.


                        Subclass of AvdModel.

                        Args:
                            enable_default: Enable egress sFlow by default.
                            unmodified:
                               Enable egress sFlow unmodified.
                               Platform dependent feature.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"disable": {"type": Disable}, "egress": {"type": Egress}, "_custom_data": {"type": dict}}
            disable: Disable
            """Subclass of AvdModel."""
            egress: Egress
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    disable: Disable | UndefinedType = Undefined,
                    egress: Egress | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Interface.


                    Subclass of AvdModel.

                    Args:
                        disable: Subclass of AvdModel.
                        egress: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class HardwareAcceleration(AvdModel):
            """Subclass of AvdModel."""

            class ModulesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool, "default": True}, "_custom_data": {"type": dict}}
                name: str
                enabled: bool
                """Default value: `True`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ModulesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            enabled: enabled
                            _custom_data: _custom_data

                        """

            class Modules(AvdIndexedList[str, ModulesItem]):
                """Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Modules._item_type = ModulesItem

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "sample": {"type": int}, "modules": {"type": Modules}, "_custom_data": {"type": dict}}
            enabled: bool | None
            sample: int | None
            modules: Modules
            """Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    modules: Modules | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HardwareAcceleration.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        sample: sample
                        modules: Subclass of AvdIndexedList with `ModulesItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "sample": {"type": int},
            "sample_input_subinterface": {"type": bool},
            "sample_output_subinterface": {"type": bool},
            "dangerous": {"type": bool},
            "polling_interval": {"type": int},
            "vrfs": {"type": Vrfs},
            "destinations": {"type": Destinations},
            "source": {"type": str},
            "source_interface": {"type": str},
            "extensions": {"type": Extensions},
            "interface": {"type": Interface},
            "run": {"type": bool},
            "hardware_acceleration": {"type": HardwareAcceleration},
            "_custom_data": {"type": dict},
        }
        sample: int | None
        sample_input_subinterface: bool | None
        sample_output_subinterface: bool | None
        dangerous: bool | None
        polling_interval: int | None
        """Polling interval in seconds."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        destinations: Destinations
        """Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`)."""
        source: str | None
        """
        Source IP Address.
        "source" and "source_interface" are mutually exclusive. If both are defined,
        "source_interface" takes precedence.
        """
        source_interface: str | None
        """Source Interface."""
        extensions: Extensions
        """Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`)."""
        interface: Interface
        """Subclass of AvdModel."""
        run: bool | None
        hardware_acceleration: HardwareAcceleration
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                sample: int | None | UndefinedType = Undefined,
                sample_input_subinterface: bool | None | UndefinedType = Undefined,
                sample_output_subinterface: bool | None | UndefinedType = Undefined,
                dangerous: bool | None | UndefinedType = Undefined,
                polling_interval: int | None | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                extensions: Extensions | UndefinedType = Undefined,
                interface: Interface | UndefinedType = Undefined,
                run: bool | None | UndefinedType = Undefined,
                hardware_acceleration: HardwareAcceleration | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Sflow.


                Subclass of AvdModel.

                Args:
                    sample: sample
                    sample_input_subinterface: sample_input_subinterface
                    sample_output_subinterface: sample_output_subinterface
                    dangerous: dangerous
                    polling_interval: Polling interval in seconds.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    destinations: Subclass of AvdIndexedList with `DestinationsItem` items. Primary key is `destination` (`str`).
                    source:
                       Source IP Address.
                       "source" and "source_interface" are mutually exclusive. If both are defined,
                       "source_interface" takes precedence.
                    source_interface: Source Interface.
                    extensions: Subclass of AvdIndexedList with `ExtensionsItem` items. Primary key is `name` (`str`).
                    interface: Subclass of AvdModel.
                    run: run
                    hardware_acceleration: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class SnmpServer(AvdModel):
        """Subclass of AvdModel."""

        class EngineIds(AvdModel):
            """Subclass of AvdModel."""

            class RemotesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"id": {"type": str}, "address": {"type": str}, "udp_port": {"type": int}, "_custom_data": {"type": dict}}
                id: str | None
                """Remote engine ID in hexadecimal."""
                address: str | None
                """Hostname or IP of remote engine."""
                udp_port: int | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        id: str | None | UndefinedType = Undefined,
                        address: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemotesItem.


                        Subclass of AvdModel.

                        Args:
                            id: Remote engine ID in hexadecimal.
                            address: Hostname or IP of remote engine.
                            udp_port: udp_port
                            _custom_data: _custom_data

                        """

            class Remotes(AvdList[RemotesItem]):
                """Subclass of AvdList with `RemotesItem` items."""

            Remotes._item_type = RemotesItem

            _fields: ClassVar[dict] = {"local": {"type": str}, "remotes": {"type": Remotes}, "_custom_data": {"type": dict}}
            local: str | None
            """Engine ID in hexadecimal."""
            remotes: Remotes
            """Subclass of AvdList with `RemotesItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local: str | None | UndefinedType = Undefined,
                    remotes: Remotes | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EngineIds.


                    Subclass of AvdModel.

                    Args:
                        local: Engine ID in hexadecimal.
                        remotes: Subclass of AvdList with `RemotesItem` items.
                        _custom_data: _custom_data

                    """

        class CommunitiesItem(AvdModel):
            """Subclass of AvdModel."""

            class AccessListIpv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                """IPv4 access list name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        AccessListIpv4.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 access list name.
                            _custom_data: _custom_data

                        """

            class AccessListIpv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str | None
                """IPv6 access list name."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        AccessListIpv6.


                        Subclass of AvdModel.

                        Args:
                            name: IPv6 access list name.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "access": {"type": str},
                "access_list_ipv4": {"type": AccessListIpv4},
                "access_list_ipv6": {"type": AccessListIpv6},
                "view": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str
            """Community name."""
            access: Literal["ro", "rw"] | None
            access_list_ipv4: AccessListIpv4
            """Subclass of AvdModel."""
            access_list_ipv6: AccessListIpv6
            """Subclass of AvdModel."""
            view: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    access: Literal["ro", "rw"] | None | UndefinedType = Undefined,
                    access_list_ipv4: AccessListIpv4 | UndefinedType = Undefined,
                    access_list_ipv6: AccessListIpv6 | UndefinedType = Undefined,
                    view: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    CommunitiesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Community name.
                        access: access
                        access_list_ipv4: Subclass of AvdModel.
                        access_list_ipv6: Subclass of AvdModel.
                        view: view
                        _custom_data: _custom_data

                    """

        class Communities(AvdIndexedList[str, CommunitiesItem]):
            """Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Communities._item_type = CommunitiesItem

        class Ipv4AclsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            """IPv4 access list name."""
            vrf: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4AclsItem.


                    Subclass of AvdModel.

                    Args:
                        name: IPv4 access list name.
                        vrf: vrf
                        _custom_data: _custom_data

                    """

        class Ipv4Acls(AvdList[Ipv4AclsItem]):
            """Subclass of AvdList with `Ipv4AclsItem` items."""

        Ipv4Acls._item_type = Ipv4AclsItem

        class Ipv6AclsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str | None
            """IPv6 access list name."""
            vrf: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6AclsItem.


                    Subclass of AvdModel.

                    Args:
                        name: IPv6 access list name.
                        vrf: vrf
                        _custom_data: _custom_data

                    """

        class Ipv6Acls(AvdList[Ipv6AclsItem]):
            """Subclass of AvdList with `Ipv6AclsItem` items."""

        Ipv6Acls._item_type = Ipv6AclsItem

        class LocalInterfacesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Interface name."""
            vrf: str | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalInterfacesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Interface name.
                        vrf: vrf
                        _custom_data: _custom_data

                    """

        class LocalInterfaces(AvdIndexedList[str, LocalInterfacesItem]):
            """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        LocalInterfaces._item_type = LocalInterfacesItem

        class ViewsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "mib_family_name": {"type": str}, "included": {"type": bool}, "_custom_data": {"type": dict}}
            name: str | None
            """SNMP view name."""
            mib_family_name: str | None
            included: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    mib_family_name: str | None | UndefinedType = Undefined,
                    included: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ViewsItem.


                    Subclass of AvdModel.

                    Args:
                        name: SNMP view name.
                        mib_family_name: mib_family_name
                        included: included
                        _custom_data: _custom_data

                    """

        class Views(AvdList[ViewsItem]):
            """Subclass of AvdList with `ViewsItem` items."""

        Views._item_type = ViewsItem

        class GroupsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "version": {"type": str},
                "authentication": {"type": str},
                "read": {"type": str},
                "write": {"type": str},
                "notify": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str | None
            """Group name."""
            version: Literal["v1", "v2c", "v3"] | None
            authentication: Literal["auth", "noauth", "priv"] | None
            read: str | None
            """Read view."""
            write: str | None
            """Write view."""
            notify: str | None
            """Notify view."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    version: Literal["v1", "v2c", "v3"] | None | UndefinedType = Undefined,
                    authentication: Literal["auth", "noauth", "priv"] | None | UndefinedType = Undefined,
                    read: str | None | UndefinedType = Undefined,
                    write: str | None | UndefinedType = Undefined,
                    notify: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupsItem.


                    Subclass of AvdModel.

                    Args:
                        name: Group name.
                        version: version
                        authentication: authentication
                        read: Read view.
                        write: Write view.
                        notify: Notify view.
                        _custom_data: _custom_data

                    """

        class Groups(AvdList[GroupsItem]):
            """Subclass of AvdList with `GroupsItem` items."""

        Groups._item_type = GroupsItem

        class UsersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "group": {"type": str},
                "remote_address": {"type": str},
                "udp_port": {"type": int},
                "version": {"type": str},
                "localized": {"type": str},
                "auth": {"type": str},
                "auth_passphrase": {"type": str},
                "priv": {"type": str},
                "priv_passphrase": {"type": str},
                "_custom_data": {"type": dict},
            }
            name: str | None
            """Username."""
            group: str | None
            """Group name."""
            remote_address: str | None
            """
            Hostname or ip of remote engine.
            The remote_address and udp_port are used for remote users.
            """
            udp_port: int | None
            """udp_port will not be used if no remote_address is configured."""
            version: Literal["v1", "v2c", "v3"] | None
            localized: str | None
            """Engine ID in hexadecimal for localizing auth and/or priv."""
            auth: str | None
            """Hash algorithm."""
            auth_passphrase: str | None
            """Hashed authentication passphrase if localized is used else cleartext authentication passphrase."""
            priv: str | None
            """Encryption algorithm."""
            priv_passphrase: str | None
            """Hashed privacy passphrase if localized is used else cleartext privacy passphrase."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    remote_address: str | None | UndefinedType = Undefined,
                    udp_port: int | None | UndefinedType = Undefined,
                    version: Literal["v1", "v2c", "v3"] | None | UndefinedType = Undefined,
                    localized: str | None | UndefinedType = Undefined,
                    auth: str | None | UndefinedType = Undefined,
                    auth_passphrase: str | None | UndefinedType = Undefined,
                    priv: str | None | UndefinedType = Undefined,
                    priv_passphrase: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    UsersItem.


                    Subclass of AvdModel.

                    Args:
                        name: Username.
                        group: Group name.
                        remote_address:
                           Hostname or ip of remote engine.
                           The remote_address and udp_port are used for remote users.
                        udp_port: udp_port will not be used if no remote_address is configured.
                        version: version
                        localized: Engine ID in hexadecimal for localizing auth and/or priv.
                        auth: Hash algorithm.
                        auth_passphrase: Hashed authentication passphrase if localized is used else cleartext authentication passphrase.
                        priv: Encryption algorithm.
                        priv_passphrase: Hashed privacy passphrase if localized is used else cleartext privacy passphrase.
                        _custom_data: _custom_data

                    """

        class Users(AvdList[UsersItem]):
            """Subclass of AvdList with `UsersItem` items."""

        Users._item_type = UsersItem

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            class UsersItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"username": {"type": str}, "authentication_level": {"type": str}, "_custom_data": {"type": dict}}
                username: str | None
                authentication_level: Literal["auth", "noauth", "priv"] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        username: str | None | UndefinedType = Undefined,
                        authentication_level: Literal["auth", "noauth", "priv"] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        UsersItem.


                        Subclass of AvdModel.

                        Args:
                            username: username
                            authentication_level: authentication_level
                            _custom_data: _custom_data

                        """

            class Users(AvdList[UsersItem]):
                """Subclass of AvdList with `UsersItem` items."""

            Users._item_type = UsersItem

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "version": {"type": str},
                "community": {"type": str},
                "users": {"type": Users},
                "_custom_data": {"type": dict},
            }
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            version: Literal["1", "2c", "3"] | None
            community: str | None
            """Community name. Required with version "1" or "2c"."""
            users: Users
            """Subclass of AvdList with `UsersItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    version: Literal["1", "2c", "3"] | None | UndefinedType = Undefined,
                    community: str | None | UndefinedType = Undefined,
                    users: Users | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        version: version
                        community: Community name. Required with version "1" or "2c".
                        users: Subclass of AvdList with `UsersItem` items.
                        _custom_data: _custom_data

                    """

        class Hosts(AvdList[HostsItem]):
            """Subclass of AvdList with `HostsItem` items."""

        Hosts._item_type = HostsItem

        class Traps(AvdModel):
            """Subclass of AvdModel."""

            class SnmpTrapsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "enabled": {"type": bool, "default": True}, "_custom_data": {"type": dict}}
                name: str | None
                """
                Enable or disable specific snmp-traps and their sub_traps.
                Examples:
                - "bgp"
                - "bgp established"
                """
                enabled: bool
                """Default value: `True`"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SnmpTrapsItem.


                        Subclass of AvdModel.

                        Args:
                            name:
                               Enable or disable specific snmp-traps and their sub_traps.
                               Examples:  # fmt: skip
                               - "bgp"
                               - "bgp established"
                            enabled: enabled
                            _custom_data: _custom_data

                        """

            class SnmpTraps(AvdList[SnmpTrapsItem]):
                """Subclass of AvdList with `SnmpTrapsItem` items."""

            SnmpTraps._item_type = SnmpTrapsItem

            _fields: ClassVar[dict] = {"enable": {"type": bool, "default": False}, "snmp_traps": {"type": SnmpTraps}, "_custom_data": {"type": dict}}
            enable: bool
            """
            Enable or disable all snmp-traps.

            Default value: `False`
            """
            snmp_traps: SnmpTraps
            """Subclass of AvdList with `SnmpTrapsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enable: bool | UndefinedType = Undefined,
                    snmp_traps: SnmpTraps | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Traps.


                    Subclass of AvdModel.

                    Args:
                        enable: Enable or disable all snmp-traps.
                        snmp_traps: Subclass of AvdList with `SnmpTrapsItem` items.
                        _custom_data: _custom_data

                    """

        class VrfsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "enable": {"type": bool}, "_custom_data": {"type": dict}}
            name: str
            """VRF name."""
            enable: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    enable: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.


                    Subclass of AvdModel.

                    Args:
                        name: VRF name.
                        enable: enable
                        _custom_data: _custom_data

                    """

        class Vrfs(AvdIndexedList[str, VrfsItem]):
            """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "engine_ids": {"type": EngineIds},
            "contact": {"type": str},
            "location": {"type": str},
            "communities": {"type": Communities},
            "ipv4_acls": {"type": Ipv4Acls},
            "ipv6_acls": {"type": Ipv6Acls},
            "local_interfaces": {"type": LocalInterfaces},
            "views": {"type": Views},
            "groups": {"type": Groups},
            "users": {"type": Users},
            "hosts": {"type": Hosts},
            "traps": {"type": Traps},
            "vrfs": {"type": Vrfs},
            "ifmib_ifspeed_shape_rate": {"type": bool},
            "_custom_data": {"type": dict},
        }
        engine_ids: EngineIds
        """Subclass of AvdModel."""
        contact: str | None
        """SNMP contact."""
        location: str | None
        """SNMP location."""
        communities: Communities
        """Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`)."""
        ipv4_acls: Ipv4Acls
        """Subclass of AvdList with `Ipv4AclsItem` items."""
        ipv6_acls: Ipv6Acls
        """Subclass of AvdList with `Ipv6AclsItem` items."""
        local_interfaces: LocalInterfaces
        """Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`)."""
        views: Views
        """Subclass of AvdList with `ViewsItem` items."""
        groups: Groups
        """Subclass of AvdList with `GroupsItem` items."""
        users: Users
        """Subclass of AvdList with `UsersItem` items."""
        hosts: Hosts
        """Subclass of AvdList with `HostsItem` items."""
        traps: Traps
        """Subclass of AvdModel."""
        vrfs: Vrfs
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
        ifmib_ifspeed_shape_rate: bool | None
        """SNMP ifspeed reflecting shaping rate."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                engine_ids: EngineIds | UndefinedType = Undefined,
                contact: str | None | UndefinedType = Undefined,
                location: str | None | UndefinedType = Undefined,
                communities: Communities | UndefinedType = Undefined,
                ipv4_acls: Ipv4Acls | UndefinedType = Undefined,
                ipv6_acls: Ipv6Acls | UndefinedType = Undefined,
                local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                views: Views | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
                users: Users | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                traps: Traps | UndefinedType = Undefined,
                vrfs: Vrfs | UndefinedType = Undefined,
                ifmib_ifspeed_shape_rate: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                SnmpServer.


                Subclass of AvdModel.

                Args:
                    engine_ids: Subclass of AvdModel.
                    contact: SNMP contact.
                    location: SNMP location.
                    communities: Subclass of AvdIndexedList with `CommunitiesItem` items. Primary key is `name` (`str`).
                    ipv4_acls: Subclass of AvdList with `Ipv4AclsItem` items.
                    ipv6_acls: Subclass of AvdList with `Ipv6AclsItem` items.
                    local_interfaces: Subclass of AvdIndexedList with `LocalInterfacesItem` items. Primary key is `name` (`str`).
                    views: Subclass of AvdList with `ViewsItem` items.
                    groups: Subclass of AvdList with `GroupsItem` items.
                    users: Subclass of AvdList with `UsersItem` items.
                    hosts: Subclass of AvdList with `HostsItem` items.
                    traps: Subclass of AvdModel.
                    vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                    ifmib_ifspeed_shape_rate: SNMP ifspeed reflecting shaping rate.
                    _custom_data: _custom_data

                """

    class SpanningTree(AvdModel):
        """Subclass of AvdModel."""

        class EdgePort(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"bpdufilter_default": {"type": bool}, "bpduguard_default": {"type": bool}, "_custom_data": {"type": dict}}
            bpdufilter_default: bool | None
            bpduguard_default: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    bpdufilter_default: bool | None | UndefinedType = Undefined,
                    bpduguard_default: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    EdgePort.


                    Subclass of AvdModel.

                    Args:
                        bpdufilter_default: bpdufilter_default
                        bpduguard_default: bpduguard_default
                        _custom_data: _custom_data

                    """

        class BpduguardRateLimit(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"default": {"type": bool}, "count": {"type": int}, "_custom_data": {"type": dict}}
            default: bool | None
            count: int | None
            """Maximum number of BPDUs per timer interval."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    default: bool | None | UndefinedType = Undefined,
                    count: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    BpduguardRateLimit.


                    Subclass of AvdModel.

                    Args:
                        default: default
                        count: Maximum number of BPDUs per timer interval.
                        _custom_data: _custom_data

                    """

        class Mst(AvdModel):
            """Subclass of AvdModel."""

            class Configuration(AvdModel):
                """Subclass of AvdModel."""

                class InstancesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"id": {"type": int}, "vlans": {"type": str}, "_custom_data": {"type": dict}}
                    id: int
                    """Instance ID."""
                    vlans: str | None
                    """
                    "< vlan_id >, < vlan_id >-< vlan_id >"
                    Example: 15,16,17,18
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            vlans: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            InstancesItem.


                            Subclass of AvdModel.

                            Args:
                                id: Instance ID.
                                vlans:
                                   "< vlan_id >, < vlan_id >-< vlan_id >"
                                   Example: 15,16,17,18
                                _custom_data: _custom_data

                            """

                class Instances(AvdIndexedList[int, InstancesItem]):
                    """Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Instances._item_type = InstancesItem

                _fields: ClassVar[dict] = {"name": {"type": str}, "revision": {"type": int}, "instances": {"type": Instances}, "_custom_data": {"type": dict}}
                name: str | None
                revision: int | None
                """0-65535."""
                instances: Instances
                """Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | None | UndefinedType = Undefined,
                        revision: int | None | UndefinedType = Undefined,
                        instances: Instances | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Configuration.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            revision: 0-65535.
                            instances: Subclass of AvdIndexedList with `InstancesItem` items. Primary key is `id` (`int`).
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"pvst_border": {"type": bool}, "configuration": {"type": Configuration}, "_custom_data": {"type": dict}}
            pvst_border: bool | None
            configuration: Configuration
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    pvst_border: bool | None | UndefinedType = Undefined,
                    configuration: Configuration | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mst.


                    Subclass of AvdModel.

                    Args:
                        pvst_border: pvst_border
                        configuration: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class MstInstancesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": str}, "priority": {"type": int}, "_custom_data": {"type": dict}}
            id: str
            """Instance ID."""
            priority: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: str | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MstInstancesItem.


                    Subclass of AvdModel.

                    Args:
                        id: Instance ID.
                        priority: priority
                        _custom_data: _custom_data

                    """

        class MstInstances(AvdIndexedList[str, MstInstancesItem]):
            """Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`)."""

            _primary_key: ClassVar[str] = "id"

        MstInstances._item_type = MstInstancesItem

        class RapidPvstInstancesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": str}, "priority": {"type": int}, "_custom_data": {"type": dict}}
            id: str
            """
            "< vlan_id >, < vlan_id >-< vlan_id >"
            Example: 105,202,505-506
            """
            priority: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: str | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RapidPvstInstancesItem.


                    Subclass of AvdModel.

                    Args:
                        id:
                           "< vlan_id >, < vlan_id >-< vlan_id >"
                           Example: 105,202,505-506
                        priority: priority
                        _custom_data: _custom_data

                    """

        class RapidPvstInstances(AvdIndexedList[str, RapidPvstInstancesItem]):
            """Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`)."""

            _primary_key: ClassVar[str] = "id"

        RapidPvstInstances._item_type = RapidPvstInstancesItem

        _fields: ClassVar[dict] = {
            "root_super": {"type": bool},
            "edge_port": {"type": EdgePort},
            "mode": {"type": str},
            "bpduguard_rate_limit": {"type": BpduguardRateLimit},
            "rstp_priority": {"type": int},
            "mst": {"type": Mst},
            "mst_instances": {"type": MstInstances},
            "no_spanning_tree_vlan": {"type": str},
            "rapid_pvst_instances": {"type": RapidPvstInstances},
            "_custom_data": {"type": dict},
        }
        root_super: bool | None
        edge_port: EdgePort
        """Subclass of AvdModel."""
        mode: Literal["mstp", "rstp", "rapid-pvst", "none"] | None
        bpduguard_rate_limit: BpduguardRateLimit
        """Subclass of AvdModel."""
        rstp_priority: int | None
        mst: Mst
        """Subclass of AvdModel."""
        mst_instances: MstInstances
        """Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`)."""
        no_spanning_tree_vlan: str | None
        """
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 105,202,505-506
        """
        rapid_pvst_instances: RapidPvstInstances
        """Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                root_super: bool | None | UndefinedType = Undefined,
                edge_port: EdgePort | UndefinedType = Undefined,
                mode: Literal["mstp", "rstp", "rapid-pvst", "none"] | None | UndefinedType = Undefined,
                bpduguard_rate_limit: BpduguardRateLimit | UndefinedType = Undefined,
                rstp_priority: int | None | UndefinedType = Undefined,
                mst: Mst | UndefinedType = Undefined,
                mst_instances: MstInstances | UndefinedType = Undefined,
                no_spanning_tree_vlan: str | None | UndefinedType = Undefined,
                rapid_pvst_instances: RapidPvstInstances | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                SpanningTree.


                Subclass of AvdModel.

                Args:
                    root_super: root_super
                    edge_port: Subclass of AvdModel.
                    mode: mode
                    bpduguard_rate_limit: Subclass of AvdModel.
                    rstp_priority: rstp_priority
                    mst: Subclass of AvdModel.
                    mst_instances: Subclass of AvdIndexedList with `MstInstancesItem` items. Primary key is `id` (`str`).
                    no_spanning_tree_vlan:
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 105,202,505-506
                    rapid_pvst_instances: Subclass of AvdIndexedList with `RapidPvstInstancesItem` items. Primary key is `id` (`str`).
                    _custom_data: _custom_data

                """

    class StandardAccessListsItem(AvdModel):
        """Subclass of AvdModel."""

        class SequenceNumbersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"sequence": {"type": int}, "action": {"type": str}, "_custom_data": {"type": dict}}
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    sequence: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.


                    Subclass of AvdModel.

                    Args:
                        sequence: Sequence ID.
                        action:
                           Action as string.
                           Example: "deny ip any any"
                        _custom_data: _custom_data

                    """

        class SequenceNumbers(AvdIndexedList[int, SequenceNumbersItem]):
            """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""

            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
            "_custom_data": {"type": dict},
        }
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers
        """Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                counters_per_entry: bool | None | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                StandardAccessListsItem.


                Subclass of AvdModel.

                Args:
                    name: Access-list Name.
                    counters_per_entry: counters_per_entry
                    sequence_numbers: Subclass of AvdIndexedList with `SequenceNumbersItem` items. Primary key is `sequence` (`int`).
                    _custom_data: _custom_data

                """

    class StandardAccessLists(AvdIndexedList[str, StandardAccessListsItem]):
        """Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    StandardAccessLists._item_type = StandardAccessListsItem

    class StaticRoutesItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
            "_custom_data": {"type": dict},
        }
        vrf: str | None
        """VRF Name."""
        destination_address_prefix: str | None
        """IPv4_network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv4 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vrf: str | None | UndefinedType = Undefined,
                destination_address_prefix: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                gateway: str | None | UndefinedType = Undefined,
                track_bfd: bool | None | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
                tag: int | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                metric: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                StaticRoutesItem.


                Subclass of AvdModel.

                Args:
                    vrf: VRF Name.
                    destination_address_prefix: IPv4_network/Mask.
                    interface: interface
                    gateway: IPv4 Address.
                    track_bfd: Track next-hop using BFD.
                    distance: distance
                    tag: tag
                    name: Description.
                    metric: metric
                    _custom_data: _custom_data

                """

    class StaticRoutes(AvdList[StaticRoutesItem]):
        """Subclass of AvdList with `StaticRoutesItem` items."""

    StaticRoutes._item_type = StaticRoutesItem

    class Stun(AvdModel):
        """Subclass of AvdModel."""

        class Client(AvdModel):
            """Subclass of AvdModel."""

            class ServerProfilesItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "ip_address": {"type": str},
                    "ssl_profile": {"type": str},
                    "port": {"type": int},
                    "_custom_data": {"type": dict},
                }
                name: str
                ip_address: str | None
                ssl_profile: str | None
                """SSL profile name."""
                port: int | None
                """Destination port for the request STUN server (default - 3478)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        ip_address: str | None | UndefinedType = Undefined,
                        ssl_profile: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ServerProfilesItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            ip_address: ip_address
                            ssl_profile: SSL profile name.
                            port: Destination port for the request STUN server (default - 3478).
                            _custom_data: _custom_data

                        """

            class ServerProfiles(AvdIndexedList[str, ServerProfilesItem]):
                """Subclass of AvdIndexedList with `ServerProfilesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            ServerProfiles._item_type = ServerProfilesItem

            _fields: ClassVar[dict] = {"server_profiles": {"type": ServerProfiles}, "_custom_data": {"type": dict}}
            server_profiles: ServerProfiles
            """
            List of server profiles for the client.

            Subclass of AvdIndexedList with `ServerProfilesItem` items.
            Primary key is `name` (`str`).
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, server_profiles: ServerProfiles | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Client.


                    Subclass of AvdModel.

                    Args:
                        server_profiles:
                           List of server profiles for the client.

                           Subclass of AvdIndexedList with `ServerProfilesItem` items.
                           Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class Server(AvdModel):
            """Subclass of AvdModel."""

            class LocalInterfaces(AvdList[str]):
                """Subclass of AvdList with `str` items."""

            LocalInterfaces._item_type = str

            class SslConnectionLifetime(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"minutes": {"type": int}, "hours": {"type": int}, "_custom_data": {"type": dict}}
                minutes: int | None
                """SSL connection lifetime in minutes (default - 120)."""
                hours: int | None
                """SSL connection lifetime in hours (default - 2)."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        minutes: int | None | UndefinedType = Undefined,
                        hours: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SslConnectionLifetime.


                        Subclass of AvdModel.

                        Args:
                            minutes: SSL connection lifetime in minutes (default - 120).
                            hours: SSL connection lifetime in hours (default - 2).
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "local_interfaces": {"type": LocalInterfaces},
                "bindings_timeout": {"type": int},
                "ssl_profile": {"type": str},
                "ssl_connection_lifetime": {"type": SslConnectionLifetime},
                "port": {"type": int},
                "_custom_data": {"type": dict},
            }
            local_interfaces: LocalInterfaces
            """Subclass of AvdList with `str` items."""
            bindings_timeout: int | None
            """Timeout for bindings stored on STUN server in seconds."""
            ssl_profile: str | None
            """SSL profile name."""
            ssl_connection_lifetime: SslConnectionLifetime
            """
            SSL connection lifetime in minutes or hours.
            If both are specified, minutes is given higher
            precedence.

            Subclass of AvdModel.
            """
            port: int | None
            """Listening port for STUN server (default - 3478)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                    bindings_timeout: int | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    ssl_connection_lifetime: SslConnectionLifetime | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Server.


                    Subclass of AvdModel.

                    Args:
                        local_interfaces: Subclass of AvdList with `str` items.
                        bindings_timeout: Timeout for bindings stored on STUN server in seconds.
                        ssl_profile: SSL profile name.
                        ssl_connection_lifetime:
                           SSL connection lifetime in minutes or hours.
                           If both are specified, minutes is given higher
                           precedence.

                           Subclass of AvdModel.
                        port: Listening port for STUN server (default - 3478).
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"client": {"type": Client}, "server": {"type": Server}, "_custom_data": {"type": dict}}
        client: Client
        """
        STUN client settings.

        Subclass of AvdModel.
        """
        server: Server
        """
        STUN server settings.

        Subclass of AvdModel.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                client: Client | UndefinedType = Undefined,
                server: Server | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Stun.


                Subclass of AvdModel.

                Args:
                    client:
                       STUN client settings.

                       Subclass of AvdModel.
                    server:
                       STUN server settings.

                       Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class SwitchportDefault(AvdModel):
        """Subclass of AvdModel."""

        class Phone(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"cos": {"type": int}, "trunk": {"type": str}, "vlan": {"type": int}, "_custom_data": {"type": dict}}
            cos: int | None
            trunk: Literal["tagged", "untagged"] | None
            vlan: int | None
            """VLAN ID."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    cos: int | None | UndefinedType = Undefined,
                    trunk: Literal["tagged", "untagged"] | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.


                    Subclass of AvdModel.

                    Args:
                        cos: cos
                        trunk: trunk
                        vlan: VLAN ID.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"mode": {"type": str}, "phone": {"type": Phone}, "_custom_data": {"type": dict}}
        mode: Literal["routed", "access"] | None
        phone: Phone
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mode: Literal["routed", "access"] | None | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                SwitchportDefault.


                Subclass of AvdModel.

                Args:
                    mode: mode
                    phone: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class SwitchportPortSecurity(AvdModel):
        """Subclass of AvdModel."""

        class MacAddress(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"aging": {"type": bool}, "moveable": {"type": bool}, "_custom_data": {"type": dict}}
            aging: bool | None
            moveable: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    aging: bool | None | UndefinedType = Undefined,
                    moveable: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    MacAddress.


                    Subclass of AvdModel.

                    Args:
                        aging: aging
                        moveable: moveable
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "mac_address": {"type": MacAddress},
            "persistence_disabled": {"type": bool},
            "violation_protect_chip_based": {"type": bool},
            "_custom_data": {"type": dict},
        }
        mac_address: MacAddress
        """Subclass of AvdModel."""
        persistence_disabled: bool | None
        violation_protect_chip_based: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mac_address: MacAddress | UndefinedType = Undefined,
                persistence_disabled: bool | None | UndefinedType = Undefined,
                violation_protect_chip_based: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                SwitchportPortSecurity.


                Subclass of AvdModel.

                Args:
                    mac_address: Subclass of AvdModel.
                    persistence_disabled: persistence_disabled
                    violation_protect_chip_based: violation_protect_chip_based
                    _custom_data: _custom_data

                """

    class SyncE(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"network_option": {"type": int}, "_custom_data": {"type": dict}}
        network_option: int
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(self, *, network_option: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                """
                SyncE.


                Subclass of AvdModel.

                Args:
                    network_option: network_option
                    _custom_data: _custom_data

                """

    class System(AvdModel):
        """Subclass of AvdModel."""

        class ControlPlane(AvdModel):
            """Subclass of AvdModel."""

            class TcpMss(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}, "_custom_data": {"type": dict}}
                ipv4: int | None
                """Segment size."""
                ipv6: int | None
                """Segment size."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: int | None | UndefinedType = Undefined,
                        ipv6: int | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TcpMss.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Segment size.
                            ipv6: Segment size.
                            _custom_data: _custom_data

                        """

            class Ipv4AccessGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"acl_name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
                acl_name: str
                vrf: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        acl_name: str | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4AccessGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            acl_name: acl_name
                            vrf: vrf
                            _custom_data: _custom_data

                        """

            class Ipv4AccessGroups(AvdList[Ipv4AccessGroupsItem]):
                """Subclass of AvdList with `Ipv4AccessGroupsItem` items."""

            Ipv4AccessGroups._item_type = Ipv4AccessGroupsItem

            class Ipv6AccessGroupsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"acl_name": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
                acl_name: str
                vrf: str | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        acl_name: str | UndefinedType = Undefined,
                        vrf: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6AccessGroupsItem.


                        Subclass of AvdModel.

                        Args:
                            acl_name: acl_name
                            vrf: vrf
                            _custom_data: _custom_data

                        """

            class Ipv6AccessGroups(AvdList[Ipv6AccessGroupsItem]):
                """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""

            Ipv6AccessGroups._item_type = Ipv6AccessGroupsItem

            _fields: ClassVar[dict] = {
                "tcp_mss": {"type": TcpMss},
                "ipv4_access_group_ingress_default": {"type": str},
                "ipv4_access_groups": {"type": Ipv4AccessGroups},
                "ipv6_access_group_ingress_default": {"type": str},
                "ipv6_access_groups": {"type": Ipv6AccessGroups},
                "_custom_data": {"type": dict},
            }
            tcp_mss: TcpMss
            """Subclass of AvdModel."""
            ipv4_access_group_ingress_default: str | None
            """ACL name to be used as the default CP ACL for all VRFs."""
            ipv4_access_groups: Ipv4AccessGroups
            """Subclass of AvdList with `Ipv4AccessGroupsItem` items."""
            ipv6_access_group_ingress_default: str | None
            """ACL name to be used as the default CP ACL for all VRFs."""
            ipv6_access_groups: Ipv6AccessGroups
            """Subclass of AvdList with `Ipv6AccessGroupsItem` items."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    tcp_mss: TcpMss | UndefinedType = Undefined,
                    ipv4_access_group_ingress_default: str | None | UndefinedType = Undefined,
                    ipv4_access_groups: Ipv4AccessGroups | UndefinedType = Undefined,
                    ipv6_access_group_ingress_default: str | None | UndefinedType = Undefined,
                    ipv6_access_groups: Ipv6AccessGroups | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ControlPlane.


                    Subclass of AvdModel.

                    Args:
                        tcp_mss: Subclass of AvdModel.
                        ipv4_access_group_ingress_default: ACL name to be used as the default CP ACL for all VRFs.
                        ipv4_access_groups: Subclass of AvdList with `Ipv4AccessGroupsItem` items.
                        ipv6_access_group_ingress_default: ACL name to be used as the default CP ACL for all VRFs.
                        ipv6_access_groups: Subclass of AvdList with `Ipv6AccessGroupsItem` items.
                        _custom_data: _custom_data

                    """

        class L1(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "unsupported_speed_action": {"type": str},
                "unsupported_error_correction_action": {"type": str},
                "_custom_data": {"type": dict},
            }
            unsupported_speed_action: Literal["error", "warn"] | None
            unsupported_error_correction_action: Literal["error", "warn"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    unsupported_speed_action: Literal["error", "warn"] | None | UndefinedType = Undefined,
                    unsupported_error_correction_action: Literal["error", "warn"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    L1.


                    Subclass of AvdModel.

                    Args:
                        unsupported_speed_action: unsupported_speed_action
                        unsupported_error_correction_action: unsupported_error_correction_action
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"control_plane": {"type": ControlPlane}, "l1": {"type": L1}, "_custom_data": {"type": dict}}
        control_plane: ControlPlane
        """Subclass of AvdModel."""
        l1: L1
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                control_plane: ControlPlane | UndefinedType = Undefined,
                l1: L1 | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                System.


                Subclass of AvdModel.

                Args:
                    control_plane: Subclass of AvdModel.
                    l1: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class TacacsServers(AvdModel):
        """Subclass of AvdModel."""

        class HostsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "host": {"type": str},
                "vrf": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str, "default": "7"},
                "single_connection": {"type": bool},
                "timeout": {"type": int},
                "_custom_data": {"type": dict},
            }
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            key: str | None
            """Encrypted key."""
            key_type: Literal["0", "7", "8a"]
            """Default value: `"7"`"""
            single_connection: bool | None
            timeout: int | None
            """Timeout in seconds."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    host: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                    single_connection: bool | None | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.


                    Subclass of AvdModel.

                    Args:
                        host: Host IP address or name.
                        vrf: vrf
                        key: Encrypted key.
                        key_type: key_type
                        single_connection: single_connection
                        timeout: Timeout in seconds.
                        _custom_data: _custom_data

                    """

        class Hosts(AvdList[HostsItem]):
            """Subclass of AvdList with `HostsItem` items."""

        Hosts._item_type = HostsItem

        _fields: ClassVar[dict] = {
            "timeout": {"type": int},
            "hosts": {"type": Hosts},
            "policy_unknown_mandatory_attribute_ignore": {"type": bool},
            "_custom_data": {"type": dict},
        }
        timeout: int | None
        """Timeout in seconds."""
        hosts: Hosts
        """Subclass of AvdList with `HostsItem` items."""
        policy_unknown_mandatory_attribute_ignore: bool | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                timeout: int | None | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
                policy_unknown_mandatory_attribute_ignore: bool | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TacacsServers.


                Subclass of AvdModel.

                Args:
                    timeout: Timeout in seconds.
                    hosts: Subclass of AvdList with `HostsItem` items.
                    policy_unknown_mandatory_attribute_ignore: policy_unknown_mandatory_attribute_ignore
                    _custom_data: _custom_data

                """

    class TapAggregation(AvdModel):
        """Subclass of AvdModel."""

        class Mode(AvdModel):
            """Subclass of AvdModel."""

            class Exclusive(AvdModel):
                """Subclass of AvdModel."""

                class NoErrdisable(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                NoErrdisable._item_type = str

                _fields: ClassVar[dict] = {
                    "enabled": {"type": bool},
                    "profile": {"type": str},
                    "no_errdisable": {"type": NoErrdisable},
                    "_custom_data": {"type": dict},
                }
                enabled: bool | None
                profile: str | None
                """Profile Name."""
                no_errdisable: NoErrdisable
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | None | UndefinedType = Undefined,
                        profile: str | None | UndefinedType = Undefined,
                        no_errdisable: NoErrdisable | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Exclusive.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            profile: Profile Name.
                            no_errdisable: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"exclusive": {"type": Exclusive}, "_custom_data": {"type": dict}}
            exclusive: Exclusive
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, exclusive: Exclusive | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Mode.


                    Subclass of AvdModel.

                    Args:
                        exclusive: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Mac(AvdModel):
            """Subclass of AvdModel."""

            class Timestamp(AvdModel):
                """Subclass of AvdModel."""

                class Header(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"format": {"type": str}, "eth_type": {"type": int}, "_custom_data": {"type": dict}}
                    format: Literal["48-bit", "64-bit"] | None
                    eth_type: int | None
                    """EtherType."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            format: Literal["48-bit", "64-bit"] | None | UndefinedType = Undefined,
                            eth_type: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Header.


                            Subclass of AvdModel.

                            Args:
                                format: format
                                eth_type: EtherType.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"replace_source_mac": {"type": bool}, "header": {"type": Header}, "_custom_data": {"type": dict}}
                replace_source_mac: bool | None
                header: Header
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        replace_source_mac: bool | None | UndefinedType = Undefined,
                        header: Header | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Timestamp.


                        Subclass of AvdModel.

                        Args:
                            replace_source_mac: replace_source_mac
                            header: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "timestamp": {"type": Timestamp},
                "fcs_append": {"type": bool},
                "fcs_error": {"type": str},
                "_custom_data": {"type": dict},
            }
            timestamp: Timestamp
            """
            mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
            defined, replace_source_mac takes precedence.


            Subclass of AvdModel.
            """
            fcs_append: bool | None
            """
            mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
            precedence.
            """
            fcs_error: Literal["correct", "discard", "pass-through"] | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    timestamp: Timestamp | UndefinedType = Undefined,
                    fcs_append: bool | None | UndefinedType = Undefined,
                    fcs_error: Literal["correct", "discard", "pass-through"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mac.


                    Subclass of AvdModel.

                    Args:
                        timestamp:
                           mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
                           defined, replace_source_mac takes precedence.


                           Subclass of AvdModel.
                        fcs_append:
                           mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
                           precedence.
                        fcs_error: fcs_error
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "mode": {"type": Mode},
            "encapsulation_dot1br_strip": {"type": bool},
            "encapsulation_vn_tag_strip": {"type": bool},
            "protocol_lldp_trap": {"type": bool},
            "truncation_size": {"type": int},
            "mac": {"type": Mac},
            "_custom_data": {"type": dict},
        }
        mode: Mode
        """Subclass of AvdModel."""
        encapsulation_dot1br_strip: bool | None
        encapsulation_vn_tag_strip: bool | None
        protocol_lldp_trap: bool | None
        truncation_size: int | None
        """Allowed truncation_size values vary depending on the platform."""
        mac: Mac
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                mode: Mode | UndefinedType = Undefined,
                encapsulation_dot1br_strip: bool | None | UndefinedType = Undefined,
                encapsulation_vn_tag_strip: bool | None | UndefinedType = Undefined,
                protocol_lldp_trap: bool | None | UndefinedType = Undefined,
                truncation_size: int | None | UndefinedType = Undefined,
                mac: Mac | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TapAggregation.


                Subclass of AvdModel.

                Args:
                    mode: Subclass of AvdModel.
                    encapsulation_dot1br_strip: encapsulation_dot1br_strip
                    encapsulation_vn_tag_strip: encapsulation_vn_tag_strip
                    protocol_lldp_trap: protocol_lldp_trap
                    truncation_size: Allowed truncation_size values vary depending on the platform.
                    mac: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class TcamProfile(AvdModel):
        """Subclass of AvdModel."""

        class ProfilesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"name": {"type": str}, "config": {"type": str}, "source": {"type": str}, "_custom_data": {"type": dict}}
            name: str
            """Tcam-Profile Name."""
            config: str | None
            """
            TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
            a file.
            Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
            """
            source: str | None
            """
            TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
            device.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    config: str | None | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Tcam-Profile Name.
                        config:
                           TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
                           a file.
                           Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
                        source:
                           TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
                           device.
                        _custom_data: _custom_data

                    """

        class Profiles(AvdIndexedList[str, ProfilesItem]):
            """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {"system": {"type": str}, "profiles": {"type": Profiles}, "_custom_data": {"type": dict}}
        system: str | None
        """TCAM profile name to activate."""
        profiles: Profiles
        """Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                system: str | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TcamProfile.


                Subclass of AvdModel.

                Args:
                    system: TCAM profile name to activate.
                    profiles: Subclass of AvdIndexedList with `ProfilesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class Terminal(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"length": {"type": int}, "width": {"type": int}, "_custom_data": {"type": dict}}
        length: int | None
        width: int | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                length: int | None | UndefinedType = Undefined,
                width: int | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                Terminal.


                Subclass of AvdModel.

                Args:
                    length: length
                    width: width
                    _custom_data: _custom_data

                """

    class TrackersItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "interface": {"type": str},
            "tracked_property": {"type": str, "default": "line-protocol"},
            "_custom_data": {"type": dict},
        }
        name: str
        """Name of tracker object."""
        interface: str
        """Name of tracked interface."""
        tracked_property: str
        """
        Property to track.

        Default value: `"line-protocol"`
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                interface: str | UndefinedType = Undefined,
                tracked_property: str | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TrackersItem.


                Subclass of AvdModel.

                Args:
                    name: Name of tracker object.
                    interface: Name of tracked interface.
                    tracked_property: Property to track.
                    _custom_data: _custom_data

                """

    class Trackers(AvdIndexedList[str, TrackersItem]):
        """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Trackers._item_type = TrackersItem

    class TrafficPolicies(AvdModel):
        """Subclass of AvdModel."""

        class Options(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"counter_per_interface": {"type": bool}, "_custom_data": {"type": dict}}
            counter_per_interface: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self, *, counter_per_interface: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                ) -> None:
                    """
                    Options.


                    Subclass of AvdModel.

                    Args:
                        counter_per_interface: counter_per_interface
                        _custom_data: _custom_data

                    """

        class FieldSets(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4Item(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Prefixes._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
                name: str
                """IPv4 Prefix Field Set Name."""
                prefixes: Prefixes
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        prefixes: Prefixes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4Item.


                        Subclass of AvdModel.

                        Args:
                            name: IPv4 Prefix Field Set Name.
                            prefixes: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class Ipv4(AvdIndexedList[str, Ipv4Item]):
                """Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv4._item_type = Ipv4Item

            class Ipv6Item(AvdModel):
                """Subclass of AvdModel."""

                class Prefixes(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                Prefixes._item_type = str

                _fields: ClassVar[dict] = {"name": {"type": str}, "prefixes": {"type": Prefixes}, "_custom_data": {"type": dict}}
                name: str
                """IPv6 Prefix Field Set Name."""
                prefixes: Prefixes
                """Subclass of AvdList with `str` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        prefixes: Prefixes | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6Item.


                        Subclass of AvdModel.

                        Args:
                            name: IPv6 Prefix Field Set Name.
                            prefixes: Subclass of AvdList with `str` items.
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdIndexedList[str, Ipv6Item]):
                """Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ipv6._item_type = Ipv6Item

            class PortsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "port_range": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                """L4 Port Field Set Name."""
                port_range: str | None
                """Example: '10,20,80,440-450'"""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        port_range: str | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PortsItem.


                        Subclass of AvdModel.

                        Args:
                            name: L4 Port Field Set Name.
                            port_range: Example: '10,20,80,440-450'
                            _custom_data: _custom_data

                        """

            class Ports(AvdIndexedList[str, PortsItem]):
                """Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Ports._item_type = PortsItem

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "ports": {"type": Ports}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`)."""
            ipv6: Ipv6
            """Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`)."""
            ports: Ports
            """Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`)."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    ports: Ports | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    FieldSets.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdIndexedList with `Ipv4Item` items. Primary key is `name` (`str`).
                        ipv6: Subclass of AvdIndexedList with `Ipv6Item` items. Primary key is `name` (`str`).
                        ports: Subclass of AvdIndexedList with `PortsItem` items. Primary key is `name` (`str`).
                        _custom_data: _custom_data

                    """

        class PoliciesItem(AvdModel):
            """Subclass of AvdModel."""

            class MatchesItem(AvdModel):
                """Subclass of AvdModel."""

                class Source(AvdModel):
                    """Subclass of AvdModel."""

                    class Prefixes(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Prefixes._item_type = str

                    class PrefixLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    PrefixLists._item_type = str

                    _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "prefix_lists": {"type": PrefixLists}, "_custom_data": {"type": dict}}
                    prefixes: Prefixes
                    """Subclass of AvdList with `str` items."""
                    prefix_lists: PrefixLists
                    """
                    Field-set prefix lists.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefixes: Prefixes | UndefinedType = Undefined,
                            prefix_lists: PrefixLists | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Source.


                            Subclass of AvdModel.

                            Args:
                                prefixes: Subclass of AvdList with `str` items.
                                prefix_lists:
                                   Field-set prefix lists.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Destination(AvdModel):
                    """Subclass of AvdModel."""

                    class Prefixes(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Prefixes._item_type = str

                    class PrefixLists(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    PrefixLists._item_type = str

                    _fields: ClassVar[dict] = {"prefixes": {"type": Prefixes}, "prefix_lists": {"type": PrefixLists}, "_custom_data": {"type": dict}}
                    prefixes: Prefixes
                    """Subclass of AvdList with `str` items."""
                    prefix_lists: PrefixLists
                    """
                    Field-set prefix lists.

                    Subclass of AvdList with `str` items.
                    """
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            prefixes: Prefixes | UndefinedType = Undefined,
                            prefix_lists: PrefixLists | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Destination.


                            Subclass of AvdModel.

                            Args:
                                prefixes: Subclass of AvdList with `str` items.
                                prefix_lists:
                                   Field-set prefix lists.

                                   Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Fragment(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"offset": {"type": str}, "_custom_data": {"type": dict}}
                    offset: str | None
                    """Fragment offset range."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, offset: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Fragment.


                            Subclass of AvdModel.

                            Args:
                                offset: Fragment offset range.
                                _custom_data: _custom_data

                            """

                class ProtocolsItem(AvdModel):
                    """Subclass of AvdModel."""

                    class Flags(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    Flags._item_type = str

                    class IcmpType(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    IcmpType._item_type = str

                    _fields: ClassVar[dict] = {
                        "protocol": {"type": str},
                        "src_port": {"type": str},
                        "dst_port": {"type": str},
                        "src_field": {"type": str},
                        "dst_field": {"type": str},
                        "flags": {"type": Flags},
                        "icmp_type": {"type": IcmpType},
                        "enforce_gtsm": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    protocol: str
                    src_port: str | None
                    """Port range."""
                    dst_port: str | None
                    """Port range."""
                    src_field: str | None
                    """L4 port range field set."""
                    dst_field: str | None
                    """L4 port range field set."""
                    flags: Flags
                    """Subclass of AvdList with `str` items."""
                    icmp_type: IcmpType
                    """Subclass of AvdList with `str` items."""
                    enforce_gtsm: bool | None
                    """Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            protocol: str | UndefinedType = Undefined,
                            src_port: str | None | UndefinedType = Undefined,
                            dst_port: str | None | UndefinedType = Undefined,
                            src_field: str | None | UndefinedType = Undefined,
                            dst_field: str | None | UndefinedType = Undefined,
                            flags: Flags | UndefinedType = Undefined,
                            icmp_type: IcmpType | UndefinedType = Undefined,
                            enforce_gtsm: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ProtocolsItem.


                            Subclass of AvdModel.

                            Args:
                                protocol: protocol
                                src_port: Port range.
                                dst_port: Port range.
                                src_field: L4 port range field set.
                                dst_field: L4 port range field set.
                                flags: Subclass of AvdList with `str` items.
                                icmp_type: Subclass of AvdList with `str` items.
                                enforce_gtsm: Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'.
                                _custom_data: _custom_data

                            """

                class Protocols(AvdIndexedList[str, ProtocolsItem]):
                    """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""

                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                class Actions(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Actions.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count: Counter name.
                                drop: drop
                                log: Only supported when action is set to drop.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "name": {"type": str},
                    "type": {"type": str},
                    "source": {"type": Source},
                    "destination": {"type": Destination},
                    "ttl": {"type": str},
                    "fragment": {"type": Fragment},
                    "protocols": {"type": Protocols},
                    "actions": {"type": Actions},
                    "_custom_data": {"type": dict},
                }
                name: str
                """Traffic Policy Item."""
                type: Literal["ipv4", "ipv6"]
                source: Source
                """Subclass of AvdModel."""
                destination: Destination
                """Subclass of AvdModel."""
                ttl: str | None
                """TTL range."""
                fragment: Fragment
                """
                The 'fragment' command is not supported when 'source port'
                or 'destination port' command is
                configured.


                Subclass of AvdModel.
                """
                protocols: Protocols
                """Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`)."""
                actions: Actions
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        type: Literal["ipv4", "ipv6"] | UndefinedType = Undefined,
                        source: Source | UndefinedType = Undefined,
                        destination: Destination | UndefinedType = Undefined,
                        ttl: str | None | UndefinedType = Undefined,
                        fragment: Fragment | UndefinedType = Undefined,
                        protocols: Protocols | UndefinedType = Undefined,
                        actions: Actions | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchesItem.


                        Subclass of AvdModel.

                        Args:
                            name: Traffic Policy Item.
                            type: type
                            source: Subclass of AvdModel.
                            destination: Subclass of AvdModel.
                            ttl: TTL range.
                            fragment:
                               The 'fragment' command is not supported when 'source port'
                               or 'destination port' command is
                               configured.


                               Subclass of AvdModel.
                            protocols: Subclass of AvdIndexedList with `ProtocolsItem` items. Primary key is `protocol` (`str`).
                            actions: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Matches(AvdIndexedList[str, MatchesItem]):
                """Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            Matches._item_type = MatchesItem

            class DefaultActions(AvdModel):
                """Subclass of AvdModel."""

                class Ipv4(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ipv4.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count: Counter name.
                                drop: drop
                                log: Only supported when action is set to drop.
                                _custom_data: _custom_data

                            """

                class Ipv6(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp: int | None | UndefinedType = Undefined,
                            traffic_class: int | None | UndefinedType = Undefined,
                            count: str | None | UndefinedType = Undefined,
                            drop: bool | None | UndefinedType = Undefined,
                            log: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ipv6.


                            Subclass of AvdModel.

                            Args:
                                dscp: dscp
                                traffic_class: Traffic class ID.
                                count: Counter name.
                                drop: drop
                                log: Only supported when action is set to drop.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "_custom_data": {"type": dict}}
                ipv4: Ipv4
                """Subclass of AvdModel."""
                ipv6: Ipv6
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: Ipv4 | UndefinedType = Undefined,
                        ipv6: Ipv6 | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultActions.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Subclass of AvdModel.
                            ipv6: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "name": {"type": str},
                "matches": {"type": Matches},
                "default_actions": {"type": DefaultActions},
                "_custom_data": {"type": dict},
            }
            name: str
            """Traffic Policy Name."""
            matches: Matches
            """Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`)."""
            default_actions: DefaultActions
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    name: str | UndefinedType = Undefined,
                    matches: Matches | UndefinedType = Undefined,
                    default_actions: DefaultActions | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.


                    Subclass of AvdModel.

                    Args:
                        name: Traffic Policy Name.
                        matches: Subclass of AvdIndexedList with `MatchesItem` items. Primary key is `name` (`str`).
                        default_actions: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Policies(AvdIndexedList[str, PoliciesItem]):
            """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""

            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        _fields: ClassVar[dict] = {
            "options": {"type": Options},
            "field_sets": {"type": FieldSets},
            "policies": {"type": Policies},
            "_custom_data": {"type": dict},
        }
        options: Options
        """Subclass of AvdModel."""
        field_sets: FieldSets
        """Subclass of AvdModel."""
        policies: Policies
        """Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`)."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                options: Options | UndefinedType = Undefined,
                field_sets: FieldSets | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TrafficPolicies.


                Subclass of AvdModel.

                Args:
                    options: Subclass of AvdModel.
                    field_sets: Subclass of AvdModel.
                    policies: Subclass of AvdIndexedList with `PoliciesItem` items. Primary key is `name` (`str`).
                    _custom_data: _custom_data

                """

    class TunnelInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class TcpMssCeiling(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}, "_custom_data": {"type": dict}}
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: Literal["ingress", "egress"] | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                    direction: Literal["ingress", "egress"] | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMssCeiling.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Segment Size for IPv4.
                        ipv6: Segment Size for IPv6.
                        direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "underlay_vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "tunnel_mode": {"type": str},
            "source_interface": {"type": str},
            "destination": {"type": str},
            "path_mtu_discovery": {"type": bool},
            "ipsec_profile": {"type": str},
            "nat_profile": {"type": str},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Tunnel Interface Name."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        underlay_vrf: str | None
        """Underlay VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        access_group_in: str | None
        """IPv4 ACL Name for ingress."""
        access_group_out: str | None
        """IPv4 ACL Name for egress."""
        ipv6_access_group_in: str | None
        """IPv6 ACL Name for ingress."""
        ipv6_access_group_out: str | None
        """IPv6 ACL Name for egress."""
        tcp_mss_ceiling: TcpMssCeiling
        """Subclass of AvdModel."""
        tunnel_mode: Literal["gre", "ipsec"] | None
        """
        Tunnel encapsulation method.
        `gre`: Generic route encapsulation protocol,
        `ipsec`: IPsec-over-IP
        encapsulation.
        """
        source_interface: str | None
        """Tunnel Source Interface Name."""
        destination: str | None
        """IPv4 or IPv6 Address Tunnel Destination."""
        path_mtu_discovery: bool | None
        """Enable Path MTU Discovery On Tunnel."""
        ipsec_profile: str | None
        """
        Used only when `tunnel_mode` is set to `ipsec`.
        It must target a defined IPsec profile.
        """
        nat_profile: str | None
        """NAT interface profile."""
        eos_cli: str | None
        """
        Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
        configuration.
        """
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                underlay_vrf: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
                tunnel_mode: Literal["gre", "ipsec"] | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                destination: str | None | UndefinedType = Undefined,
                path_mtu_discovery: bool | None | UndefinedType = Undefined,
                ipsec_profile: str | None | UndefinedType = Undefined,
                nat_profile: str | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                TunnelInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: Tunnel Interface Name.
                    description: description
                    shutdown: shutdown
                    mtu: mtu
                    vrf: VRF Name.
                    underlay_vrf: Underlay VRF Name.
                    ip_address: IPv4_address/Mask.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    access_group_in: IPv4 ACL Name for ingress.
                    access_group_out: IPv4 ACL Name for egress.
                    ipv6_access_group_in: IPv6 ACL Name for ingress.
                    ipv6_access_group_out: IPv6 ACL Name for egress.
                    tcp_mss_ceiling: Subclass of AvdModel.
                    tunnel_mode:
                       Tunnel encapsulation method.
                       `gre`: Generic route encapsulation protocol,
                       `ipsec`: IPsec-over-IP
                       encapsulation.
                    source_interface: Tunnel Source Interface Name.
                    destination: IPv4 or IPv6 Address Tunnel Destination.
                    path_mtu_discovery: Enable Path MTU Discovery On Tunnel.
                    ipsec_profile:
                       Used only when `tunnel_mode` is set to `ipsec`.
                       It must target a defined IPsec profile.
                    nat_profile: NAT interface profile.
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
                       configuration.
                    _custom_data: _custom_data

                """

    class TunnelInterfaces(AvdIndexedList[str, TunnelInterfacesItem]):
        """Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    TunnelInterfaces._item_type = TunnelInterfacesItem

    class VirtualSourceNatVrfsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {"name": {"type": str}, "ip_address": {"type": str}, "ipv6_address": {"type": str}, "_custom_data": {"type": dict}}
        name: str
        """VRF Name."""
        ip_address: str | None
        """IPv4 Address."""
        ipv6_address: str | None
        """IPv6 Address."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VirtualSourceNatVrfsItem.


                Subclass of AvdModel.

                Args:
                    name: VRF Name.
                    ip_address: IPv4 Address.
                    ipv6_address: IPv6 Address.
                    _custom_data: _custom_data

                """

    class VirtualSourceNatVrfs(AvdIndexedList[str, VirtualSourceNatVrfsItem]):
        """Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VirtualSourceNatVrfs._item_type = VirtualSourceNatVrfsItem

    class VlanInterfacesItem(AvdModel):
        """Subclass of AvdModel."""

        class Logging(AvdModel):
            """Subclass of AvdModel."""

            class Event(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"link_status": {"type": bool}, "_custom_data": {"type": dict}}
                link_status: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self, *, link_status: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Event.


                        Subclass of AvdModel.

                        Args:
                            link_status: link_status
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"event": {"type": Event}, "_custom_data": {"type": dict}}
            event: Event
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, event: Event | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Logging.


                    Subclass of AvdModel.

                    Args:
                        event: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class IpAddressSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressSecondaries._item_type = str

        class IpVirtualRouterAddresses(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpVirtualRouterAddresses._item_type = str

        class IpAddressVirtualSecondaries(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        IpAddressVirtualSecondaries._item_type = str

        class IpIgmpHostProxy(AvdModel):
            """Subclass of AvdModel."""

            class GroupsItem(AvdModel):
                """Subclass of AvdModel."""

                class ExcludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            ExcludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Exclude(AvdIndexedList[str, ExcludeItem]):
                    """Subclass of AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"source": {"type": str}, "_custom_data": {"type": dict}}
                    source: str
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, source: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            IncludeItem.


                            Subclass of AvdModel.

                            Args:
                                source: source
                                _custom_data: _custom_data

                            """

                class Include(AvdIndexedList[str, IncludeItem]):
                    """Subclass of AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`)."""

                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}, "_custom_data": {"type": dict}}
                group: str
                """Multicast Address."""
                exclude: Exclude
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                """
                include: Include
                """
                The same source must not be present both in `exclude` and `include` list.

                Subclass of
                AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                """
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        group: str | UndefinedType = Undefined,
                        exclude: Exclude | UndefinedType = Undefined,
                        include: Include | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        GroupsItem.


                        Subclass of AvdModel.

                        Args:
                            group: Multicast Address.
                            exclude:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `ExcludeItem` items. Primary key is `source` (`str`).
                            include:
                               The same source must not be present both in `exclude` and `include` list.

                               Subclass of
                               AvdIndexedList with `IncludeItem` items. Primary key is `source` (`str`).
                            _custom_data: _custom_data

                        """

            class Groups(AvdIndexedList[str, GroupsItem]):
                """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""

                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "_custom_data": {"type": dict}}
                name: str
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, name: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        AccessListsItem.


                        Subclass of AvdModel.

                        Args:
                            name: name
                            _custom_data: _custom_data

                        """

            class AccessLists(AvdIndexedList[str, AccessListsItem]):
                """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
                "_custom_data": {"type": dict},
            }
            enabled: bool | None
            groups: Groups
            """Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`)."""
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """
            Non-standard Access List name.

            Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
            is `name` (`str`).
            """
            version: int | None
            """IGMP version on IGMP host-proxy interface."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | None | UndefinedType = Undefined,
                    groups: Groups | UndefinedType = Undefined,
                    report_interval: int | None | UndefinedType = Undefined,
                    access_lists: AccessLists | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpIgmpHostProxy.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        groups: Subclass of AvdIndexedList with `GroupsItem` items. Primary key is `group` (`str`).
                        report_interval: Time interval between unsolicited reports.
                        access_lists:
                           Non-standard Access List name.

                           Subclass of AvdIndexedList with `AccessListsItem` items. Primary key
                           is `name` (`str`).
                        version: IGMP version on IGMP host-proxy interface.
                        _custom_data: _custom_data

                    """

        class IpHelpersItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}, "_custom_data": {"type": dict}}
            ip_helper: str
            """IP address or hostname of DHCP server."""
            source_interface: str | None
            """Interface used as source for forwarded DHCP packets."""
            vrf: str | None
            """VRF where DHCP server can be reached."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ip_helper: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpHelpersItem.


                    Subclass of AvdModel.

                    Args:
                        ip_helper: IP address or hostname of DHCP server.
                        source_interface: Interface used as source for forwarded DHCP packets.
                        vrf: VRF where DHCP server can be reached.
                        _custom_data: _custom_data

                    """

        class IpHelpers(AvdIndexedList[str, IpHelpersItem]):
            """Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is `ip_helper` (`str`)."""

            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            """Subclass of AvdModel."""

            class Destination(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            pool_name: str | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                pool_name: pool_name
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            class Source(AvdModel):
                """Subclass of AvdModel."""

                class DynamicItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str
                    comment: str | None
                    nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"]
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            nat_type: Literal["overload", "pool", "pool-address-only", "pool-full-cone"] | UndefinedType = Undefined,
                            pool_name: str | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DynamicItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: access_list
                                comment: comment
                                nat_type: nat_type
                                pool_name:
                                   required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                                   ignored if 'nat_type' is
                                   overload.
                                priority: priority
                                _custom_data: _custom_data

                            """

                class Dynamic(AvdIndexedList[str, DynamicItem]):
                    """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""

                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                        "_custom_data": {"type": dict},
                    }
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: Literal["egress", "ingress"] | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: Literal["udp", "tcp"] | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            access_list: str | None | UndefinedType = Undefined,
                            comment: str | None | UndefinedType = Undefined,
                            direction: Literal["egress", "ingress"] | None | UndefinedType = Undefined,
                            group: int | None | UndefinedType = Undefined,
                            original_ip: str | None | UndefinedType = Undefined,
                            original_port: int | None | UndefinedType = Undefined,
                            priority: int | None | UndefinedType = Undefined,
                            protocol: Literal["udp", "tcp"] | None | UndefinedType = Undefined,
                            translated_ip: str | UndefinedType = Undefined,
                            translated_port: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticItem.


                            Subclass of AvdModel.

                            Args:
                                access_list: 'access_list' and 'group' are mutual exclusive.
                                comment: comment
                                direction:
                                   Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                                   platform.
                                   EOS might remove this keyword in the configuration. So, check the configuration on
                                   targeted HW/SW.
                                group: 'access_list' and 'group' are mutual exclusive.
                                original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                                original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                                priority: priority
                                protocol: protocol
                                translated_ip: IPv4 address.
                                translated_port: requires 'original_port'.
                                _custom_data: _custom_data

                            """

                class Static(AvdList[StaticItem]):
                    """Subclass of AvdList with `StaticItem` items."""

                Static._item_type = StaticItem

                _fields: ClassVar[dict] = {"dynamic": {"type": Dynamic}, "static": {"type": Static}, "_custom_data": {"type": dict}}
                dynamic: Dynamic
                """Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`)."""
                static: Static
                """Subclass of AvdList with `StaticItem` items."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Source.


                        Subclass of AvdModel.

                        Args:
                            dynamic: Subclass of AvdIndexedList with `DynamicItem` items. Primary key is `access_list` (`str`).
                            static: Subclass of AvdList with `StaticItem` items.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"destination": {"type": Destination}, "source": {"type": Source}, "_custom_data": {"type": dict}}
            destination: Destination
            """Subclass of AvdModel."""
            source: Source
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    destination: Destination | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpNat.


                    Subclass of AvdModel.

                    Args:
                        destination: Subclass of AvdModel.
                        source: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Ipv6AddressVirtuals(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Ipv6AddressVirtuals._item_type = str

        class Ipv6VirtualRouterAddresses(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Ipv6VirtualRouterAddresses._item_type = str

        class Ipv6NdCache(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "dynamic_capacity": {"type": int},
                "expire": {"type": int},
                "refresh_always": {"type": bool},
                "_custom_data": {"type": dict},
            }
            dynamic_capacity: int | None
            """Capacity of dynamic cache entries."""
            expire: int | None
            """Cache entries expirery in seconds."""
            refresh_always: bool | None
            """Force refresh on cache expiry."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    dynamic_capacity: int | None | UndefinedType = Undefined,
                    expire: int | None | UndefinedType = Undefined,
                    refresh_always: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdCache.


                    Subclass of AvdModel.

                    Args:
                        dynamic_capacity: Capacity of dynamic cache entries.
                        expire: Cache entries expirery in seconds.
                        refresh_always: Force refresh on cache expiry.
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixesItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
                "_custom_data": {"type": dict},
            }
            ipv6_prefix: str
            """IPv6_address/Mask."""
            valid_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            preferred_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            no_autoconfig_flag: bool | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv6_prefix: str | UndefinedType = Undefined,
                    valid_lifetime: str | None | UndefinedType = Undefined,
                    preferred_lifetime: str | None | UndefinedType = Undefined,
                    no_autoconfig_flag: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6NdPrefixesItem.


                    Subclass of AvdModel.

                    Args:
                        ipv6_prefix: IPv6_address/Mask.
                        valid_lifetime: In seconds <0-4294967295> or infinite.
                        preferred_lifetime: In seconds <0-4294967295> or infinite.
                        no_autoconfig_flag: no_autoconfig_flag
                        _custom_data: _custom_data

                    """

        class Ipv6NdPrefixes(AvdIndexedList[str, Ipv6NdPrefixesItem]):
            """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""

            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
                "_custom_data": {"type": dict},
            }
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    source_address: str | None | UndefinedType = Undefined,
                    link_address: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6DhcpRelayDestinationsItem.


                    Subclass of AvdModel.

                    Args:
                        address: DHCP server's IPv6 address.
                        vrf: vrf
                        local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                        source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                        link_address: Override the default link address specified in the relayed DHCP packet.
                        _custom_data: _custom_data

                    """

        class Ipv6DhcpRelayDestinations(AvdIndexedList[str, Ipv6DhcpRelayDestinationsItem]):
            """
            Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
            (`str`).
            """

            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "out": {"type": bool}, "_custom_data": {"type": dict}}
                    boundary: str
                    """IPv4 access-list name or IPv4 multicast group prefix with mask."""
                    out: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            boundary: str | UndefinedType = Undefined,
                            out: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: IPv4 access-list name or IPv4 multicast group prefix with mask.
                                out: out
                                _custom_data: _custom_data

                            """

                class Boundaries(AvdIndexedList[str, BoundariesItem]):
                    """Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`)."""

                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_distance": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool
                    administrative_distance: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            administrative_distance: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SourceRouteExport.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                administrative_distance: administrative_distance
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "boundaries": {"type": Boundaries},
                    "source_route_export": {"type": SourceRouteExport},
                    "static": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.

                Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                """
                source_route_export: SourceRouteExport
                """Subclass of AvdModel."""
                static: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        source_route_export: SourceRouteExport | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            boundaries:
                               Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                               of both.

                               Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                            source_route_export: Subclass of AvdModel.
                            static: static
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                class BoundariesItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"boundary": {"type": str}, "_custom_data": {"type": dict}}
                    boundary: str
                    """IPv6 access-list name or IPv6 multicast group prefix with mask."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, boundary: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            BoundariesItem.


                            Subclass of AvdModel.

                            Args:
                                boundary: IPv6 access-list name or IPv6 multicast group prefix with mask.
                                _custom_data: _custom_data

                            """

                class Boundaries(AvdIndexedList[str, BoundariesItem]):
                    """Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`)."""

                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "administrative_distance": {"type": int}, "_custom_data": {"type": dict}}
                    enabled: bool
                    administrative_distance: int | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            enabled: bool | UndefinedType = Undefined,
                            administrative_distance: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SourceRouteExport.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                administrative_distance: administrative_distance
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "boundaries": {"type": Boundaries},
                    "source_route_export": {"type": SourceRouteExport},
                    "static": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.

                Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                """
                source_route_export: SourceRouteExport
                """Subclass of AvdModel."""
                static: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        boundaries: Boundaries | UndefinedType = Undefined,
                        source_route_export: SourceRouteExport | UndefinedType = Undefined,
                        static: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            boundaries:
                               Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                               of both.

                               Subclass of AvdIndexedList with `BoundariesItem` items. Primary key is `boundary` (`str`).
                            source_route_export: Subclass of AvdModel.
                            static: static
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeysItem(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}, "_custom_data": {"type": dict}}
            id: int
            hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None
            key: str | None
            """Encrypted password."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    hash_algorithm: Literal["md5", "sha1", "sha256", "sha384", "sha512"] | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    OspfMessageDigestKeysItem.


                    Subclass of AvdModel.

                    Args:
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Encrypted password.
                        _custom_data: _custom_data

                    """

        class OspfMessageDigestKeys(AvdIndexedList[int, OspfMessageDigestKeysItem]):
            """Subclass of AvdIndexedList with `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            """Subclass of AvdModel."""

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                class Hello(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"count": {"type": str}, "interval": {"type": int}, "_custom_data": {"type": dict}}
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            count: str | None | UndefinedType = Undefined,
                            interval: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Hello.


                            Subclass of AvdModel.

                            Args:
                                count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                                interval: PIM hello interval in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "local_interface": {"type": str},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                    "_custom_data": {"type": dict},
                }
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                local_interface: str | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        border_router: bool | None | UndefinedType = Undefined,
                        dr_priority: int | None | UndefinedType = Undefined,
                        sparse_mode: bool | None | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bidirectional: bool | None | UndefinedType = Undefined,
                        hello: Hello | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            border_router: Configure PIM border router. EOS default is false.
                            dr_priority: dr_priority
                            sparse_mode: sparse_mode
                            local_interface: local_interface
                            bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                            bidirectional: bidirectional
                            hello: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"ipv4": {"type": Ipv4}, "_custom_data": {"type": dict}}
            ipv4: Ipv4
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, ipv4: Ipv4 | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    Pim.


                    Subclass of AvdModel.

                    Args:
                        ipv4: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class IsisAuthentication(AvdModel):
            """Subclass of AvdModel."""

            class Both(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Both.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level1(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level1.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            class Level2(AvdModel):
                """Subclass of AvdModel."""

                class KeyIdsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """Configure authentication key-id."""
                    algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    key_type: Literal["0", "7", "8a"]
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            algorithm: Literal["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            key_type: Literal["0", "7", "8a"] | UndefinedType = Undefined,
                            key: str | UndefinedType = Undefined,
                            rfc_5310: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            KeyIdsItem.


                            Subclass of AvdModel.

                            Args:
                                id: Configure authentication key-id.
                                algorithm: algorithm
                                key_type: Configure authentication key type.
                                key: Password string.
                                rfc_5310: SHA digest computation according to rfc5310.
                                _custom_data: _custom_data

                            """

                class KeyIds(AvdIndexedList[int, KeyIdsItem]):
                    """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"key_id": {"type": int}, "_custom_data": {"type": dict}}
                    key_id: int
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, key_id: int | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Sha.


                            Subclass of AvdModel.

                            Args:
                                key_id: key_id
                                _custom_data: _custom_data

                            """

                class SharedSecret(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"profile": {"type": str}, "algorithm": {"type": str}, "_custom_data": {"type": dict}}
                    profile: str
                    algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            profile: str | UndefinedType = Undefined,
                            algorithm: Literal["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"] | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.


                            Subclass of AvdModel.

                            Args:
                                profile: profile
                                algorithm: algorithm
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                key_type: Literal["0", "7", "8a"] | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                """Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`)."""
                mode: Literal["md5", "sha", "text", "shared-secret"] | None
                """Authentication mode."""
                sha: Sha
                """
                Required settings for authentication mode 'sha'.

                Subclass of AvdModel.
                """
                shared_secret: SharedSecret
                """
                Required settings for authentication mode 'shared_secret'.

                Subclass of AvdModel.
                """
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        key_type: Literal["0", "7", "8a"] | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                        key_ids: KeyIds | UndefinedType = Undefined,
                        mode: Literal["md5", "sha", "text", "shared-secret"] | None | UndefinedType = Undefined,
                        sha: Sha | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        rx_disabled: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Level2.


                        Subclass of AvdModel.

                        Args:
                            key_type: Configure authentication key type.
                            key: Password string. `key_type` is required for this setting.
                            key_ids: Subclass of AvdIndexedList with `KeyIdsItem` items. Primary key is `id` (`int`).
                            mode: Authentication mode.
                            sha:
                               Required settings for authentication mode 'sha'.

                               Subclass of AvdModel.
                            shared_secret:
                               Required settings for authentication mode 'shared_secret'.

                               Subclass of AvdModel.
                            rx_disabled: Disable authentication check on the receive side.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}, "_custom_data": {"type": dict}}
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.

            Subclass of AvdModel.
            """
            level_1: Level1
            """
            Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            level_2: Level2
            """
            Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
            Subclass of AvdModel.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    both: Both | UndefinedType = Undefined,
                    level_1: Level1 | UndefinedType = Undefined,
                    level_2: Level2 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IsisAuthentication.


                    Subclass of AvdModel.

                    Args:
                        both:
                           Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                           'level_2' settings.

                           Subclass of AvdModel.
                        level_1:
                           Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        level_2:
                           Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.
                           Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class VrrpIdsItem(AvdModel):
            """Subclass of AvdModel."""

            class Advertisement(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"interval": {"type": int}, "_custom_data": {"type": dict}}
                interval: int | None
                """Interval in seconds."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, interval: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Advertisement.


                        Subclass of AvdModel.

                        Args:
                            interval: Interval in seconds.
                            _custom_data: _custom_data

                        """

            class Preempt(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"minimum": {"type": int}, "reload": {"type": int}, "_custom_data": {"type": dict}}
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            minimum: int | None | UndefinedType = Undefined,
                            reload: int | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                minimum: Minimum preempt delay in seconds.
                                reload: Reload preempt delay in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"enabled": {"type": bool}, "delay": {"type": Delay}, "_custom_data": {"type": dict}}
                enabled: bool
                delay: Delay
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        enabled: bool | UndefinedType = Undefined,
                        delay: Delay | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Preempt.


                        Subclass of AvdModel.

                        Args:
                            enabled: enabled
                            delay: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class Timers(AvdModel):
                """Subclass of AvdModel."""

                class Delay(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"reload": {"type": int}, "_custom_data": {"type": dict}}
                    reload: int | None
                    """Delay after reload in seconds."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(self, *, reload: int | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                            """
                            Delay.


                            Subclass of AvdModel.

                            Args:
                                reload: Delay after reload in seconds.
                                _custom_data: _custom_data

                            """

                _fields: ClassVar[dict] = {"delay": {"type": Delay}, "_custom_data": {"type": dict}}
                delay: Delay
                """Subclass of AvdModel."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, delay: Delay | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Timers.


                        Subclass of AvdModel.

                        Args:
                            delay: Subclass of AvdModel.
                            _custom_data: _custom_data

                        """

            class TrackedObjectItem(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}, "_custom_data": {"type": dict}}
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        name: str | UndefinedType = Undefined,
                        decrement: int | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TrackedObjectItem.


                        Subclass of AvdModel.

                        Args:
                            name: Tracked object name.
                            decrement: Decrement VRRP priority by 1-254.
                            shutdown: shutdown
                            _custom_data: _custom_data

                        """

            class TrackedObject(AvdIndexedList[str, TrackedObjectItem]):
                """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""

                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"address": {"type": str}, "version": {"type": int}, "_custom_data": {"type": dict}}
                address: str
                """Virtual IPv4 address."""
                version: Literal[2, 3] | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        address: str | UndefinedType = Undefined,
                        version: Literal[2, 3] | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv4 address.
                            version: version
                            _custom_data: _custom_data

                        """

            class Ipv6(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"address": {"type": str}, "_custom_data": {"type": dict}}
                address: str
                """Virtual IPv6 address."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, address: str | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Ipv6.


                        Subclass of AvdModel.

                        Args:
                            address: Virtual IPv6 address.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
                "_custom_data": {"type": dict},
            }
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            """Subclass of AvdModel."""
            preempt: Preempt
            """Subclass of AvdModel."""
            timers: Timers
            """Subclass of AvdModel."""
            tracked_object: TrackedObject
            """Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`)."""
            ipv4: Ipv4
            """Subclass of AvdModel."""
            ipv6: Ipv6
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    id: int | UndefinedType = Undefined,
                    priority_level: int | None | UndefinedType = Undefined,
                    advertisement: Advertisement | UndefinedType = Undefined,
                    preempt: Preempt | UndefinedType = Undefined,
                    timers: Timers | UndefinedType = Undefined,
                    tracked_object: TrackedObject | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrrpIdsItem.


                    Subclass of AvdModel.

                    Args:
                        id: VRID.
                        priority_level: Instance priority.
                        advertisement: Subclass of AvdModel.
                        preempt: Subclass of AvdModel.
                        timers: Subclass of AvdModel.
                        tracked_object: Subclass of AvdIndexedList with `TrackedObjectItem` items. Primary key is `name` (`str`).
                        ipv4: Subclass of AvdModel.
                        ipv6: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class VrrpIds(AvdIndexedList[int, VrrpIdsItem]):
            """Subclass of AvdIndexedList with `VrrpIdsItem` items. Primary key is `id` (`int`)."""

            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class IpAttachedHostRouteExport(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "distance": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool
            distance: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    distance: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpAttachedHostRouteExport.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        distance: distance
                        _custom_data: _custom_data

                    """

        class Ipv6AttachedHostRouteExport(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"enabled": {"type": bool}, "distance": {"type": int}, "prefix_length": {"type": int}, "_custom_data": {"type": dict}}
            enabled: bool
            distance: int | None
            """Administrative distance for generated routes."""
            prefix_length: int | None
            """Prefix length for generated routes."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    enabled: bool | UndefinedType = Undefined,
                    distance: int | None | UndefinedType = Undefined,
                    prefix_length: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6AttachedHostRouteExport.


                    Subclass of AvdModel.

                    Args:
                        enabled: enabled
                        distance: Administrative distance for generated routes.
                        prefix_length: Prefix length for generated routes.
                        _custom_data: _custom_data

                    """

        class Bfd(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
                "_custom_data": {"type": dict},
            }
            echo: bool | None
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Minimum RX hold time in milliseconds."""
            multiplier: int | None
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    echo: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bfd.


                    Subclass of AvdModel.

                    Args:
                        echo: echo
                        interval: Rate in milliseconds.
                        min_rx: Minimum RX hold time in milliseconds.
                        multiplier: multiplier
                        _custom_data: _custom_data

                    """

        class ServicePolicy(AvdModel):
            """Subclass of AvdModel."""

            class Pbr(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"input": {"type": str}, "_custom_data": {"type": dict}}
                input: str | None
                """Name of policy-map used for policy based routing."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(self, *, input: str | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                        """
                        Pbr.


                        Subclass of AvdModel.

                        Args:
                            input: Name of policy-map used for policy based routing.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"pbr": {"type": Pbr}, "_custom_data": {"type": dict}}
            pbr: Pbr
            """Subclass of AvdModel."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(self, *, pbr: Pbr | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined) -> None:
                    """
                    ServicePolicy.


                    Subclass of AvdModel.

                    Args:
                        pbr: Subclass of AvdModel.
                        _custom_data: _custom_data

                    """

        class Tags(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        Tags._item_type = str

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "arp_aging_timeout": {"type": int},
            "arp_cache_dynamic_capacity": {"type": int},
            "arp_gratuitous_accept": {"type": bool},
            "arp_monitor_mac_address": {"type": bool},
            "ip_proxy_arp": {"type": bool},
            "ip_directed_broadcast": {"type": bool},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": IpAddressSecondaries},
            "ip_virtual_router_addresses": {"type": IpVirtualRouterAddresses},
            "ip_address_virtual": {"type": str},
            "ip_address_virtual_secondaries": {"type": IpAddressVirtualSecondaries},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_igmp": {"type": bool},
            "ip_igmp_version": {"type": int},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "ip_helpers": {"type": IpHelpers},
            "ip_dhcp_relay_all_subnets": {"type": bool},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_virtuals": {"type": Ipv6AddressVirtuals},
            "ipv6_address_link_local": {"type": str},
            "ipv6_virtual_router_addresses": {"type": Ipv6VirtualRouterAddresses},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_other_config_flag": {"type": bool},
            "ipv6_nd_cache": {"type": Ipv6NdCache},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "ipv6_dhcp_relay_all_subnets": {"type": bool},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_authentication": {"type": IsisAuthentication},
            "mtu": {"type": int},
            "no_autostate": {"type": bool},
            "vrrp_ids": {"type": VrrpIds},
            "ip_attached_host_route_export": {"type": IpAttachedHostRouteExport},
            "ipv6_attached_host_route_export": {"type": Ipv6AttachedHostRouteExport},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "pvlan_mapping": {"type": str},
            "tenant": {"type": str},
            "tags": {"type": Tags},
            "type": {"type": str},
            "eos_cli": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """VLAN interface name like "Vlan123"."""
        description: str | None
        logging: Logging
        """Subclass of AvdModel."""
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        arp_aging_timeout: int | None
        """In seconds."""
        arp_cache_dynamic_capacity: int | None
        arp_gratuitous_accept: bool | None
        arp_monitor_mac_address: bool | None
        ip_proxy_arp: bool | None
        ip_directed_broadcast: bool | None
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: IpAddressSecondaries
        """Subclass of AvdList with `str` items."""
        ip_virtual_router_addresses: IpVirtualRouterAddresses
        """Subclass of AvdList with `str` items."""
        ip_address_virtual: str | None
        """IPv4_address/Mask."""
        ip_address_virtual_secondaries: IpAddressVirtualSecondaries
        """Subclass of AvdList with `str` items."""
        ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None
        ip_igmp: bool | None
        ip_igmp_version: int | None
        ip_igmp_host_proxy: IpIgmpHostProxy
        """Subclass of AvdModel."""
        ip_helpers: IpHelpers
        """
        List of DHCP servers.

        Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is
        `ip_helper` (`str`).
        """
        ip_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        ip_nat: IpNat
        """Subclass of AvdModel."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ipv6_address_virtuals: Ipv6AddressVirtuals
        """
        The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.

        Subclass of AvdList
        with `str` items.
        """
        ipv6_address_link_local: str | None
        """IPv6_address/Mask."""
        ipv6_virtual_router_addresses: Ipv6VirtualRouterAddresses
        """
        Improved "VARPv6" data model to support multiple VARPv6 addresses.

        Subclass of AvdList with `str`
        items.
        """
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_other_config_flag: bool | None
        """Set the "other stateful configuration" flag in IPv6 router advertisements."""
        ipv6_nd_cache: Ipv6NdCache
        """
        IPv6 neighbor cache options.

        Subclass of AvdModel.
        """
        ipv6_nd_prefixes: Ipv6NdPrefixes
        """Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`)."""
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        """
        Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
        (`str`).
        """
        ipv6_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        access_group_in: str | None
        """IPv4 access-list name."""
        access_group_out: str | None
        """IPv4 access-list name."""
        ipv6_access_group_in: str | None
        """IPv6 access-list name."""
        ipv6_access_group_out: str | None
        """IPv6 access-list name."""
        multicast: Multicast
        """Subclass of AvdModel."""
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: Literal["none", "simple", "message-digest"] | None
        ospf_authentication_key: str | None
        """Encrypted password used for simple authentication."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """
        Keys used for message-digest authentication.

        Subclass of AvdIndexedList with
        `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
        """
        pim: Pim
        """Subclass of AvdModel."""
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_authentication: IsisAuthentication
        """Subclass of AvdModel."""
        mtu: int | None
        no_autostate: bool | None
        vrrp_ids: VrrpIds
        """
        Improved "vrrp" data model to support multiple VRRP IDs.

        Subclass of AvdIndexedList with
        `VrrpIdsItem` items. Primary key is `id` (`int`).
        """
        ip_attached_host_route_export: IpAttachedHostRouteExport
        """Subclass of AvdModel."""
        ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport
        """Subclass of AvdModel."""
        bfd: Bfd
        """Subclass of AvdModel."""
        service_policy: ServicePolicy
        """Subclass of AvdModel."""
        pvlan_mapping: str | None
        """List of VLANs as string."""
        tenant: str | None
        """Key only used for documentation or validation purposes."""
        tags: Tags
        """
        Key only used for documentation or validation purposes.

        Subclass of AvdList with `str` items.
        """
        type: str | None
        """Key only used for documentation or validation purposes."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                logging: Logging | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                arp_aging_timeout: int | None | UndefinedType = Undefined,
                arp_cache_dynamic_capacity: int | None | UndefinedType = Undefined,
                arp_gratuitous_accept: bool | None | UndefinedType = Undefined,
                arp_monitor_mac_address: bool | None | UndefinedType = Undefined,
                ip_proxy_arp: bool | None | UndefinedType = Undefined,
                ip_directed_broadcast: bool | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ip_address_secondaries: IpAddressSecondaries | UndefinedType = Undefined,
                ip_virtual_router_addresses: IpVirtualRouterAddresses | UndefinedType = Undefined,
                ip_address_virtual: str | None | UndefinedType = Undefined,
                ip_address_virtual_secondaries: IpAddressVirtualSecondaries | UndefinedType = Undefined,
                ip_verify_unicast_source_reachable_via: Literal["any", "rx"] | None | UndefinedType = Undefined,
                ip_igmp: bool | None | UndefinedType = Undefined,
                ip_igmp_version: int | None | UndefinedType = Undefined,
                ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
                ip_helpers: IpHelpers | UndefinedType = Undefined,
                ip_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
                ip_nat: IpNat | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_address_virtuals: Ipv6AddressVirtuals | UndefinedType = Undefined,
                ipv6_address_link_local: str | None | UndefinedType = Undefined,
                ipv6_virtual_router_addresses: Ipv6VirtualRouterAddresses | UndefinedType = Undefined,
                ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
                ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_other_config_flag: bool | None | UndefinedType = Undefined,
                ipv6_nd_cache: Ipv6NdCache | UndefinedType = Undefined,
                ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
                ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
                ipv6_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
                access_group_in: str | None | UndefinedType = Undefined,
                access_group_out: str | None | UndefinedType = Undefined,
                ipv6_access_group_in: str | None | UndefinedType = Undefined,
                ipv6_access_group_out: str | None | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
                ospf_area: str | None | UndefinedType = Undefined,
                ospf_cost: int | None | UndefinedType = Undefined,
                ospf_authentication: Literal["none", "simple", "message-digest"] | None | UndefinedType = Undefined,
                ospf_authentication_key: str | None | UndefinedType = Undefined,
                ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
                pim: Pim | UndefinedType = Undefined,
                isis_enable: str | None | UndefinedType = Undefined,
                isis_bfd: bool | None | UndefinedType = Undefined,
                isis_passive: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_network_point_to_point: bool | None | UndefinedType = Undefined,
                isis_authentication: IsisAuthentication | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                no_autostate: bool | None | UndefinedType = Undefined,
                vrrp_ids: VrrpIds | UndefinedType = Undefined,
                ip_attached_host_route_export: IpAttachedHostRouteExport | UndefinedType = Undefined,
                ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport | UndefinedType = Undefined,
                bfd: Bfd | UndefinedType = Undefined,
                service_policy: ServicePolicy | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                tags: Tags | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VlanInterfacesItem.


                Subclass of AvdModel.

                Args:
                    name: VLAN interface name like "Vlan123".
                    description: description
                    logging: Subclass of AvdModel.
                    shutdown: shutdown
                    vrf: VRF name.
                    arp_aging_timeout: In seconds.
                    arp_cache_dynamic_capacity: arp_cache_dynamic_capacity
                    arp_gratuitous_accept: arp_gratuitous_accept
                    arp_monitor_mac_address: arp_monitor_mac_address
                    ip_proxy_arp: ip_proxy_arp
                    ip_directed_broadcast: ip_directed_broadcast
                    ip_address: IPv4_address/Mask.
                    ip_address_secondaries: Subclass of AvdList with `str` items.
                    ip_virtual_router_addresses: Subclass of AvdList with `str` items.
                    ip_address_virtual: IPv4_address/Mask.
                    ip_address_virtual_secondaries: Subclass of AvdList with `str` items.
                    ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                    ip_igmp: ip_igmp
                    ip_igmp_version: ip_igmp_version
                    ip_igmp_host_proxy: Subclass of AvdModel.
                    ip_helpers:
                       List of DHCP servers.

                       Subclass of AvdIndexedList with `IpHelpersItem` items. Primary key is
                       `ip_helper` (`str`).
                    ip_dhcp_relay_all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                    ip_nat: Subclass of AvdModel.
                    ipv6_enable: ipv6_enable
                    ipv6_address: IPv6_address/Mask.
                    ipv6_address_virtuals:
                       The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.

                       Subclass of AvdList
                       with `str` items.
                    ipv6_address_link_local: IPv6_address/Mask.
                    ipv6_virtual_router_addresses:
                       Improved "VARPv6" data model to support multiple VARPv6 addresses.

                       Subclass of AvdList with `str`
                       items.
                    ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                    ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                    ipv6_nd_other_config_flag: Set the "other stateful configuration" flag in IPv6 router advertisements.
                    ipv6_nd_cache:
                       IPv6 neighbor cache options.

                       Subclass of AvdModel.
                    ipv6_nd_prefixes: Subclass of AvdIndexedList with `Ipv6NdPrefixesItem` items. Primary key is `ipv6_prefix` (`str`).
                    ipv6_dhcp_relay_destinations:
                       Subclass of AvdIndexedList with `Ipv6DhcpRelayDestinationsItem` items. Primary key is `address`
                       (`str`).
                    ipv6_dhcp_relay_all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                    access_group_in: IPv4 access-list name.
                    access_group_out: IPv4 access-list name.
                    ipv6_access_group_in: IPv6 access-list name.
                    ipv6_access_group_out: IPv6 access-list name.
                    multicast: Subclass of AvdModel.
                    ospf_network_point_to_point: ospf_network_point_to_point
                    ospf_area: ospf_area
                    ospf_cost: ospf_cost
                    ospf_authentication: ospf_authentication
                    ospf_authentication_key: Encrypted password used for simple authentication.
                    ospf_message_digest_keys:
                       Keys used for message-digest authentication.

                       Subclass of AvdIndexedList with
                       `OspfMessageDigestKeysItem` items. Primary key is `id` (`int`).
                    pim: Subclass of AvdModel.
                    isis_enable: ISIS instance name.
                    isis_bfd: Enable BFD for ISIS.
                    isis_passive: isis_passive
                    isis_metric: isis_metric
                    isis_network_point_to_point: isis_network_point_to_point
                    isis_authentication: Subclass of AvdModel.
                    mtu: mtu
                    no_autostate: no_autostate
                    vrrp_ids:
                       Improved "vrrp" data model to support multiple VRRP IDs.

                       Subclass of AvdIndexedList with
                       `VrrpIdsItem` items. Primary key is `id` (`int`).
                    ip_attached_host_route_export: Subclass of AvdModel.
                    ipv6_attached_host_route_export: Subclass of AvdModel.
                    bfd: Subclass of AvdModel.
                    service_policy: Subclass of AvdModel.
                    pvlan_mapping: List of VLANs as string.
                    tenant: Key only used for documentation or validation purposes.
                    tags:
                       Key only used for documentation or validation purposes.

                       Subclass of AvdList with `str` items.
                    type: Key only used for documentation or validation purposes.
                    eos_cli: Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration.
                    _custom_data: _custom_data

                """

    class VlanInterfaces(AvdIndexedList[str, VlanInterfacesItem]):
        """Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VlanInterfaces._item_type = VlanInterfacesItem

    class VlanInternalOrder(AvdModel):
        """Subclass of AvdModel."""

        class Range(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"beginning": {"type": int}, "ending": {"type": int}, "_custom_data": {"type": dict}}
            beginning: int
            """First VLAN ID."""
            ending: int
            """Last VLAN ID."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    beginning: int | UndefinedType = Undefined,
                    ending: int | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Range.


                    Subclass of AvdModel.

                    Args:
                        beginning: First VLAN ID.
                        ending: Last VLAN ID.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"allocation": {"type": str}, "range": {"type": Range}, "_custom_data": {"type": dict}}
        allocation: Literal["ascending", "descending"]
        range: Range
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                allocation: Literal["ascending", "descending"] | UndefinedType = Undefined,
                range: Range | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VlanInternalOrder.


                Subclass of AvdModel.

                Args:
                    allocation: allocation
                    range: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    class VlansItem(AvdModel):
        """Subclass of AvdModel."""

        class AddressLocking(AvdModel):
            """Subclass of AvdModel."""

            class AddressFamily(AvdModel):
                """Subclass of AvdModel."""

                _fields: ClassVar[dict] = {"ipv4": {"type": bool}, "ipv6": {"type": bool}, "_custom_data": {"type": dict}}
                ipv4: bool | None
                """Enable address locking for IPv4."""
                ipv6: bool | None
                """Enable address locking for IPv6."""
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        ipv4: bool | None | UndefinedType = Undefined,
                        ipv6: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AddressFamily.


                        Subclass of AvdModel.

                        Args:
                            ipv4: Enable address locking for IPv4.
                            ipv6: Enable address locking for IPv6.
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"address_family": {"type": AddressFamily}, "ipv4_enforcement_disabled": {"type": bool}, "_custom_data": {"type": dict}}
            address_family: AddressFamily
            """Subclass of AvdModel."""
            ipv4_enforcement_disabled: bool | None
            """Disable enforcement for IPv4 locked addresses."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    address_family: AddressFamily | UndefinedType = Undefined,
                    ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressLocking.


                    Subclass of AvdModel.

                    Args:
                        address_family: Subclass of AvdModel.
                        ipv4_enforcement_disabled: Disable enforcement for IPv4 locked addresses.
                        _custom_data: _custom_data

                    """

        class TrunkGroups(AvdList[str]):
            """Subclass of AvdList with `str` items."""

        TrunkGroups._item_type = str

        class PrivateVlan(AvdModel):
            """Subclass of AvdModel."""

            _fields: ClassVar[dict] = {"type": {"type": str}, "primary_vlan": {"type": int}, "_custom_data": {"type": dict}}
            type: Literal["community", "isolated"] | None
            primary_vlan: int | None
            """Primary VLAN ID."""
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    type: Literal["community", "isolated"] | None | UndefinedType = Undefined,
                    primary_vlan: int | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrivateVlan.


                    Subclass of AvdModel.

                    Args:
                        type: type
                        primary_vlan: Primary VLAN ID.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {
            "id": {"type": int},
            "name": {"type": str},
            "state": {"type": str},
            "address_locking": {"type": AddressLocking},
            "trunk_groups": {"type": TrunkGroups},
            "private_vlan": {"type": PrivateVlan},
            "tenant": {"type": str},
            "_custom_data": {"type": dict},
        }
        id: int
        """VLAN ID."""
        name: str | None
        """VLAN Name."""
        state: Literal["active", "suspend"] | None
        address_locking: AddressLocking
        """Subclass of AvdModel."""
        trunk_groups: TrunkGroups
        """Subclass of AvdList with `str` items."""
        private_vlan: PrivateVlan
        """Subclass of AvdModel."""
        tenant: str | None
        """Key only used for documentation or validation purposes."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                id: int | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                state: Literal["active", "suspend"] | None | UndefinedType = Undefined,
                address_locking: AddressLocking | UndefinedType = Undefined,
                trunk_groups: TrunkGroups | UndefinedType = Undefined,
                private_vlan: PrivateVlan | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VlansItem.


                Subclass of AvdModel.

                Args:
                    id: VLAN ID.
                    name: VLAN Name.
                    state: state
                    address_locking: Subclass of AvdModel.
                    trunk_groups: Subclass of AvdList with `str` items.
                    private_vlan: Subclass of AvdModel.
                    tenant: Key only used for documentation or validation purposes.
                    _custom_data: _custom_data

                """

    class Vlans(AvdIndexedList[int, VlansItem]):
        """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

        _primary_key: ClassVar[str] = "id"

    Vlans._item_type = VlansItem

    class VmtracerSessionsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "url": {"type": str},
            "username": {"type": str},
            "password": {"type": str},
            "autovlan_disable": {"type": bool},
            "vrf": {"type": str},
            "source_interface": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """Vmtracer Session Name."""
        url: str | None
        username: str | None
        password: str | None
        """Type 7 Password Hash."""
        autovlan_disable: bool | None
        vrf: str | None
        source_interface: str | None
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
                username: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                autovlan_disable: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VmtracerSessionsItem.


                Subclass of AvdModel.

                Args:
                    name: Vmtracer Session Name.
                    url: url
                    username: username
                    password: Type 7 Password Hash.
                    autovlan_disable: autovlan_disable
                    vrf: vrf
                    source_interface: source_interface
                    _custom_data: _custom_data

                """

    class VmtracerSessions(AvdIndexedList[str, VmtracerSessionsItem]):
        """Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    VmtracerSessions._item_type = VmtracerSessionsItem

    class VrfsItem(AvdModel):
        """Subclass of AvdModel."""

        _fields: ClassVar[dict] = {
            "name": {"type": str},
            "description": {"type": str},
            "ip_routing": {"type": bool},
            "ipv6_routing": {"type": bool},
            "ip_routing_ipv6_interfaces": {"type": bool},
            "tenant": {"type": str},
            "_custom_data": {"type": dict},
        }
        name: str
        """VRF Name."""
        description: str | None
        ip_routing: bool | None
        ipv6_routing: bool | None
        ip_routing_ipv6_interfaces: bool | None
        tenant: str | None
        """Key only used for documentation or validation purposes."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                ip_routing: bool | None | UndefinedType = Undefined,
                ipv6_routing: bool | None | UndefinedType = Undefined,
                ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.


                Subclass of AvdModel.

                Args:
                    name: VRF Name.
                    description: description
                    ip_routing: ip_routing
                    ipv6_routing: ipv6_routing
                    ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                    tenant: Key only used for documentation or validation purposes.
                    _custom_data: _custom_data

                """

    class Vrfs(AvdIndexedList[str, VrfsItem]):
        """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

        _primary_key: ClassVar[str] = "name"

    Vrfs._item_type = VrfsItem

    class VxlanInterface(AvdModel):
        """Subclass of AvdModel."""

        class Vxlan1(AvdModel):
            """Subclass of AvdModel."""

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                class Multicast(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"headend_replication": {"type": bool}, "_custom_data": {"type": dict}}
                    headend_replication: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, headend_replication: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Multicast.


                            Subclass of AvdModel.

                            Args:
                                headend_replication: headend_replication
                                _custom_data: _custom_data

                            """

                class ControllerClient(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, enabled: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            ControllerClient.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                _custom_data: _custom_data

                            """

                class BfdVtepEvpn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "interval": {"type": int},
                        "min_rx": {"type": int},
                        "multiplier": {"type": int},
                        "prefix_list": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | None | UndefinedType = Undefined,
                            min_rx: int | None | UndefinedType = Undefined,
                            multiplier: int | None | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdVtepEvpn.


                            Subclass of AvdModel.

                            Args:
                                interval: interval
                                min_rx: min_rx
                                multiplier: multiplier
                                prefix_list: prefix_list
                                _custom_data: _custom_data

                            """

                class Qos(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                            ecn_propagation: bool | None | UndefinedType = Undefined,
                            map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Qos.


                            Subclass of AvdModel.

                            Args:
                                dscp_propagation_encapsulation: dscp_propagation_encapsulation
                                ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                                map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation
                                _custom_data: _custom_data

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    class FloodVteps(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    FloodVteps._item_type = str

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": FloodVteps},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: FloodVteps
                    """Subclass of AvdList with `str` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            flood_vteps: FloodVteps | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                id: VLAN ID.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                flood_vteps: Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Vlans(AvdIndexedList[int, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "vni": {"type": int}, "multicast_group": {"type": str}, "_custom_data": {"type": dict}}
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VrfsItem.


                            Subclass of AvdModel.

                            Args:
                                name: VRF Name.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                _custom_data: _custom_data

                            """

                class Vrfs(AvdIndexedList[str, VrfsItem]):
                    """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                class FloodVteps(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                FloodVteps._item_type = str

                _fields: ClassVar[dict] = {
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": FloodVteps},
                    "flood_vtep_learned_data_plane": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                """Subclass of AvdModel."""
                controller_client: ControllerClient
                """
                Client to CVX Controllers.

                Subclass of AvdModel.
                """
                mlag_source_interface: str | None
                udp_port: int | None
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                """Subclass of AvdModel."""
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                Subclass of AvdModel.
                """
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
                vrfs: Vrfs
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
                flood_vteps: FloodVteps
                """Subclass of AvdList with `str` items."""
                flood_vtep_learned_data_plane: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_interface: str | None | UndefinedType = Undefined,
                        multicast: Multicast | UndefinedType = Undefined,
                        controller_client: ControllerClient | UndefinedType = Undefined,
                        mlag_source_interface: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                        vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                        virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                        bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                        qos: Qos | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        vrfs: Vrfs | UndefinedType = Undefined,
                        flood_vteps: FloodVteps | UndefinedType = Undefined,
                        flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            source_interface: Source Interface Name.
                            multicast: Subclass of AvdModel.
                            controller_client:
                               Client to CVX Controllers.

                               Subclass of AvdModel.
                            mlag_source_interface: mlag_source_interface
                            udp_port: udp_port
                            vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                            virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                            bfd_vtep_evpn: Subclass of AvdModel.
                            qos:
                               For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                               core ports must be in "DSCP Trust" mode.
                               !!!Warning, only few hardware types with software version
                               >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                               Subclass of AvdModel.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                            vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                            flood_vteps: Subclass of AvdList with `str` items.
                            flood_vtep_learned_data_plane: flood_vtep_learned_data_plane
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}, "_custom_data": {"type": dict}}
            description: str | None
            vxlan: Vxlan
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    vxlan: Vxlan | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan1.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        vxlan: Subclass of AvdModel.
                        eos_cli:
                           Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                           configuration.
                        _custom_data: _custom_data

                    """

        class Vxlan1(AvdModel):
            """Subclass of AvdModel."""

            class Vxlan(AvdModel):
                """Subclass of AvdModel."""

                class Multicast(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"headend_replication": {"type": bool}, "_custom_data": {"type": dict}}
                    headend_replication: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, headend_replication: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            Multicast.


                            Subclass of AvdModel.

                            Args:
                                headend_replication: headend_replication
                                _custom_data: _custom_data

                            """

                class ControllerClient(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"enabled": {"type": bool}, "_custom_data": {"type": dict}}
                    enabled: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self, *, enabled: bool | None | UndefinedType = Undefined, _custom_data: dict[str, Any] | UndefinedType = Undefined
                        ) -> None:
                            """
                            ControllerClient.


                            Subclass of AvdModel.

                            Args:
                                enabled: enabled
                                _custom_data: _custom_data

                            """

                class BfdVtepEvpn(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "interval": {"type": int},
                        "min_rx": {"type": int},
                        "multiplier": {"type": int},
                        "prefix_list": {"type": str},
                        "_custom_data": {"type": dict},
                    }
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            interval: int | None | UndefinedType = Undefined,
                            min_rx: int | None | UndefinedType = Undefined,
                            multiplier: int | None | UndefinedType = Undefined,
                            prefix_list: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdVtepEvpn.


                            Subclass of AvdModel.

                            Args:
                                interval: interval
                                min_rx: min_rx
                                multiplier: multiplier
                                prefix_list: prefix_list
                                _custom_data: _custom_data

                            """

                class Qos(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                        "_custom_data": {"type": dict},
                    }
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                            ecn_propagation: bool | None | UndefinedType = Undefined,
                            map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Qos.


                            Subclass of AvdModel.

                            Args:
                                dscp_propagation_encapsulation: dscp_propagation_encapsulation
                                ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                                map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation
                                _custom_data: _custom_data

                            """

                class VlansItem(AvdModel):
                    """Subclass of AvdModel."""

                    class FloodVteps(AvdList[str]):
                        """Subclass of AvdList with `str` items."""

                    FloodVteps._item_type = str

                    _fields: ClassVar[dict] = {
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": FloodVteps},
                        "_custom_data": {"type": dict},
                    }
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: FloodVteps
                    """Subclass of AvdList with `str` items."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            id: int | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            flood_vteps: FloodVteps | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VlansItem.


                            Subclass of AvdModel.

                            Args:
                                id: VLAN ID.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                flood_vteps: Subclass of AvdList with `str` items.
                                _custom_data: _custom_data

                            """

                class Vlans(AvdIndexedList[int, VlansItem]):
                    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""

                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    """Subclass of AvdModel."""

                    _fields: ClassVar[dict] = {"name": {"type": str}, "vni": {"type": int}, "multicast_group": {"type": str}, "_custom_data": {"type": dict}}
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    _custom_data: dict[str, Any]

                    if TYPE_CHECKING:

                        def __init__(
                            self,
                            *,
                            name: str | UndefinedType = Undefined,
                            vni: int | None | UndefinedType = Undefined,
                            multicast_group: str | None | UndefinedType = Undefined,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VrfsItem.


                            Subclass of AvdModel.

                            Args:
                                name: VRF Name.
                                vni: vni
                                multicast_group: IP Multicast Group Address.
                                _custom_data: _custom_data

                            """

                class Vrfs(AvdIndexedList[str, VrfsItem]):
                    """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""

                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                class FloodVteps(AvdList[str]):
                    """Subclass of AvdList with `str` items."""

                FloodVteps._item_type = str

                _fields: ClassVar[dict] = {
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": FloodVteps},
                    "flood_vtep_learned_data_plane": {"type": bool},
                    "_custom_data": {"type": dict},
                }
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                """Subclass of AvdModel."""
                controller_client: ControllerClient
                """
                Client to CVX Controllers.

                Subclass of AvdModel.
                """
                mlag_source_interface: str | None
                udp_port: int | None
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                """Subclass of AvdModel."""
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                Subclass of AvdModel.
                """
                vlans: Vlans
                """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
                vrfs: Vrfs
                """Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`)."""
                flood_vteps: FloodVteps
                """Subclass of AvdList with `str` items."""
                flood_vtep_learned_data_plane: bool | None
                _custom_data: dict[str, Any]

                if TYPE_CHECKING:

                    def __init__(
                        self,
                        *,
                        source_interface: str | None | UndefinedType = Undefined,
                        multicast: Multicast | UndefinedType = Undefined,
                        controller_client: ControllerClient | UndefinedType = Undefined,
                        mlag_source_interface: str | None | UndefinedType = Undefined,
                        udp_port: int | None | UndefinedType = Undefined,
                        vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                        virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                        bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                        qos: Qos | UndefinedType = Undefined,
                        vlans: Vlans | UndefinedType = Undefined,
                        vrfs: Vrfs | UndefinedType = Undefined,
                        flood_vteps: FloodVteps | UndefinedType = Undefined,
                        flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Vxlan.


                        Subclass of AvdModel.

                        Args:
                            source_interface: Source Interface Name.
                            multicast: Subclass of AvdModel.
                            controller_client:
                               Client to CVX Controllers.

                               Subclass of AvdModel.
                            mlag_source_interface: mlag_source_interface
                            udp_port: udp_port
                            vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                            virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                            bfd_vtep_evpn: Subclass of AvdModel.
                            qos:
                               For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                               core ports must be in "DSCP Trust" mode.
                               !!!Warning, only few hardware types with software version
                               >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.


                               Subclass of AvdModel.
                            vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                            vrfs: Subclass of AvdIndexedList with `VrfsItem` items. Primary key is `name` (`str`).
                            flood_vteps: Subclass of AvdList with `str` items.
                            flood_vtep_learned_data_plane: flood_vtep_learned_data_plane
                            _custom_data: _custom_data

                        """

            _fields: ClassVar[dict] = {"description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}, "_custom_data": {"type": dict}}
            description: str | None
            vxlan: Vxlan
            """Subclass of AvdModel."""
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """
            _custom_data: dict[str, Any]

            if TYPE_CHECKING:

                def __init__(
                    self,
                    *,
                    description: str | None | UndefinedType = Undefined,
                    vxlan: Vxlan | UndefinedType = Undefined,
                    eos_cli: str | None | UndefinedType = Undefined,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan1.


                    Subclass of AvdModel.

                    Args:
                        description: description
                        vxlan: Subclass of AvdModel.
                        eos_cli:
                           Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                           configuration.
                        _custom_data: _custom_data

                    """

        _fields: ClassVar[dict] = {"vxlan1": {"type": Vxlan1}, "field_Vxlan1": {"type": Vxlan1}, "_custom_data": {"type": dict}}
        _field_to_key_map: ClassVar[dict] = {"field_Vxlan1": "Vxlan1"}
        _key_to_field_map: ClassVar[dict] = {"Vxlan1": "field_Vxlan1"}
        vxlan1: Vxlan1
        """Subclass of AvdModel."""
        field_Vxlan1: Vxlan1
        """Subclass of AvdModel."""
        _custom_data: dict[str, Any]

        if TYPE_CHECKING:

            def __init__(
                self,
                *,
                vxlan1: Vxlan1 | UndefinedType = Undefined,
                field_Vxlan1: Vxlan1 | UndefinedType = Undefined,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ) -> None:
                """
                VxlanInterface.


                Subclass of AvdModel.

                Args:
                    vxlan1: Subclass of AvdModel.
                    field_Vxlan1: Subclass of AvdModel.
                    _custom_data: _custom_data

                """

    _fields: ClassVar[dict] = {
        "aaa_accounting": {"type": AaaAccounting},
        "aaa_authentication": {"type": AaaAuthentication},
        "aaa_authorization": {"type": AaaAuthorization},
        "aaa_root": {"type": AaaRoot},
        "aaa_server_groups": {"type": AaaServerGroups},
        "access_lists": {"type": AccessLists},
        "address_locking": {"type": AddressLocking},
        "agents": {"type": Agents},
        "aliases": {"type": str},
        "application_traffic_recognition": {"type": ApplicationTrafficRecognition},
        "arp": {"type": Arp},
        "as_path": {"type": AsPath},
        "avd_data_validation_mode": {"type": str, "default": "error"},
        "banners": {"type": Banners},
        "bgp_groups": {"type": BgpGroups},
        "boot": {"type": Boot},
        "class_maps": {"type": ClassMaps},
        "clock": {"type": Clock},
        "community_lists": {"type": CommunityLists},
        "config_comment": {"type": str},
        "config_end": {"type": bool, "default": False},
        "custom_templates": {"type": CustomTemplates},
        "cvx": {"type": Cvx},
        "daemon_terminattr": {"type": DaemonTerminattr},
        "daemons": {"type": Daemons},
        "dhcp_relay": {"type": DhcpRelay},
        "dhcp_servers": {"type": DhcpServers},
        "dns_domain": {"type": str},
        "domain_list": {"type": DomainList},
        "dot1x": {"type": Dot1x},
        "dps_interfaces": {"type": DpsInterfaces},
        "dynamic_prefix_lists": {"type": DynamicPrefixLists},
        "enable_password": {"type": EnablePassword},
        "eos_cli": {"type": str},
        "eos_cli_config_gen_configuration": {"type": EosCliConfigGenConfiguration},
        "eos_cli_config_gen_documentation": {"type": EosCliConfigGenDocumentation},
        "errdisable": {"type": Errdisable},
        "ethernet_interfaces": {"type": EthernetInterfaces},
        "event_handlers": {"type": EventHandlers},
        "event_monitor": {"type": EventMonitor},
        "flow_tracking": {"type": FlowTracking},
        "generate_default_config": {"type": bool, "default": False},
        "generate_device_documentation": {"type": bool, "default": True},
        "hardware": {"type": Hardware},
        "hardware_counters": {"type": HardwareCounters},
        "hostname": {"type": str},
        "interface_defaults": {"type": InterfaceDefaults},
        "interface_groups": {"type": InterfaceGroups},
        "interface_profiles": {"type": InterfaceProfiles},
        "ip_access_lists": {"type": IpAccessLists},
        "ip_access_lists_max_entries": {"type": int},
        "ip_community_lists": {"type": IpCommunityLists},
        "ip_dhcp_relay": {"type": IpDhcpRelay},
        "ip_dhcp_snooping": {"type": IpDhcpSnooping},
        "ip_domain_lookup": {"type": IpDomainLookup},
        "ip_extcommunity_lists": {"type": IpExtcommunityLists},
        "ip_extcommunity_lists_regexp": {"type": IpExtcommunityListsRegexp},
        "ip_ftp_client_source_interfaces": {"type": IpFtpClientSourceInterfaces},
        "ip_hardware": {"type": IpHardware},
        "ip_http_client_source_interfaces": {"type": IpHttpClientSourceInterfaces},
        "ip_icmp_redirect": {"type": bool},
        "ip_igmp_snooping": {"type": IpIgmpSnooping},
        "ip_name_servers": {"type": IpNameServers},
        "ip_nat": {"type": IpNat},
        "ip_radius_source_interfaces": {"type": IpRadiusSourceInterfaces},
        "ip_routing": {"type": bool},
        "ip_routing_ipv6_interfaces": {"type": bool},
        "ip_security": {"type": IpSecurity},
        "ip_ssh_client_source_interfaces": {"type": IpSshClientSourceInterfaces},
        "ip_tacacs_source_interfaces": {"type": IpTacacsSourceInterfaces},
        "ip_telnet_client_source_interfaces": {"type": IpTelnetClientSourceInterfaces},
        "ip_tftp_client_source_interfaces": {"type": IpTftpClientSourceInterfaces},
        "ip_virtual_router_mac_address": {"type": str},
        "ipv6_access_lists": {"type": Ipv6AccessLists},
        "ipv6_dhcp_relay": {"type": Ipv6DhcpRelay},
        "ipv6_hardware": {"type": Ipv6Hardware},
        "ipv6_icmp_redirect": {"type": bool},
        "ipv6_neighbor": {"type": Ipv6Neighbor},
        "ipv6_prefix_lists": {"type": Ipv6PrefixLists},
        "ipv6_standard_access_lists": {"type": Ipv6StandardAccessLists},
        "ipv6_static_routes": {"type": Ipv6StaticRoutes},
        "ipv6_unicast_routing": {"type": bool},
        "is_deployed": {"type": bool, "default": True},
        "l2_protocol": {"type": L2Protocol},
        "lacp": {"type": Lacp},
        "link_tracking_groups": {"type": LinkTrackingGroups},
        "lldp": {"type": Lldp},
        "load_interval": {"type": LoadInterval},
        "local_users": {"type": LocalUsers},
        "logging": {"type": Logging},
        "loopback_interfaces": {"type": LoopbackInterfaces},
        "mac_access_lists": {"type": MacAccessLists},
        "mac_address_table": {"type": MacAddressTable},
        "mac_security": {"type": MacSecurity},
        "maintenance": {"type": Maintenance},
        "management_accounts": {"type": ManagementAccounts},
        "management_api_gnmi": {"type": ManagementApiGnmi},
        "management_api_http": {"type": ManagementApiHttp},
        "management_api_models": {"type": ManagementApiModels},
        "management_console": {"type": ManagementConsole},
        "management_cvx": {"type": ManagementCvx},
        "management_defaults": {"type": ManagementDefaults},
        "management_interfaces": {"type": ManagementInterfaces},
        "management_security": {"type": ManagementSecurity},
        "management_ssh": {"type": ManagementSsh},
        "management_tech_support": {"type": ManagementTechSupport},
        "match_list_input": {"type": MatchListInput},
        "mcs_client": {"type": McsClient},
        "metadata": {"type": Metadata},
        "mlag_configuration": {"type": MlagConfiguration},
        "monitor_connectivity": {"type": MonitorConnectivity},
        "monitor_layer1": {"type": MonitorLayer1},
        "monitor_server_radius": {"type": MonitorServerRadius},
        "monitor_session_default_encapsulation_gre": {"type": MonitorSessionDefaultEncapsulationGre},
        "monitor_sessions": {"type": MonitorSessions},
        "monitor_telemetry_influx": {"type": MonitorTelemetryInflux},
        "monitor_telemetry_postcard_policy": {"type": MonitorTelemetryPostcardPolicy},
        "mpls": {"type": Mpls},
        "ntp": {"type": Ntp},
        "patch_panel": {"type": PatchPanel},
        "peer_filters": {"type": PeerFilters},
        "platform": {"type": Platform},
        "poe": {"type": Poe},
        "policy_maps": {"type": PolicyMaps},
        "port_channel_interfaces": {"type": PortChannelInterfaces},
        "prefix_lists": {"type": PrefixLists},
        "priority_flow_control": {"type": PriorityFlowControl},
        "prompt": {"type": str},
        "ptp": {"type": Ptp},
        "qos": {"type": Qos},
        "qos_profiles": {"type": QosProfiles},
        "queue_monitor_length": {"type": QueueMonitorLength},
        "queue_monitor_streaming": {"type": QueueMonitorStreaming},
        "radius_server": {"type": RadiusServer},
        "redundancy": {"type": Redundancy},
        "roles": {"type": Roles},
        "route_maps": {"type": RouteMaps},
        "router_adaptive_virtual_topology": {"type": RouterAdaptiveVirtualTopology},
        "router_bfd": {"type": RouterBfd},
        "router_bgp": {"type": RouterBgp},
        "router_general": {"type": RouterGeneral},
        "router_igmp": {"type": RouterIgmp},
        "router_internet_exit": {"type": RouterInternetExit},
        "router_isis": {"type": RouterIsis},
        "router_l2_vpn": {"type": RouterL2Vpn},
        "router_msdp": {"type": RouterMsdp},
        "router_multicast": {"type": RouterMulticast},
        "router_ospf": {"type": RouterOspf},
        "router_path_selection": {"type": RouterPathSelection},
        "router_pim_sparse_mode": {"type": RouterPimSparseMode},
        "router_segment_security": {"type": RouterSegmentSecurity},
        "router_service_insertion": {"type": RouterServiceInsertion},
        "router_traffic_engineering": {"type": RouterTrafficEngineering},
        "service_routing_configuration_bgp": {"type": ServiceRoutingConfigurationBgp},
        "service_routing_protocols_model": {"type": str},
        "service_unsupported_transceiver": {"type": ServiceUnsupportedTransceiver},
        "sflow": {"type": Sflow},
        "snmp_server": {"type": SnmpServer},
        "spanning_tree": {"type": SpanningTree},
        "standard_access_lists": {"type": StandardAccessLists},
        "static_routes": {"type": StaticRoutes},
        "stun": {"type": Stun},
        "switchport_default": {"type": SwitchportDefault},
        "switchport_port_security": {"type": SwitchportPortSecurity},
        "sync_e": {"type": SyncE},
        "system": {"type": System},
        "tacacs_servers": {"type": TacacsServers},
        "tap_aggregation": {"type": TapAggregation},
        "tcam_profile": {"type": TcamProfile},
        "terminal": {"type": Terminal},
        "trackers": {"type": Trackers},
        "traffic_policies": {"type": TrafficPolicies},
        "transceiver_qsfp_default_mode_4x10": {"type": bool, "default": True},
        "tunnel_interfaces": {"type": TunnelInterfaces},
        "virtual_source_nat_vrfs": {"type": VirtualSourceNatVrfs},
        "vlan_interfaces": {"type": VlanInterfaces},
        "vlan_internal_order": {"type": VlanInternalOrder},
        "vlans": {"type": Vlans},
        "vmtracer_sessions": {"type": VmtracerSessions},
        "vrfs": {"type": Vrfs},
        "vxlan_interface": {"type": VxlanInterface},
        "_custom_data": {"type": dict},
    }
    _allow_other_keys: ClassVar[bool] = True
    aaa_accounting: AaaAccounting
    """Subclass of AvdModel."""
    aaa_authentication: AaaAuthentication
    """Subclass of AvdModel."""
    aaa_authorization: AaaAuthorization
    """Subclass of AvdModel."""
    aaa_root: AaaRoot
    """Subclass of AvdModel."""
    aaa_server_groups: AaaServerGroups
    """Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`)."""
    access_lists: AccessLists
    """Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`)."""
    address_locking: AddressLocking
    """Subclass of AvdModel."""
    agents: Agents
    """Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`)."""
    aliases: str | None
    """
    Multi-line string with one or more alias commands.

    Example:

    ```yaml
    aliases: |
      alias wr copy
    running-config startup-config
      alias siib show ip interface brief
    ```
    """
    application_traffic_recognition: ApplicationTrafficRecognition
    """
    Application traffic recognition configuration.

    Subclass of AvdModel.
    """
    arp: Arp
    """Subclass of AvdModel."""
    as_path: AsPath
    """Subclass of AvdModel."""
    avd_data_validation_mode: Literal["error", "warning"]
    """
    Validation Mode for AVD input data validation.
    Input data validation will validate the input
    variables according to the schema.
    During validation, messages will generated with information about
    the host(s) and key(s) which failed validation.
    "error" will produce error messages and fail the
    task.
    "warning" will produce warning messages.

    Default value: `"error"`
    """
    banners: Banners
    """Subclass of AvdModel."""
    bgp_groups: BgpGroups
    """Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`)."""
    boot: Boot
    """
    Set the Aboot password.


    Subclass of AvdModel.
    """
    class_maps: ClassMaps
    """Subclass of AvdModel."""
    clock: Clock
    """Subclass of AvdModel."""
    community_lists: CommunityLists
    """Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`)."""
    config_comment: str | None
    """
    Add a comment to provide information about the configuration.
    This comment will be rendered at the
    top of the generated configuration.
    """
    config_end: bool
    """
    Render `end` at the end of the configuration.

    Default value: `False`
    """
    custom_templates: CustomTemplates
    """
    - Custom templates can be added below the playbook directory.
    - If a location above the directory is
    desired, a symbolic link can be used.
    - Example under the `playbooks` directory create symbolic link
    with the following command:

      ```bash
      ln -s ../../shared_repo/custom_avd_templates/
    ./custom_avd_templates
      ```

    - The output will be rendered at the end of the configuration.
    - The
    order of custom templates in the list can be important if they overlap.
    - It is recommended to use a
    `!` delimiter at the top of each custom template.

    Add `custom_templates` to group/host variables:
    Subclass of AvdList with `str` items.
    """
    cvx: Cvx
    """
    CVX server features are not supported on physical switches. See `management_cvx` for client
    configurations.

    Subclass of AvdModel.
    """
    daemon_terminattr: DaemonTerminattr
    """
    You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
    for your Cloudvision as a Service instance.
    Streaming to multiple clusters both on-prem and cloud
    service is supported.

    !!! note
        For TerminAttr version recommendation and EOS compatibility
    matrix, please refer to the latest TerminAttr Release Notes
        which always contain the latest
    recommended versions and minimum required versions per EOS release.


    Subclass of AvdModel.
    """
    daemons: Daemons
    """
    This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
    clients like ocprometheus.

    Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is
    `name` (`str`).
    """
    dhcp_relay: DhcpRelay
    """Subclass of AvdModel."""
    dhcp_servers: DhcpServers
    """Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`)."""
    dns_domain: str | None
    """Domain Name."""
    domain_list: DomainList
    """
    Search list of DNS domains.

    Subclass of AvdList with `str` items.
    """
    dot1x: Dot1x
    """Subclass of AvdModel."""
    dps_interfaces: DpsInterfaces
    """Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`)."""
    dynamic_prefix_lists: DynamicPrefixLists
    """Subclass of AvdList with `DynamicPrefixListsItem` items."""
    enable_password: EnablePassword
    """Subclass of AvdModel."""
    eos_cli: str | None
    """Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration."""
    eos_cli_config_gen_configuration: EosCliConfigGenConfiguration
    """Subclass of AvdModel."""
    eos_cli_config_gen_documentation: EosCliConfigGenDocumentation
    """Subclass of AvdModel."""
    errdisable: Errdisable
    """Subclass of AvdModel."""
    ethernet_interfaces: EthernetInterfaces
    """Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`)."""
    event_handlers: EventHandlers
    """
    Gives the ability to monitor and react to Syslog messages.
    Event Handlers provide a powerful and
    flexible tool that can be used to apply self-healing actions,
    customize the system behavior, and
    implement workarounds to problems discovered in the field.


    Subclass of AvdIndexedList with
    `EventHandlersItem` items. Primary key is `name` (`str`).
    """
    event_monitor: EventMonitor
    """Subclass of AvdModel."""
    flow_tracking: FlowTracking
    """Subclass of AvdModel."""
    generate_default_config: bool
    """
    The `generate_default_config` knob allows to omit default EOS configuration.
    This can be useful when
    leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

    The following commands
    will be omitted when `generate_default_config` is set to `false`:

    - RANCID Content Type
    - Hostname
    (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
    -
    Default configuration for `aaa`
    - Default configuration for `enable password`
    - Transceiver qsfp
    default mode
    - End of configuration delimiter

    Default value: `False`
    """
    generate_device_documentation: bool
    """Default value: `True`"""
    hardware: Hardware
    """Subclass of AvdModel."""
    hardware_counters: HardwareCounters
    """Subclass of AvdModel."""
    hostname: str | None
    interface_defaults: InterfaceDefaults
    """Subclass of AvdModel."""
    interface_groups: InterfaceGroups
    """Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`)."""
    interface_profiles: InterfaceProfiles
    """Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`)."""
    ip_access_lists: IpAccessLists
    """Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`)."""
    ip_access_lists_max_entries: int | None
    """Limit ACL entries defined under the `ip_access_lists`."""
    ip_community_lists: IpCommunityLists
    """
    Communities and regexp entries MUST not be configured in the same community-list.


    Subclass of
    AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`).
    """
    ip_dhcp_relay: IpDhcpRelay
    """Subclass of AvdModel."""
    ip_dhcp_snooping: IpDhcpSnooping
    """Subclass of AvdModel."""
    ip_domain_lookup: IpDomainLookup
    """Subclass of AvdModel."""
    ip_extcommunity_lists: IpExtcommunityLists
    """Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`)."""
    ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp
    """
    Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
    (`str`).
    """
    ip_ftp_client_source_interfaces: IpFtpClientSourceInterfaces
    """Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items."""
    ip_hardware: IpHardware
    """Subclass of AvdModel."""
    ip_http_client_source_interfaces: IpHttpClientSourceInterfaces
    """Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items."""
    ip_icmp_redirect: bool | None
    ip_igmp_snooping: IpIgmpSnooping
    """Subclass of AvdModel."""
    ip_name_servers: IpNameServers
    """Subclass of AvdList with `IpNameServersItem` items."""
    ip_nat: IpNat
    """Subclass of AvdModel."""
    ip_radius_source_interfaces: IpRadiusSourceInterfaces
    """Subclass of AvdList with `IpRadiusSourceInterfacesItem` items."""
    ip_routing: bool | None
    ip_routing_ipv6_interfaces: bool | None
    ip_security: IpSecurity
    """Subclass of AvdModel."""
    ip_ssh_client_source_interfaces: IpSshClientSourceInterfaces
    """Subclass of AvdList with `IpSshClientSourceInterfacesItem` items."""
    ip_tacacs_source_interfaces: IpTacacsSourceInterfaces
    """Subclass of AvdList with `IpTacacsSourceInterfacesItem` items."""
    ip_telnet_client_source_interfaces: IpTelnetClientSourceInterfaces
    """Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items."""
    ip_tftp_client_source_interfaces: IpTftpClientSourceInterfaces
    """Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items."""
    ip_virtual_router_mac_address: str | None
    """MAC address (hh:hh:hh:hh:hh:hh)."""
    ipv6_access_lists: Ipv6AccessLists
    """Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`)."""
    ipv6_dhcp_relay: Ipv6DhcpRelay
    """Subclass of AvdModel."""
    ipv6_hardware: Ipv6Hardware
    """Subclass of AvdModel."""
    ipv6_icmp_redirect: bool | None
    ipv6_neighbor: Ipv6Neighbor
    """Subclass of AvdModel."""
    ipv6_prefix_lists: Ipv6PrefixLists
    """Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`)."""
    ipv6_standard_access_lists: Ipv6StandardAccessLists
    """Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`)."""
    ipv6_static_routes: Ipv6StaticRoutes
    """Subclass of AvdList with `Ipv6StaticRoutesItem` items."""
    ipv6_unicast_routing: bool | None
    is_deployed: bool
    """
    Key only used for documentation or validation purposes.

    Default value: `True`
    """
    l2_protocol: L2Protocol
    """Subclass of AvdModel."""
    lacp: Lacp
    """
    Set Link Aggregation Control Protocol (LACP) parameters.

    Subclass of AvdModel.
    """
    link_tracking_groups: LinkTrackingGroups
    """Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`)."""
    lldp: Lldp
    """Subclass of AvdModel."""
    load_interval: LoadInterval
    """Subclass of AvdModel."""
    local_users: LocalUsers
    """Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`)."""
    logging: Logging
    """Subclass of AvdModel."""
    loopback_interfaces: LoopbackInterfaces
    """Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`)."""
    mac_access_lists: MacAccessLists
    """Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`)."""
    mac_address_table: MacAddressTable
    """Subclass of AvdModel."""
    mac_security: MacSecurity
    """Subclass of AvdModel."""
    maintenance: Maintenance
    """Subclass of AvdModel."""
    management_accounts: ManagementAccounts
    """Subclass of AvdModel."""
    management_api_gnmi: ManagementApiGnmi
    """Subclass of AvdModel."""
    management_api_http: ManagementApiHttp
    """Subclass of AvdModel."""
    management_api_models: ManagementApiModels
    """Subclass of AvdModel."""
    management_console: ManagementConsole
    """Subclass of AvdModel."""
    management_cvx: ManagementCvx
    """Subclass of AvdModel."""
    management_defaults: ManagementDefaults
    """Subclass of AvdModel."""
    management_interfaces: ManagementInterfaces
    """Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`)."""
    management_security: ManagementSecurity
    """Subclass of AvdModel."""
    management_ssh: ManagementSsh
    """Subclass of AvdModel."""
    management_tech_support: ManagementTechSupport
    """Subclass of AvdModel."""
    match_list_input: MatchListInput
    """Subclass of AvdModel."""
    mcs_client: McsClient
    """Subclass of AvdModel."""
    metadata: Metadata
    """
    The data under `metadata` is used for documentation, validation or integration purposes.
    It will not
    affect the generated EOS configuration.

    Subclass of AvdModel.
    """
    mlag_configuration: MlagConfiguration
    """Subclass of AvdModel."""
    monitor_connectivity: MonitorConnectivity
    """Subclass of AvdModel."""
    monitor_layer1: MonitorLayer1
    """
    Enable SYSLOG messages on transceiver SMBus communication failures.

    Subclass of AvdModel.
    """
    monitor_server_radius: MonitorServerRadius
    """
    Settings to monitor radius servers.

    Subclass of AvdModel.
    """
    monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre
    """Subclass of AvdModel."""
    monitor_sessions: MonitorSessions
    """Subclass of AvdList with `MonitorSessionsItem` items."""
    monitor_telemetry_influx: MonitorTelemetryInflux
    """Subclass of AvdModel."""
    monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy
    """Subclass of AvdModel."""
    mpls: Mpls
    """Subclass of AvdModel."""
    ntp: Ntp
    """Subclass of AvdModel."""
    patch_panel: PatchPanel
    """Subclass of AvdModel."""
    peer_filters: PeerFilters
    """Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`)."""
    platform: Platform
    """
    Every key below this point is platform dependent.

    Subclass of AvdModel.
    """
    poe: Poe
    """Subclass of AvdModel."""
    policy_maps: PolicyMaps
    """Subclass of AvdModel."""
    port_channel_interfaces: PortChannelInterfaces
    """Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`)."""
    prefix_lists: PrefixLists
    """Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`)."""
    priority_flow_control: PriorityFlowControl
    """
    Global Priority Flow Control settings.


    Subclass of AvdModel.
    """
    prompt: str | None
    ptp: Ptp
    """Subclass of AvdModel."""
    qos: Qos
    """Subclass of AvdModel."""
    qos_profiles: QosProfiles
    """Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`)."""
    queue_monitor_length: QueueMonitorLength
    """Subclass of AvdModel."""
    queue_monitor_streaming: QueueMonitorStreaming
    """Subclass of AvdModel."""
    radius_server: RadiusServer
    """Subclass of AvdModel."""
    redundancy: Redundancy
    """Subclass of AvdModel."""
    roles: Roles
    """Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`)."""
    route_maps: RouteMaps
    """Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`)."""
    router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology
    """Subclass of AvdModel."""
    router_bfd: RouterBfd
    """Subclass of AvdModel."""
    router_bgp: RouterBgp
    """Subclass of AvdModel."""
    router_general: RouterGeneral
    """Subclass of AvdModel."""
    router_igmp: RouterIgmp
    """Subclass of AvdModel."""
    router_internet_exit: RouterInternetExit
    """
    Internet-exit feature to configure internet bound service for virtual topologies.

    Subclass of
    AvdModel.
    """
    router_isis: RouterIsis
    """Subclass of AvdModel."""
    router_l2_vpn: RouterL2Vpn
    """Subclass of AvdModel."""
    router_msdp: RouterMsdp
    """Subclass of AvdModel."""
    router_multicast: RouterMulticast
    """Subclass of AvdModel."""
    router_ospf: RouterOspf
    """Subclass of AvdModel."""
    router_path_selection: RouterPathSelection
    """
    Dynamic path selection configuration.

    Subclass of AvdModel.
    """
    router_pim_sparse_mode: RouterPimSparseMode
    """Subclass of AvdModel."""
    router_segment_security: RouterSegmentSecurity
    """Subclass of AvdModel."""
    router_service_insertion: RouterServiceInsertion
    """
    Configure network services inserted to data forwarding.

    Subclass of AvdModel.
    """
    router_traffic_engineering: RouterTrafficEngineering
    """Subclass of AvdModel."""
    service_routing_configuration_bgp: ServiceRoutingConfigurationBgp
    """Subclass of AvdModel."""
    service_routing_protocols_model: Literal["multi-agent", "ribd"] | None
    service_unsupported_transceiver: ServiceUnsupportedTransceiver
    """Subclass of AvdModel."""
    sflow: Sflow
    """Subclass of AvdModel."""
    snmp_server: SnmpServer
    """
    SNMP settings.

    Subclass of AvdModel.
    """
    spanning_tree: SpanningTree
    """Subclass of AvdModel."""
    standard_access_lists: StandardAccessLists
    """Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`)."""
    static_routes: StaticRoutes
    """Subclass of AvdList with `StaticRoutesItem` items."""
    stun: Stun
    """
    STUN configuration.

    Subclass of AvdModel.
    """
    switchport_default: SwitchportDefault
    """Subclass of AvdModel."""
    switchport_port_security: SwitchportPortSecurity
    """Subclass of AvdModel."""
    sync_e: SyncE
    """Subclass of AvdModel."""
    system: System
    """Subclass of AvdModel."""
    tacacs_servers: TacacsServers
    """Subclass of AvdModel."""
    tap_aggregation: TapAggregation
    """Subclass of AvdModel."""
    tcam_profile: TcamProfile
    """Subclass of AvdModel."""
    terminal: Terminal
    """Subclass of AvdModel."""
    trackers: Trackers
    """Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`)."""
    traffic_policies: TrafficPolicies
    """Subclass of AvdModel."""
    transceiver_qsfp_default_mode_4x10: bool
    """
    On all front panel ports which support this feature, the following global configuration command
    changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
    QSFP mode back to 40G.

    Default value: `True`
    """
    tunnel_interfaces: TunnelInterfaces
    """Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`)."""
    virtual_source_nat_vrfs: VirtualSourceNatVrfs
    """Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`)."""
    vlan_interfaces: VlanInterfaces
    """Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`)."""
    vlan_internal_order: VlanInternalOrder
    """Subclass of AvdModel."""
    vlans: Vlans
    """Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`)."""
    vmtracer_sessions: VmtracerSessions
    """Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`)."""
    vrfs: Vrfs
    """
    These keys are ignored if the name of the vrf is 'default'.


    Subclass of AvdIndexedList with
    `VrfsItem` items. Primary key is `name` (`str`).
    """
    vxlan_interface: VxlanInterface
    """Subclass of AvdModel."""
    _custom_data: dict[str, Any]

    if TYPE_CHECKING:

        def __init__(
            self,
            *,
            aaa_accounting: AaaAccounting | UndefinedType = Undefined,
            aaa_authentication: AaaAuthentication | UndefinedType = Undefined,
            aaa_authorization: AaaAuthorization | UndefinedType = Undefined,
            aaa_root: AaaRoot | UndefinedType = Undefined,
            aaa_server_groups: AaaServerGroups | UndefinedType = Undefined,
            access_lists: AccessLists | UndefinedType = Undefined,
            address_locking: AddressLocking | UndefinedType = Undefined,
            agents: Agents | UndefinedType = Undefined,
            aliases: str | None | UndefinedType = Undefined,
            application_traffic_recognition: ApplicationTrafficRecognition | UndefinedType = Undefined,
            arp: Arp | UndefinedType = Undefined,
            as_path: AsPath | UndefinedType = Undefined,
            avd_data_validation_mode: Literal["error", "warning"] | UndefinedType = Undefined,
            banners: Banners | UndefinedType = Undefined,
            bgp_groups: BgpGroups | UndefinedType = Undefined,
            boot: Boot | UndefinedType = Undefined,
            class_maps: ClassMaps | UndefinedType = Undefined,
            clock: Clock | UndefinedType = Undefined,
            community_lists: CommunityLists | UndefinedType = Undefined,
            config_comment: str | None | UndefinedType = Undefined,
            config_end: bool | UndefinedType = Undefined,
            custom_templates: CustomTemplates | UndefinedType = Undefined,
            cvx: Cvx | UndefinedType = Undefined,
            daemon_terminattr: DaemonTerminattr | UndefinedType = Undefined,
            daemons: Daemons | UndefinedType = Undefined,
            dhcp_relay: DhcpRelay | UndefinedType = Undefined,
            dhcp_servers: DhcpServers | UndefinedType = Undefined,
            dns_domain: str | None | UndefinedType = Undefined,
            domain_list: DomainList | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            dps_interfaces: DpsInterfaces | UndefinedType = Undefined,
            dynamic_prefix_lists: DynamicPrefixLists | UndefinedType = Undefined,
            enable_password: EnablePassword | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
            eos_cli_config_gen_configuration: EosCliConfigGenConfiguration | UndefinedType = Undefined,
            eos_cli_config_gen_documentation: EosCliConfigGenDocumentation | UndefinedType = Undefined,
            errdisable: Errdisable | UndefinedType = Undefined,
            ethernet_interfaces: EthernetInterfaces | UndefinedType = Undefined,
            event_handlers: EventHandlers | UndefinedType = Undefined,
            event_monitor: EventMonitor | UndefinedType = Undefined,
            flow_tracking: FlowTracking | UndefinedType = Undefined,
            generate_default_config: bool | UndefinedType = Undefined,
            generate_device_documentation: bool | UndefinedType = Undefined,
            hardware: Hardware | UndefinedType = Undefined,
            hardware_counters: HardwareCounters | UndefinedType = Undefined,
            hostname: str | None | UndefinedType = Undefined,
            interface_defaults: InterfaceDefaults | UndefinedType = Undefined,
            interface_groups: InterfaceGroups | UndefinedType = Undefined,
            interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
            ip_access_lists: IpAccessLists | UndefinedType = Undefined,
            ip_access_lists_max_entries: int | None | UndefinedType = Undefined,
            ip_community_lists: IpCommunityLists | UndefinedType = Undefined,
            ip_dhcp_relay: IpDhcpRelay | UndefinedType = Undefined,
            ip_dhcp_snooping: IpDhcpSnooping | UndefinedType = Undefined,
            ip_domain_lookup: IpDomainLookup | UndefinedType = Undefined,
            ip_extcommunity_lists: IpExtcommunityLists | UndefinedType = Undefined,
            ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp | UndefinedType = Undefined,
            ip_ftp_client_source_interfaces: IpFtpClientSourceInterfaces | UndefinedType = Undefined,
            ip_hardware: IpHardware | UndefinedType = Undefined,
            ip_http_client_source_interfaces: IpHttpClientSourceInterfaces | UndefinedType = Undefined,
            ip_icmp_redirect: bool | None | UndefinedType = Undefined,
            ip_igmp_snooping: IpIgmpSnooping | UndefinedType = Undefined,
            ip_name_servers: IpNameServers | UndefinedType = Undefined,
            ip_nat: IpNat | UndefinedType = Undefined,
            ip_radius_source_interfaces: IpRadiusSourceInterfaces | UndefinedType = Undefined,
            ip_routing: bool | None | UndefinedType = Undefined,
            ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
            ip_security: IpSecurity | UndefinedType = Undefined,
            ip_ssh_client_source_interfaces: IpSshClientSourceInterfaces | UndefinedType = Undefined,
            ip_tacacs_source_interfaces: IpTacacsSourceInterfaces | UndefinedType = Undefined,
            ip_telnet_client_source_interfaces: IpTelnetClientSourceInterfaces | UndefinedType = Undefined,
            ip_tftp_client_source_interfaces: IpTftpClientSourceInterfaces | UndefinedType = Undefined,
            ip_virtual_router_mac_address: str | None | UndefinedType = Undefined,
            ipv6_access_lists: Ipv6AccessLists | UndefinedType = Undefined,
            ipv6_dhcp_relay: Ipv6DhcpRelay | UndefinedType = Undefined,
            ipv6_hardware: Ipv6Hardware | UndefinedType = Undefined,
            ipv6_icmp_redirect: bool | None | UndefinedType = Undefined,
            ipv6_neighbor: Ipv6Neighbor | UndefinedType = Undefined,
            ipv6_prefix_lists: Ipv6PrefixLists | UndefinedType = Undefined,
            ipv6_standard_access_lists: Ipv6StandardAccessLists | UndefinedType = Undefined,
            ipv6_static_routes: Ipv6StaticRoutes | UndefinedType = Undefined,
            ipv6_unicast_routing: bool | None | UndefinedType = Undefined,
            is_deployed: bool | UndefinedType = Undefined,
            l2_protocol: L2Protocol | UndefinedType = Undefined,
            lacp: Lacp | UndefinedType = Undefined,
            link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
            lldp: Lldp | UndefinedType = Undefined,
            load_interval: LoadInterval | UndefinedType = Undefined,
            local_users: LocalUsers | UndefinedType = Undefined,
            logging: Logging | UndefinedType = Undefined,
            loopback_interfaces: LoopbackInterfaces | UndefinedType = Undefined,
            mac_access_lists: MacAccessLists | UndefinedType = Undefined,
            mac_address_table: MacAddressTable | UndefinedType = Undefined,
            mac_security: MacSecurity | UndefinedType = Undefined,
            maintenance: Maintenance | UndefinedType = Undefined,
            management_accounts: ManagementAccounts | UndefinedType = Undefined,
            management_api_gnmi: ManagementApiGnmi | UndefinedType = Undefined,
            management_api_http: ManagementApiHttp | UndefinedType = Undefined,
            management_api_models: ManagementApiModels | UndefinedType = Undefined,
            management_console: ManagementConsole | UndefinedType = Undefined,
            management_cvx: ManagementCvx | UndefinedType = Undefined,
            management_defaults: ManagementDefaults | UndefinedType = Undefined,
            management_interfaces: ManagementInterfaces | UndefinedType = Undefined,
            management_security: ManagementSecurity | UndefinedType = Undefined,
            management_ssh: ManagementSsh | UndefinedType = Undefined,
            management_tech_support: ManagementTechSupport | UndefinedType = Undefined,
            match_list_input: MatchListInput | UndefinedType = Undefined,
            mcs_client: McsClient | UndefinedType = Undefined,
            metadata: Metadata | UndefinedType = Undefined,
            mlag_configuration: MlagConfiguration | UndefinedType = Undefined,
            monitor_connectivity: MonitorConnectivity | UndefinedType = Undefined,
            monitor_layer1: MonitorLayer1 | UndefinedType = Undefined,
            monitor_server_radius: MonitorServerRadius | UndefinedType = Undefined,
            monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre | UndefinedType = Undefined,
            monitor_sessions: MonitorSessions | UndefinedType = Undefined,
            monitor_telemetry_influx: MonitorTelemetryInflux | UndefinedType = Undefined,
            monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy | UndefinedType = Undefined,
            mpls: Mpls | UndefinedType = Undefined,
            ntp: Ntp | UndefinedType = Undefined,
            patch_panel: PatchPanel | UndefinedType = Undefined,
            peer_filters: PeerFilters | UndefinedType = Undefined,
            platform: Platform | UndefinedType = Undefined,
            poe: Poe | UndefinedType = Undefined,
            policy_maps: PolicyMaps | UndefinedType = Undefined,
            port_channel_interfaces: PortChannelInterfaces | UndefinedType = Undefined,
            prefix_lists: PrefixLists | UndefinedType = Undefined,
            priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
            prompt: str | None | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            qos: Qos | UndefinedType = Undefined,
            qos_profiles: QosProfiles | UndefinedType = Undefined,
            queue_monitor_length: QueueMonitorLength | UndefinedType = Undefined,
            queue_monitor_streaming: QueueMonitorStreaming | UndefinedType = Undefined,
            radius_server: RadiusServer | UndefinedType = Undefined,
            redundancy: Redundancy | UndefinedType = Undefined,
            roles: Roles | UndefinedType = Undefined,
            route_maps: RouteMaps | UndefinedType = Undefined,
            router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology | UndefinedType = Undefined,
            router_bfd: RouterBfd | UndefinedType = Undefined,
            router_bgp: RouterBgp | UndefinedType = Undefined,
            router_general: RouterGeneral | UndefinedType = Undefined,
            router_igmp: RouterIgmp | UndefinedType = Undefined,
            router_internet_exit: RouterInternetExit | UndefinedType = Undefined,
            router_isis: RouterIsis | UndefinedType = Undefined,
            router_l2_vpn: RouterL2Vpn | UndefinedType = Undefined,
            router_msdp: RouterMsdp | UndefinedType = Undefined,
            router_multicast: RouterMulticast | UndefinedType = Undefined,
            router_ospf: RouterOspf | UndefinedType = Undefined,
            router_path_selection: RouterPathSelection | UndefinedType = Undefined,
            router_pim_sparse_mode: RouterPimSparseMode | UndefinedType = Undefined,
            router_segment_security: RouterSegmentSecurity | UndefinedType = Undefined,
            router_service_insertion: RouterServiceInsertion | UndefinedType = Undefined,
            router_traffic_engineering: RouterTrafficEngineering | UndefinedType = Undefined,
            service_routing_configuration_bgp: ServiceRoutingConfigurationBgp | UndefinedType = Undefined,
            service_routing_protocols_model: Literal["multi-agent", "ribd"] | None | UndefinedType = Undefined,
            service_unsupported_transceiver: ServiceUnsupportedTransceiver | UndefinedType = Undefined,
            sflow: Sflow | UndefinedType = Undefined,
            snmp_server: SnmpServer | UndefinedType = Undefined,
            spanning_tree: SpanningTree | UndefinedType = Undefined,
            standard_access_lists: StandardAccessLists | UndefinedType = Undefined,
            static_routes: StaticRoutes | UndefinedType = Undefined,
            stun: Stun | UndefinedType = Undefined,
            switchport_default: SwitchportDefault | UndefinedType = Undefined,
            switchport_port_security: SwitchportPortSecurity | UndefinedType = Undefined,
            sync_e: SyncE | UndefinedType = Undefined,
            system: System | UndefinedType = Undefined,
            tacacs_servers: TacacsServers | UndefinedType = Undefined,
            tap_aggregation: TapAggregation | UndefinedType = Undefined,
            tcam_profile: TcamProfile | UndefinedType = Undefined,
            terminal: Terminal | UndefinedType = Undefined,
            trackers: Trackers | UndefinedType = Undefined,
            traffic_policies: TrafficPolicies | UndefinedType = Undefined,
            transceiver_qsfp_default_mode_4x10: bool | UndefinedType = Undefined,
            tunnel_interfaces: TunnelInterfaces | UndefinedType = Undefined,
            virtual_source_nat_vrfs: VirtualSourceNatVrfs | UndefinedType = Undefined,
            vlan_interfaces: VlanInterfaces | UndefinedType = Undefined,
            vlan_internal_order: VlanInternalOrder | UndefinedType = Undefined,
            vlans: Vlans | UndefinedType = Undefined,
            vmtracer_sessions: VmtracerSessions | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            vxlan_interface: VxlanInterface | UndefinedType = Undefined,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
        ) -> None:
            """
            EosCliConfigGen.


            Subclass of AvdModel.

            Args:
                aaa_accounting: Subclass of AvdModel.
                aaa_authentication: Subclass of AvdModel.
                aaa_authorization: Subclass of AvdModel.
                aaa_root: Subclass of AvdModel.
                aaa_server_groups: Subclass of AvdIndexedList with `AaaServerGroupsItem` items. Primary key is `name` (`str`).
                access_lists: Subclass of AvdIndexedList with `AccessListsItem` items. Primary key is `name` (`str`).
                address_locking: Subclass of AvdModel.
                agents: Subclass of AvdIndexedList with `AgentsItem` items. Primary key is `name` (`str`).
                aliases:
                   Multi-line string with one or more alias commands.

                   Example:  # fmt: skip

                   ```yaml
                   aliases: |
                     alias wr copy
                   running-config startup-config
                     alias siib show ip interface brief
                   ```
                application_traffic_recognition:
                   Application traffic recognition configuration.

                   Subclass of AvdModel.
                arp: Subclass of AvdModel.
                as_path: Subclass of AvdModel.
                avd_data_validation_mode:
                   Validation Mode for AVD input data validation.
                   Input data validation will validate the input
                   variables according to the schema.
                   During validation, messages will generated with information about
                   the host(s) and key(s) which failed validation.
                   "error" will produce error messages and fail the
                   task.
                   "warning" will produce warning messages.
                banners: Subclass of AvdModel.
                bgp_groups: Subclass of AvdIndexedList with `BgpGroupsItem` items. Primary key is `name` (`str`).
                boot:
                   Set the Aboot password.


                   Subclass of AvdModel.
                class_maps: Subclass of AvdModel.
                clock: Subclass of AvdModel.
                community_lists: Subclass of AvdIndexedList with `CommunityListsItem` items. Primary key is `name` (`str`).
                config_comment:
                   Add a comment to provide information about the configuration.
                   This comment will be rendered at the
                   top of the generated configuration.
                config_end: Render `end` at the end of the configuration.
                custom_templates:
                   - Custom templates can be added below the playbook directory.
                   - If a location above the directory is
                   desired, a symbolic link can be used.
                   - Example under the `playbooks` directory create symbolic link
                   with the following command:

                     ```bash
                     ln -s ../../shared_repo/custom_avd_templates/
                   ./custom_avd_templates
                     ```

                   - The output will be rendered at the end of the configuration.
                   - The
                   order of custom templates in the list can be important if they overlap.
                   - It is recommended to use a
                   `!` delimiter at the top of each custom template.

                   Add `custom_templates` to group/host variables:
                   Subclass of AvdList with `str` items.
                cvx:
                   CVX server features are not supported on physical switches. See `management_cvx` for client
                   configurations.

                   Subclass of AvdModel.
                daemon_terminattr:
                   You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
                   for your Cloudvision as a Service instance.
                   Streaming to multiple clusters both on-prem and cloud
                   service is supported.

                   !!! note
                       For TerminAttr version recommendation and EOS compatibility
                   matrix, please refer to the latest TerminAttr Release Notes
                       which always contain the latest
                   recommended versions and minimum required versions per EOS release.


                   Subclass of AvdModel.
                daemons:
                   This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
                   clients like ocprometheus.

                   Subclass of AvdIndexedList with `DaemonsItem` items. Primary key is
                   `name` (`str`).
                dhcp_relay: Subclass of AvdModel.
                dhcp_servers: Subclass of AvdIndexedList with `DhcpServersItem` items. Primary key is `vrf` (`str`).
                dns_domain: Domain Name.
                domain_list:
                   Search list of DNS domains.

                   Subclass of AvdList with `str` items.
                dot1x: Subclass of AvdModel.
                dps_interfaces: Subclass of AvdIndexedList with `DpsInterfacesItem` items. Primary key is `name` (`str`).
                dynamic_prefix_lists: Subclass of AvdList with `DynamicPrefixListsItem` items.
                enable_password: Subclass of AvdModel.
                eos_cli: Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration.
                eos_cli_config_gen_configuration: Subclass of AvdModel.
                eos_cli_config_gen_documentation: Subclass of AvdModel.
                errdisable: Subclass of AvdModel.
                ethernet_interfaces: Subclass of AvdIndexedList with `EthernetInterfacesItem` items. Primary key is `name` (`str`).
                event_handlers:
                   Gives the ability to monitor and react to Syslog messages.
                   Event Handlers provide a powerful and
                   flexible tool that can be used to apply self-healing actions,
                   customize the system behavior, and
                   implement workarounds to problems discovered in the field.


                   Subclass of AvdIndexedList with
                   `EventHandlersItem` items. Primary key is `name` (`str`).
                event_monitor: Subclass of AvdModel.
                flow_tracking: Subclass of AvdModel.
                generate_default_config:
                   The `generate_default_config` knob allows to omit default EOS configuration.
                   This can be useful when
                   leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

                   The following commands
                   will be omitted when `generate_default_config` is set to `false`:

                   - RANCID Content Type
                   - Hostname
                   (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
                   -
                   Default configuration for `aaa`
                   - Default configuration for `enable password`
                   - Transceiver qsfp
                   default mode
                   - End of configuration delimiter
                generate_device_documentation: generate_device_documentation
                hardware: Subclass of AvdModel.
                hardware_counters: Subclass of AvdModel.
                hostname: hostname
                interface_defaults: Subclass of AvdModel.
                interface_groups: Subclass of AvdIndexedList with `InterfaceGroupsItem` items. Primary key is `name` (`str`).
                interface_profiles: Subclass of AvdIndexedList with `InterfaceProfilesItem` items. Primary key is `name` (`str`).
                ip_access_lists: Subclass of AvdIndexedList with `IpAccessListsItem` items. Primary key is `name` (`str`).
                ip_access_lists_max_entries: Limit ACL entries defined under the `ip_access_lists`.
                ip_community_lists:
                   Communities and regexp entries MUST not be configured in the same community-list.


                   Subclass of
                   AvdIndexedList with `IpCommunityListsItem` items. Primary key is `name` (`str`).
                ip_dhcp_relay: Subclass of AvdModel.
                ip_dhcp_snooping: Subclass of AvdModel.
                ip_domain_lookup: Subclass of AvdModel.
                ip_extcommunity_lists: Subclass of AvdIndexedList with `IpExtcommunityListsItem` items. Primary key is `name` (`str`).
                ip_extcommunity_lists_regexp:
                   Subclass of AvdIndexedList with `IpExtcommunityListsRegexpItem` items. Primary key is `name`
                   (`str`).
                ip_ftp_client_source_interfaces: Subclass of AvdList with `IpFtpClientSourceInterfacesItem` items.
                ip_hardware: Subclass of AvdModel.
                ip_http_client_source_interfaces: Subclass of AvdList with `IpHttpClientSourceInterfacesItem` items.
                ip_icmp_redirect: ip_icmp_redirect
                ip_igmp_snooping: Subclass of AvdModel.
                ip_name_servers: Subclass of AvdList with `IpNameServersItem` items.
                ip_nat: Subclass of AvdModel.
                ip_radius_source_interfaces: Subclass of AvdList with `IpRadiusSourceInterfacesItem` items.
                ip_routing: ip_routing
                ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                ip_security: Subclass of AvdModel.
                ip_ssh_client_source_interfaces: Subclass of AvdList with `IpSshClientSourceInterfacesItem` items.
                ip_tacacs_source_interfaces: Subclass of AvdList with `IpTacacsSourceInterfacesItem` items.
                ip_telnet_client_source_interfaces: Subclass of AvdList with `IpTelnetClientSourceInterfacesItem` items.
                ip_tftp_client_source_interfaces: Subclass of AvdList with `IpTftpClientSourceInterfacesItem` items.
                ip_virtual_router_mac_address: MAC address (hh:hh:hh:hh:hh:hh).
                ipv6_access_lists: Subclass of AvdIndexedList with `Ipv6AccessListsItem` items. Primary key is `name` (`str`).
                ipv6_dhcp_relay: Subclass of AvdModel.
                ipv6_hardware: Subclass of AvdModel.
                ipv6_icmp_redirect: ipv6_icmp_redirect
                ipv6_neighbor: Subclass of AvdModel.
                ipv6_prefix_lists: Subclass of AvdIndexedList with `Ipv6PrefixListsItem` items. Primary key is `name` (`str`).
                ipv6_standard_access_lists: Subclass of AvdIndexedList with `Ipv6StandardAccessListsItem` items. Primary key is `name` (`str`).
                ipv6_static_routes: Subclass of AvdList with `Ipv6StaticRoutesItem` items.
                ipv6_unicast_routing: ipv6_unicast_routing
                is_deployed: Key only used for documentation or validation purposes.
                l2_protocol: Subclass of AvdModel.
                lacp:
                   Set Link Aggregation Control Protocol (LACP) parameters.

                   Subclass of AvdModel.
                link_tracking_groups: Subclass of AvdIndexedList with `LinkTrackingGroupsItem` items. Primary key is `name` (`str`).
                lldp: Subclass of AvdModel.
                load_interval: Subclass of AvdModel.
                local_users: Subclass of AvdIndexedList with `LocalUsersItem` items. Primary key is `name` (`str`).
                logging: Subclass of AvdModel.
                loopback_interfaces: Subclass of AvdIndexedList with `LoopbackInterfacesItem` items. Primary key is `name` (`str`).
                mac_access_lists: Subclass of AvdIndexedList with `MacAccessListsItem` items. Primary key is `name` (`str`).
                mac_address_table: Subclass of AvdModel.
                mac_security: Subclass of AvdModel.
                maintenance: Subclass of AvdModel.
                management_accounts: Subclass of AvdModel.
                management_api_gnmi: Subclass of AvdModel.
                management_api_http: Subclass of AvdModel.
                management_api_models: Subclass of AvdModel.
                management_console: Subclass of AvdModel.
                management_cvx: Subclass of AvdModel.
                management_defaults: Subclass of AvdModel.
                management_interfaces: Subclass of AvdIndexedList with `ManagementInterfacesItem` items. Primary key is `name` (`str`).
                management_security: Subclass of AvdModel.
                management_ssh: Subclass of AvdModel.
                management_tech_support: Subclass of AvdModel.
                match_list_input: Subclass of AvdModel.
                mcs_client: Subclass of AvdModel.
                metadata:
                   The data under `metadata` is used for documentation, validation or integration purposes.
                   It will not
                   affect the generated EOS configuration.

                   Subclass of AvdModel.
                mlag_configuration: Subclass of AvdModel.
                monitor_connectivity: Subclass of AvdModel.
                monitor_layer1:
                   Enable SYSLOG messages on transceiver SMBus communication failures.

                   Subclass of AvdModel.
                monitor_server_radius:
                   Settings to monitor radius servers.

                   Subclass of AvdModel.
                monitor_session_default_encapsulation_gre: Subclass of AvdModel.
                monitor_sessions: Subclass of AvdList with `MonitorSessionsItem` items.
                monitor_telemetry_influx: Subclass of AvdModel.
                monitor_telemetry_postcard_policy: Subclass of AvdModel.
                mpls: Subclass of AvdModel.
                ntp: Subclass of AvdModel.
                patch_panel: Subclass of AvdModel.
                peer_filters: Subclass of AvdIndexedList with `PeerFiltersItem` items. Primary key is `name` (`str`).
                platform:
                   Every key below this point is platform dependent.

                   Subclass of AvdModel.
                poe: Subclass of AvdModel.
                policy_maps: Subclass of AvdModel.
                port_channel_interfaces: Subclass of AvdIndexedList with `PortChannelInterfacesItem` items. Primary key is `name` (`str`).
                prefix_lists: Subclass of AvdIndexedList with `PrefixListsItem` items. Primary key is `name` (`str`).
                priority_flow_control:
                   Global Priority Flow Control settings.


                   Subclass of AvdModel.
                prompt: prompt
                ptp: Subclass of AvdModel.
                qos: Subclass of AvdModel.
                qos_profiles: Subclass of AvdIndexedList with `QosProfilesItem` items. Primary key is `name` (`str`).
                queue_monitor_length: Subclass of AvdModel.
                queue_monitor_streaming: Subclass of AvdModel.
                radius_server: Subclass of AvdModel.
                redundancy: Subclass of AvdModel.
                roles: Subclass of AvdIndexedList with `RolesItem` items. Primary key is `name` (`str`).
                route_maps: Subclass of AvdIndexedList with `RouteMapsItem` items. Primary key is `name` (`str`).
                router_adaptive_virtual_topology: Subclass of AvdModel.
                router_bfd: Subclass of AvdModel.
                router_bgp: Subclass of AvdModel.
                router_general: Subclass of AvdModel.
                router_igmp: Subclass of AvdModel.
                router_internet_exit:
                   Internet-exit feature to configure internet bound service for virtual topologies.

                   Subclass of
                   AvdModel.
                router_isis: Subclass of AvdModel.
                router_l2_vpn: Subclass of AvdModel.
                router_msdp: Subclass of AvdModel.
                router_multicast: Subclass of AvdModel.
                router_ospf: Subclass of AvdModel.
                router_path_selection:
                   Dynamic path selection configuration.

                   Subclass of AvdModel.
                router_pim_sparse_mode: Subclass of AvdModel.
                router_segment_security: Subclass of AvdModel.
                router_service_insertion:
                   Configure network services inserted to data forwarding.

                   Subclass of AvdModel.
                router_traffic_engineering: Subclass of AvdModel.
                service_routing_configuration_bgp: Subclass of AvdModel.
                service_routing_protocols_model: service_routing_protocols_model
                service_unsupported_transceiver: Subclass of AvdModel.
                sflow: Subclass of AvdModel.
                snmp_server:
                   SNMP settings.

                   Subclass of AvdModel.
                spanning_tree: Subclass of AvdModel.
                standard_access_lists: Subclass of AvdIndexedList with `StandardAccessListsItem` items. Primary key is `name` (`str`).
                static_routes: Subclass of AvdList with `StaticRoutesItem` items.
                stun:
                   STUN configuration.

                   Subclass of AvdModel.
                switchport_default: Subclass of AvdModel.
                switchport_port_security: Subclass of AvdModel.
                sync_e: Subclass of AvdModel.
                system: Subclass of AvdModel.
                tacacs_servers: Subclass of AvdModel.
                tap_aggregation: Subclass of AvdModel.
                tcam_profile: Subclass of AvdModel.
                terminal: Subclass of AvdModel.
                trackers: Subclass of AvdIndexedList with `TrackersItem` items. Primary key is `name` (`str`).
                traffic_policies: Subclass of AvdModel.
                transceiver_qsfp_default_mode_4x10:
                   On all front panel ports which support this feature, the following global configuration command
                   changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
                   QSFP mode back to 40G.
                tunnel_interfaces: Subclass of AvdIndexedList with `TunnelInterfacesItem` items. Primary key is `name` (`str`).
                virtual_source_nat_vrfs: Subclass of AvdIndexedList with `VirtualSourceNatVrfsItem` items. Primary key is `name` (`str`).
                vlan_interfaces: Subclass of AvdIndexedList with `VlanInterfacesItem` items. Primary key is `name` (`str`).
                vlan_internal_order: Subclass of AvdModel.
                vlans: Subclass of AvdIndexedList with `VlansItem` items. Primary key is `id` (`int`).
                vmtracer_sessions: Subclass of AvdIndexedList with `VmtracerSessionsItem` items. Primary key is `name` (`str`).
                vrfs:
                   These keys are ignored if the name of the vrf is 'default'.


                   Subclass of AvdIndexedList with
                   `VrfsItem` items. Primary key is `name` (`str`).
                vxlan_interface: Subclass of AvdModel.
                _custom_data: _custom_data

            """
