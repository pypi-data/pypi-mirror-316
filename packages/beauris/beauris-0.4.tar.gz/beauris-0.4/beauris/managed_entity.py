import logging
import os
import re
from copy import deepcopy

import yaml

from .managed_file import DerivedFile

logging.basicConfig(level=logging.INFO)
log = logging.getLogger()


class ManagedEntity():

    def __init__(self, config, yml_path=None, locked_dir=None, future_locked_dir=None, default_services=[], yml_data={}, **kwargs):

        self.config = config

        self.yml_data = yml_data

        self.locked_dir = locked_dir

        self.future_locked_dir = future_locked_dir

        self.version = None

        self.tags = self.yml_data.get('tags', [])

        self.entity_name = None  # The name of the entity (like 'assembly', or 'annotation')

        # Path to yml file if we have one for this entity level in the hierarchy
        self.yml_path = None
        if yml_path:
            self.yml_path = yml_path

            if locked_dir:
                self.locked_yml_path = os.path.join(locked_dir, os.path.basename(self.yml_path))
            else:
                self.locked_yml_path = os.path.join(self.config.raw['data_locker']['options']['locked_yml_dir'], os.path.basename(self.yml_path))

            if future_locked_dir:
                self.future_locked_yml_path = os.path.join(future_locked_dir, os.path.basename(self.yml_path))
            else:
                self.future_locked_yml_path = os.path.join(self.config.raw['data_locker']['options']['locked_yml_dir_future'], os.path.basename(self.yml_path))

        self.restricted_to_not_inherited = self.yml_data.get('restricted_to', None)
        if self.get_parent():
            self.restricted_to = self.yml_data.get('restricted_to', self.get_parent().restricted_to)
        else:
            self.restricted_to = self.yml_data.get('restricted_to', None)

        self.locked_restricted_to = None

        # Dict of tasks that can be used to generate derived files
        self.tasks = {}

        # List of input reference files
        self.input_files = {}

        # List of output files generated by tasks (key=task name, value=list of file names relative to task work_dir)
        self.derived_files = {}

        # Dict of dict, key = task_id, value = dict of options to be passed to a task
        self.task_options = self.load_task_options(self.yml_data)

        self.deploy_services = deepcopy(default_services)
        # Dict of list of services (by server) that should be deployed for this entity
        if 'services' in self.yml_data:
            if self.yml_data['services'] is None:
                self.deploy_services = []
            if self.yml_data['services']["staging"] is None and self.yml_data['services']["production"] is None:
                self.deploy_services = []

        self.parse_services(self.yml_data)

        # A list of BlastBank objects
        self.blastbanks = []

    def sanitize(self, name):

        name = re.sub('[^0-9a-zA-Z_.-]+', '_', name)

        return name

    def parse_services(self, yml_data):

        if 'services' in yml_data:
            for server in self.deploy_services:
                if server in yml_data['services']:
                    # Force authelia if any services might requires it
                    require_authelia = 'authelia' in self.deploy_services[server]
                    require_authelia = require_authelia and any([service in yml_data['services'][server] for service in ['jbrowse', 'download', 'blast']])
                    self.deploy_services[server] = yml_data['services'][server]
                    if 'authelia' not in self.deploy_services[server] and require_authelia:
                        self.deploy_services[server].append('authelia')

    def slug(self, short=False):

        raise NotImplementedError()

    def pretty_name(self, with_parent=True):

        raise NotImplementedError()

    def get_work_dir(self):

        raise NotImplementedError()

    def create_work_dir(self):

        dir = self.get_work_dir()

        if not os.path.isdir(dir):
            os.mkdir(dir)

        for tid, task in self.tasks.items():
            task.create_work_dir()

        for child in self.get_children():
            child.create_work_dir()

    def get_input_path(self, file_id):

        return self.input_files[file_id].get_usable_path()

    def get_derived_path(self, file_id):

        tmp_task = self.derived_files[file_id].task

        return self.derived_files[file_id].get_usable_path(force_work_dir=tmp_task.needs_to_run())

    def get_parent(self):

        return None

    def get_children(self):

        return []

    def get_organism(self):

        return None

    def get_tags(self, inherit=False):

        if inherit and self.get_parent():
            self.tags += self.get_parent().get_tags(inherit)
            return set(self.tags)
        else:
            return set(self.tags)

    def load_locked_data(self, locked_yml, future=False):

        # Basic implementation, organism and its children takes care of recursivity

        if 'derived' in locked_yml:
            by_name = {x['name']: x for x in locked_yml['derived']}
            for did, derived in self.derived_files.items():
                if did in by_name:
                    derived.merge_with_locked(by_name[did], future)

        self.locked_restricted_to = locked_yml.get("restricted_to", "")

        # Can't load input files here as their identifier is not the same in beauris and in the yml file
        # TODO maybe harmonize naming of input files between beauris and yml file?

    def save_locked_yml(self):

        dest = self.locked_yml_path

        os.makedirs(os.path.dirname(dest), exist_ok=True)

        with open(dest, 'w') as desth:
            desth.write(yaml.dump(self.get_locked_yml(), default_flow_style=False, sort_keys=False))

    def get_locked_yml(self):

        # Basic implementation, organism and its children takes care of recursivity + injection of derived data
        locked_yml = self.yml_data

        return locked_yml

    def get_metadata(self, inherit=True):

        return {}

    def get_basic_metadata(self):

        meta = {}
        searched = [
            'description',
            'source',
            'date',
            'restricted_to',
        ]

        for s in searched:
            if s in self.yml_data:
                meta[s] = str(self.yml_data[s])

        return meta

    def lock(self, locker, recursive=False, dry_run=False):

        # Lock an input file when the revision has changed since last lock
        # TODO support greeted_path here (and add tests)
        for iid, input in self.input_files.items():
            ipath = input.path
            if input.has_changed_since_last_lock():
                if input.greeted_path:
                    ipath = input.greeted_path

                if input.no_lock:
                    log.info("No need to lock '{}' from {}, this file is probably too big".format(iid, ipath))
                    input.locked_path = ipath
                else:
                    log.debug("Will lock input file '{}' from {} (if not already done)".format(iid, ipath))
                    metadata = self.get_metadata()
                    metadata.update(input.get_metadata())
                    locked_path = locker.check_locked(ipath, input.version, input.revision, dry_run=dry_run, metadata=metadata)
                    input.locked_path = locked_path
            else:
                log.info("No need to lock '{}' from {}, no change since last lock".format(iid, ipath))

        # Lock a derived file when the task is supposed to have run (forced by tag, or because of change in dep)
        # and when the expected file is present in the work dir
        for iid, derived in self.derived_files.items():
            if derived.task.needs_to_run():
                if not derived.file_exists() and not dry_run:
                    if not derived.optional:
                        raise Exception("Could not find derived file '{}' at {} while trying to lock it".format(iid, derived.path))
                    log.debug("Skipping missing optional file '{}'".format(iid))
                    continue

                log.debug("Will lock derived file '{}' from {} (if not already done)".format(iid, derived.path))
                metadata = self.get_metadata()
                metadata.update(derived.get_metadata())
                locked_path = locker.check_locked(derived.path, derived.version, derived.get_revision(), dry_run=dry_run, metadata=metadata)

                derived.locked_path = locked_path
            else:
                log.info("No need to lock '{}' derived file, no changes in dependencies since last lock".format(iid))

        if recursive:
            for child in self.get_children():
                child.lock(locker, recursive, dry_run)

    def load_task_options(self, yml_data):
        options = {}

        if self.yml_data and "task_options" in self.yml_data:
            options = self.yml_data['task_options']

        return options

    def get_task_options(self, task_id):

        if task_id in self.task_options:
            return self.task_options[task_id]

        return {}

    def find_matching_yml_in_list(self, yml):
        """
        Find a yml subelement from a list matching the current object
        """

        for ysub in yml:
            if ysub["version"] == self.version:
                return ysub

        return {}

    def get_task_path(self, ext, file_path):
        file_name, _ = os.path.splitext(os.path.basename(file_path))
        return os.path.join(self.get_work_dir(), "{}.{}".format(file_name, ext))

    def get_files_to_publish(self):
        # Return list of files
        files = []
        for input_file in self.input_files.values():
            if input_file.publish:
                files.append((input_file, self))
        for derived_file in self.derived_files.values():
            if derived_file.publish:
                if derived_file.optional and not os.path.exists(derived_file.get_usable_path()):
                    continue
                files.append((derived_file, self))

        for child in self.get_children():
            files += child.get_files_to_publish()

        return files

    def get_deploy_services(self, server):

        if server != "any":
            return self.deploy_services[server] if server in self.deploy_services else []

        servs = []
        for aserver in self.deploy_services:
            servs = list(set(servs + self.deploy_services[aserver]))

        return servs

    def load_tasks_derived_files(self):

        self.derived_files = {}

        for t in self.tasks.values():

            for out in t.get_derived_outputs():

                self.derived_files[out.name] = DerivedFile(
                    out.ftype,
                    os.path.join(self.get_work_dir(), t.name, out.path),
                    version=self.version,
                    task=t,
                    name=out.name,
                    tool_version=out.tool_version,
                    publish=out.publish,
                    depends_on=out.depends_on,
                    optional=out.optional
                )

                if out.access_mode_from_children and self.has_mixed_data():
                    # We only add the _restricted suffix when the entity has both public and restricted output
                    # No suffix if all entity's data is public, or is restricted

                    restr_name = "{}_restricted".format(out.name)
                    self.derived_files[restr_name] = DerivedFile(
                        out.ftype,
                        os.path.join(self.get_work_dir(), t.name + "_restricted", out.path),
                        version=self.version,
                        task=t,
                        name=restr_name,
                        tool_version=out.tool_version,
                        publish=out.publish,
                        depends_on=out.depends_on,
                        optional=out.optional
                    )

    def accept_task(self, task):
        """
        Some entities can refuse to run selected tasks if not applicable
        """

        return True

    def get_blast_banks(self, recursive=True):

        banks = self.blastbanks

        if recursive:
            for child in self.get_children():
                banks += child.get_blast_banks()

        return banks

    def get_blast_link(self, bank, server, restricted=False):

        return '{id}'

    def copy_and_purge_restricted_data(self):

        newent = deepcopy(self)

        if newent.restricted_to is not None:
            return None

        newent.purge_restricted_data()

        return newent

    def purge_restricted_data(self):

        # If there are no subentities, nothing to do.
        return self

    def is_restricted(self):

        return self.restricted_to is not None

    def has_public_data(self):

        if self.restricted_to is None:
            return True

        for child in self.get_children():
            if child.has_public_data():
                return True

        return False

    def has_restricted_data(self):

        if self.restricted_to is not None:
            return True

        for child in self.get_children():
            if child.has_restricted_data():
                return True

        return False

    def has_mixed_data(self):

        return self.has_public_data() and self.has_restricted_data()

    def get_restricted_tos(self):

        rtos = set()

        if self.restricted_to is not None:
            rtos.add(self.restricted_to)

        for child in self.get_children():
            rtos.update(child.get_restricted_tos())

        return sorted(list(rtos))

    def get_restricted_to_map(self, locked=False):

        rtos = {}

        if locked:
            if self.locked_restricted_to:
                rtos[self.slug()] = self.locked_restricted_to
        else:
            if self.restricted_to_not_inherited:
                rtos[self.slug()] = self.restricted_to_not_inherited

        for ch in self.get_children():
            rtos.update(ch.get_restricted_to_map(locked))

        return rtos

    def greet_raw_data(self, processes):

        for input in self.input_files.values():

            download_dir = os.path.join(self.get_work_dir(), "greeted_data")

            if not input.has_locked_path() and input.is_remote():

                from_path = input.url

                dest_path = os.path.join(download_dir, input.name + "." + input.type)

                if not os.path.isdir(download_dir):
                    os.makedirs(download_dir, exist_ok=True)

                need_download = True
            else:
                from_path = input.path

                dest_path = os.path.join(download_dir, input.name + "." + input.type)

                need_download = False

            processes.greet_data(from_path, dest_path, input.hash_type, input.hash_value, need_download)

            if os.path.exists(dest_path):
                input.greeted_path = dest_path

        for ch in self.get_children():
            ch.greet_raw_data(processes)
