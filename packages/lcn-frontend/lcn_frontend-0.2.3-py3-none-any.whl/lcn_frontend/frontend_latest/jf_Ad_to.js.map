{"version":3,"file":"jf_Ad_to.js","mappings":";;;AAgBA;;;;AAOA;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgGA;ACvEA;AAGA;AACA;AACA;AATA;;;;AAwIA;;AC5IA;;AAGA;ACJA;AAGA;;;AASA;;;;AAKA;;;;AAUA;AChDA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAGA;AACA;;AAEA;;;AAIA;AACA;;;AAGA;;AAGA;AACA;;;;;;;AAQA;AACA;;;AAGA;;;AAGA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoJA;ACzLA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;;;ACLA;AACA;AACA;;;AAGA;AACA;;;AAIA;AACA;;AAGA;AAEA;AACA;AACA;;;AAGA;AACA;AAGA;AACA;;AAEA;;AAGA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+HA;;ACdA;;AAIA;AACA;;AAEA;AAEA;AACA;;AAwCA;AACA;AACA;AALA;;;;;AAWA;;AAEA;;AAMA;;AAqHA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;AAUA;AACA;AACA;;AAEA;;AAdA;AAEA;AACA;;;;;;AAiBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAIA;AACA;;;AAnbA;;AAwbA;;AAIA;;;;;;;AAiGA","sources":["webpack://lcn-frontend/./homeassistant-frontend/src/panels/config/ha-config-section.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-icon.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-state-icon.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-domain-icon.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-expansion-panel.ts","webpack://lcn-frontend/mwc-check-list-item-base.ts","webpack://lcn-frontend/./homeassistant-frontend/src/components/ha-check-list-item.ts","webpack://lcn-frontend/./src/components/lcn-filter-address.ts","webpack://lcn-frontend/./src/lcn-entities-page.ts"],"sourcesContent":["import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\n@customElement(\"ha-config-section\")\nexport class HaConfigSection extends LitElement {\n  @property({ type: Boolean }) public isWide = false;\n\n  @property({ type: Boolean }) public vertical = false;\n\n  @property({ type: Boolean, attribute: \"full-width\" })\n  public fullWidth = false;\n\n  protected render() {\n    return html`\n      <div\n        class=\"content ${classMap({\n          narrow: !this.isWide,\n          \"full-width\": this.fullWidth,\n        })}\"\n      >\n        <div class=\"header\"><slot name=\"header\"></slot></div>\n        <div\n          class=\"together layout ${classMap({\n            narrow: !this.isWide,\n            vertical: this.vertical || !this.isWide,\n            horizontal: !this.vertical && this.isWide,\n          })}\"\n        >\n          <div class=\"intro\"><slot name=\"introduction\"></slot></div>\n          <div class=\"panel flex-auto\"><slot></slot></div>\n        </div>\n      </div>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: block;\n      }\n      .content {\n        padding: 28px 20px 0;\n        max-width: 1040px;\n        margin: 0 auto;\n      }\n\n      .layout {\n        display: flex;\n      }\n\n      .horizontal {\n        flex-direction: row;\n      }\n\n      .vertical {\n        flex-direction: column;\n      }\n\n      .flex-auto {\n        flex: 1 1 auto;\n      }\n\n      .header {\n        font-family: var(--paper-font-headline_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-headline_-_-webkit-font-smoothing\n        );\n        font-size: var(--paper-font-headline_-_font-size);\n        font-weight: var(--paper-font-headline_-_font-weight);\n        letter-spacing: var(--paper-font-headline_-_letter-spacing);\n        line-height: var(--paper-font-headline_-_line-height);\n        opacity: var(--dark-primary-opacity);\n      }\n\n      .together {\n        margin-top: 32px;\n      }\n\n      .intro {\n        font-family: var(--paper-font-subhead_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-subhead_-_-webkit-font-smoothing\n        );\n        font-weight: var(--paper-font-subhead_-_font-weight);\n        line-height: var(--paper-font-subhead_-_line-height);\n        width: 100%;\n        opacity: var(--dark-primary-opacity);\n        font-size: 14px;\n        padding-bottom: 20px;\n      }\n\n      .horizontal .intro {\n        max-width: 400px;\n        margin-right: 40px;\n        margin-inline-end: 40px;\n        margin-inline-start: initial;\n      }\n\n      .panel {\n        margin-top: -24px;\n      }\n\n      .panel ::slotted(*) {\n        margin-top: 24px;\n        display: block;\n      }\n\n      .narrow.content {\n        max-width: 640px;\n      }\n      .narrow .together {\n        margin-top: 20px;\n      }\n      .narrow .intro {\n        padding-bottom: 20px;\n        margin-right: 0;\n        margin-inline-end: 0;\n        margin-inline-start: initial;\n        max-width: 500px;\n      }\n\n      .full-width {\n        padding: 0;\n      }\n\n      .full-width .layout {\n        flex-direction: column;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-config-section\": HaConfigSection;\n  }\n}\n","import type { CSSResultGroup, PropertyValues } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { debounce } from \"../common/util/debounce\";\nimport type { CustomIcon } from \"../data/custom_icons\";\nimport { customIcons } from \"../data/custom_icons\";\nimport type { Chunks, Icons } from \"../data/iconsets\";\nimport {\n  MDI_PREFIXES,\n  findIconChunk,\n  getIcon,\n  writeCache,\n} from \"../data/iconsets\";\nimport \"./ha-svg-icon\";\n\ninterface DeprecatedIcon {\n  [key: string]: {\n    removeIn: string;\n    newName?: string;\n  };\n}\n\nconst mdiDeprecatedIcons: DeprecatedIcon = {};\n\nconst chunks: Chunks = {};\n\nconst debouncedWriteCache = debounce(() => writeCache(chunks), 2000);\n\nconst cachedIcons: Record<string, string> = {};\n\n@customElement(\"ha-icon\")\nexport class HaIcon extends LitElement {\n  @property() public icon?: string;\n\n  @state() private _path?: string;\n\n  @state() private _secondaryPath?: string;\n\n  @state() private _viewBox?: string;\n\n  @state() private _legacy = false;\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"icon\")) {\n      this._path = undefined;\n      this._secondaryPath = undefined;\n      this._viewBox = undefined;\n      this._loadIcon();\n    }\n  }\n\n  protected render() {\n    if (!this.icon) {\n      return nothing;\n    }\n    if (this._legacy) {\n      return html`<!-- @ts-ignore we don't provice the iron-icon element -->\n        <iron-icon .icon=${this.icon}></iron-icon>`;\n    }\n    return html`<ha-svg-icon\n      .path=${this._path}\n      .secondaryPath=${this._secondaryPath}\n      .viewBox=${this._viewBox}\n    ></ha-svg-icon>`;\n  }\n\n  private async _loadIcon() {\n    if (!this.icon) {\n      return;\n    }\n    const requestedIcon = this.icon;\n    const [iconPrefix, origIconName] = this.icon.split(\":\", 2);\n\n    let iconName = origIconName;\n\n    if (!iconPrefix || !iconName) {\n      return;\n    }\n\n    if (!MDI_PREFIXES.includes(iconPrefix)) {\n      const customIcon = customIcons[iconPrefix];\n      if (customIcon) {\n        if (customIcon && typeof customIcon.getIcon === \"function\") {\n          this._setCustomPath(customIcon.getIcon(iconName), requestedIcon);\n        }\n        return;\n      }\n      this._legacy = true;\n      return;\n    }\n\n    this._legacy = false;\n\n    if (iconName in mdiDeprecatedIcons) {\n      const deprecatedIcon = mdiDeprecatedIcons[iconName];\n      let message: string;\n\n      if (deprecatedIcon.newName) {\n        message = `Icon ${iconPrefix}:${iconName} was renamed to ${iconPrefix}:${deprecatedIcon.newName}, please change your config, it will be removed in version ${deprecatedIcon.removeIn}.`;\n        iconName = deprecatedIcon.newName!;\n      } else {\n        message = `Icon ${iconPrefix}:${iconName} was removed from MDI, please replace this icon with an other icon in your config, it will be removed in version ${deprecatedIcon.removeIn}.`;\n      }\n      // eslint-disable-next-line no-console\n      console.warn(message);\n      fireEvent(this, \"write_log\", {\n        level: \"warning\",\n        message,\n      });\n    }\n\n    if (iconName in cachedIcons) {\n      this._path = cachedIcons[iconName];\n      return;\n    }\n\n    if (iconName === \"home-assistant\") {\n      const icon = (await import(\"../resources/home-assistant-logo-svg\"))\n        .mdiHomeAssistant;\n\n      if (this.icon === requestedIcon) {\n        this._path = icon;\n      }\n      cachedIcons[iconName] = icon;\n      return;\n    }\n\n    let databaseIcon: string | undefined;\n    try {\n      databaseIcon = await getIcon(iconName);\n    } catch (_err) {\n      // Firefox in private mode doesn't support IDB\n      // iOS Safari sometimes doesn't open the DB\n      databaseIcon = undefined;\n    }\n\n    if (databaseIcon) {\n      if (this.icon === requestedIcon) {\n        this._path = databaseIcon;\n      }\n      cachedIcons[iconName] = databaseIcon;\n      return;\n    }\n    const chunk = findIconChunk(iconName);\n\n    if (chunk in chunks) {\n      this._setPath(chunks[chunk], iconName, requestedIcon);\n      return;\n    }\n\n    const iconPromise = fetch(`/static/mdi/${chunk}.json`).then((response) =>\n      response.json()\n    );\n    chunks[chunk] = iconPromise;\n    this._setPath(iconPromise, iconName, requestedIcon);\n    debouncedWriteCache();\n  }\n\n  private async _setCustomPath(\n    promise: Promise<CustomIcon>,\n    requestedIcon: string\n  ) {\n    const icon = await promise;\n    if (this.icon !== requestedIcon) {\n      return;\n    }\n    this._path = icon.path;\n    this._secondaryPath = icon.secondaryPath;\n    this._viewBox = icon.viewBox;\n  }\n\n  private async _setPath(\n    promise: Promise<Icons>,\n    iconName: string,\n    requestedIcon: string\n  ) {\n    const iconPack = await promise;\n    if (this.icon === requestedIcon) {\n      this._path = iconPack[iconName];\n    }\n    cachedIcons[iconName] = iconPack[iconName];\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        fill: currentcolor;\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon\": HaIcon;\n  }\n}\n","import type { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_DOMAIN_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { computeStateDomain } from \"../common/entity/compute_state_domain\";\nimport { entityIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-state-icon\")\nexport class HaStateIcon extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: HassEntity;\n\n  @property({ attribute: false }) public stateValue?: string;\n\n  @property() public icon?: string;\n\n  protected render() {\n    const overrideIcon =\n      this.icon ||\n      (this.stateObj && this.hass?.entities[this.stateObj.entity_id]?.icon) ||\n      this.stateObj?.attributes.icon;\n    if (overrideIcon) {\n      return html`<ha-icon .icon=${overrideIcon}></ha-icon>`;\n    }\n    if (!this.stateObj) {\n      return nothing;\n    }\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n    const icon = entityIcon(this.hass, this.stateObj, this.stateValue).then(\n      (icn) => {\n        if (icn) {\n          return html`<ha-icon .icon=${icn}></ha-icon>`;\n        }\n        return this._renderFallback();\n      }\n    );\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    const domain = computeStateDomain(this.stateObj!);\n\n    return html`\n      <ha-svg-icon\n        .path=${FIXED_DOMAIN_ICONS[domain] || DEFAULT_DOMAIN_ICON}\n      ></ha-svg-icon>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-icon\": HaStateIcon;\n  }\n}\n","import type { CSSResultGroup } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { until } from \"lit/directives/until\";\nimport { DEFAULT_DOMAIN_ICON, FIXED_DOMAIN_ICONS } from \"../common/const\";\nimport { domainIcon } from \"../data/icons\";\nimport type { HomeAssistant } from \"../types\";\nimport { brandsUrl } from \"../util/brands-url\";\nimport \"./ha-icon\";\n\n@customElement(\"ha-domain-icon\")\nexport class HaDomainIcon extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public domain?: string;\n\n  @property() public deviceClass?: string;\n\n  @property() public icon?: string;\n\n  @property({ type: Boolean }) public brandFallback?: boolean;\n\n  protected render() {\n    if (this.icon) {\n      return html`<ha-icon .icon=${this.icon}></ha-icon>`;\n    }\n\n    if (!this.domain) {\n      return nothing;\n    }\n\n    if (!this.hass) {\n      return this._renderFallback();\n    }\n\n    const icon = domainIcon(this.hass, this.domain, this.deviceClass).then(\n      (icn) => {\n        if (icn) {\n          return html`<ha-icon .icon=${icn}></ha-icon>`;\n        }\n        return this._renderFallback();\n      }\n    );\n\n    return html`${until(icon)}`;\n  }\n\n  private _renderFallback() {\n    if (this.domain! in FIXED_DOMAIN_ICONS) {\n      return html`\n        <ha-svg-icon .path=${FIXED_DOMAIN_ICONS[this.domain!]}></ha-svg-icon>\n      `;\n    }\n    if (this.brandFallback) {\n      const image = brandsUrl({\n        domain: this.domain!,\n        type: \"icon\",\n        darkOptimized: this.hass.themes?.darkMode,\n      });\n      return html`\n        <img\n          alt=\"\"\n          src=${image}\n          crossorigin=\"anonymous\"\n          referrerpolicy=\"no-referrer\"\n        />\n      `;\n    }\n    return html`<ha-svg-icon .path=${DEFAULT_DOMAIN_ICON}></ha-svg-icon>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      img {\n        width: var(--mdc-icon-size, 24px);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-domain-icon\": HaDomainIcon;\n  }\n}\n","import { mdiChevronDown } from \"@mdi/js\";\nimport type { CSSResultGroup, PropertyValues, TemplateResult } from \"lit\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { nextRender } from \"../common/util/render-status\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-expansion-panel\")\nexport class HaExpansionPanel extends LitElement {\n  @property({ type: Boolean, reflect: true }) expanded = false;\n\n  @property({ type: Boolean, reflect: true }) outlined = false;\n\n  @property({ type: Boolean, reflect: true }) leftChevron = false;\n\n  @property({ type: Boolean, reflect: true }) noCollapse = false;\n\n  @property() header?: string;\n\n  @property() secondary?: string;\n\n  @state() _showContent = this.expanded;\n\n  @query(\".container\") private _container!: HTMLDivElement;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"top ${classMap({ expanded: this.expanded })}\">\n        <div\n          id=\"summary\"\n          class=${classMap({ noCollapse: this.noCollapse })}\n          @click=${this._toggleContainer}\n          @keydown=${this._toggleContainer}\n          @focus=${this._focusChanged}\n          @blur=${this._focusChanged}\n          role=\"button\"\n          tabindex=${this.noCollapse ? -1 : 0}\n          aria-expanded=${this.expanded}\n          aria-controls=\"sect1\"\n        >\n          ${this.leftChevron && !this.noCollapse\n            ? html`\n                <ha-svg-icon\n                  .path=${mdiChevronDown}\n                  class=\"summary-icon ${classMap({ expanded: this.expanded })}\"\n                ></ha-svg-icon>\n              `\n            : \"\"}\n          <slot name=\"header\">\n            <div class=\"header\">\n              ${this.header}\n              <slot class=\"secondary\" name=\"secondary\">${this.secondary}</slot>\n            </div>\n          </slot>\n          ${!this.leftChevron && !this.noCollapse\n            ? html`\n                <ha-svg-icon\n                  .path=${mdiChevronDown}\n                  class=\"summary-icon ${classMap({ expanded: this.expanded })}\"\n                ></ha-svg-icon>\n              `\n            : \"\"}\n          <slot name=\"icons\"></slot>\n        </div>\n      </div>\n      <div\n        class=\"container ${classMap({ expanded: this.expanded })}\"\n        @transitionend=${this._handleTransitionEnd}\n        role=\"region\"\n        aria-labelledby=\"summary\"\n        aria-hidden=${!this.expanded}\n        tabindex=\"-1\"\n      >\n        ${this._showContent ? html`<slot></slot>` : \"\"}\n      </div>\n    `;\n  }\n\n  protected willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"expanded\")) {\n      this._showContent = this.expanded;\n      setTimeout(() => {\n        // Verify we're still expanded\n        this._container.style.overflow = this.expanded ? \"initial\" : \"hidden\";\n      }, 300);\n    }\n  }\n\n  private _handleTransitionEnd() {\n    this._container.style.removeProperty(\"height\");\n    this._container.style.overflow = this.expanded ? \"initial\" : \"hidden\";\n    this._showContent = this.expanded;\n  }\n\n  private async _toggleContainer(ev): Promise<void> {\n    if (ev.defaultPrevented) {\n      return;\n    }\n    if (ev.type === \"keydown\" && ev.key !== \"Enter\" && ev.key !== \" \") {\n      return;\n    }\n    ev.preventDefault();\n    if (this.noCollapse) {\n      return;\n    }\n    const newExpanded = !this.expanded;\n    fireEvent(this, \"expanded-will-change\", { expanded: newExpanded });\n    this._container.style.overflow = \"hidden\";\n\n    if (newExpanded) {\n      this._showContent = true;\n      // allow for dynamic content to be rendered\n      await nextRender();\n    }\n\n    const scrollHeight = this._container.scrollHeight;\n    this._container.style.height = `${scrollHeight}px`;\n\n    if (!newExpanded) {\n      setTimeout(() => {\n        this._container.style.height = \"0px\";\n      }, 0);\n    }\n\n    this.expanded = newExpanded;\n    fireEvent(this, \"expanded-changed\", { expanded: this.expanded });\n  }\n\n  private _focusChanged(ev) {\n    if (this.noCollapse) {\n      return;\n    }\n    this.shadowRoot!.querySelector(\".top\")!.classList.toggle(\n      \"focused\",\n      ev.type === \"focus\"\n    );\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n\n      .top {\n        display: flex;\n        align-items: center;\n        border-radius: var(--ha-card-border-radius, 12px);\n      }\n\n      .top.expanded {\n        border-bottom-left-radius: 0px;\n        border-bottom-right-radius: 0px;\n      }\n\n      .top.focused {\n        background: var(--input-fill-color);\n      }\n\n      :host([outlined]) {\n        box-shadow: none;\n        border-width: 1px;\n        border-style: solid;\n        border-color: var(--outline-color);\n        border-radius: var(--ha-card-border-radius, 12px);\n      }\n\n      .summary-icon {\n        transition: transform 150ms cubic-bezier(0.4, 0, 0.2, 1);\n        direction: var(--direction);\n        margin-left: 8px;\n        margin-inline-start: 8px;\n        margin-inline-end: initial;\n      }\n\n      :host([leftchevron]) .summary-icon {\n        margin-left: 0;\n        margin-right: 8px;\n        margin-inline-start: 0;\n        margin-inline-end: 8px;\n      }\n\n      #summary {\n        flex: 1;\n        display: flex;\n        padding: var(--expansion-panel-summary-padding, 0 8px);\n        min-height: 48px;\n        align-items: center;\n        cursor: pointer;\n        overflow: hidden;\n        font-weight: 500;\n        outline: none;\n      }\n      #summary.noCollapse {\n        cursor: default;\n      }\n\n      .summary-icon.expanded {\n        transform: rotate(180deg);\n      }\n\n      .header,\n      ::slotted([slot=\"header\"]) {\n        flex: 1;\n      }\n\n      .container {\n        padding: var(--expansion-panel-content-padding, 0 8px);\n        overflow: hidden;\n        transition: height 300ms cubic-bezier(0.4, 0, 0.2, 1);\n        height: 0px;\n      }\n\n      .container.expanded {\n        height: auto;\n      }\n\n      .secondary {\n        display: block;\n        color: var(--secondary-text-color);\n        font-size: 12px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-expansion-panel\": HaExpansionPanel;\n  }\n\n  // for fire event\n  interface HASSDomEvents {\n    \"expanded-changed\": {\n      expanded: boolean;\n    };\n    \"expanded-will-change\": {\n      expanded: boolean;\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\nimport '@material/mwc-checkbox/mwc-checkbox.js';\n\nimport {Checkbox} from '@material/mwc-checkbox/mwc-checkbox.js';\nimport {html} from 'lit';\nimport {property, query} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nimport {GraphicType, ListItemBase} from './mwc-list-item-base.js';\n\nexport class CheckListItemBase extends ListItemBase {\n  @query('slot') protected override slotElement!: HTMLSlotElement|null;\n  @query('mwc-checkbox') protected checkboxElement!: Checkbox;\n\n  @property({type: Boolean}) left = false;\n  @property({type: String, reflect: true})\n  override graphic: GraphicType = 'control';\n\n  override render() {\n    const checkboxClasses = {\n      'mdc-deprecated-list-item__graphic': this.left,\n      'mdc-deprecated-list-item__meta': !this.left,\n    };\n\n    const text = this.renderText();\n    const graphic = this.graphic && this.graphic !== 'control' && !this.left ?\n        this.renderGraphic() :\n        html``;\n    const meta = this.hasMeta && this.left ? this.renderMeta() : html``;\n    const ripple = this.renderRipple();\n\n    return html`\n      ${ripple}\n      ${graphic}\n      ${this.left ? '' : text}\n      <span class=${classMap(checkboxClasses)}>\n        <mwc-checkbox\n            reducedTouchTarget\n            tabindex=${this.tabindex}\n            .checked=${this.selected}\n            ?disabled=${this.disabled}\n            @change=${this.onChange}>\n        </mwc-checkbox>\n      </span>\n      ${this.left ? text : ''}\n      ${meta}`;\n  }\n\n  protected async onChange(evt: Event) {\n    const checkbox = evt.target as Checkbox;\n    const changeFromProp = this.selected === checkbox.checked;\n\n    if (!changeFromProp) {\n      this._skipPropRequest = true;\n      this.selected = checkbox.checked;\n      await this.updateComplete;\n      this._skipPropRequest = false;\n    }\n  }\n}\n","import { css } from \"lit\";\nimport { CheckListItemBase } from \"@material/mwc-list/mwc-check-list-item-base\";\nimport { styles as controlStyles } from \"@material/mwc-list/mwc-control-list-item.css\";\nimport { styles } from \"@material/mwc-list/mwc-list-item.css\";\nimport { customElement } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\n\n@customElement(\"ha-check-list-item\")\nexport class HaCheckListItem extends CheckListItemBase {\n  async onChange(event) {\n    super.onChange(event);\n    fireEvent(this, event.type);\n  }\n\n  static override styles = [\n    styles,\n    controlStyles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--primary-color);\n      }\n\n      :host([graphic=\"avatar\"]) .mdc-deprecated-list-item__graphic,\n      :host([graphic=\"medium\"]) .mdc-deprecated-list-item__graphic,\n      :host([graphic=\"large\"]) .mdc-deprecated-list-item__graphic,\n      :host([graphic=\"control\"]) .mdc-deprecated-list-item__graphic {\n        margin-inline-end: var(--mdc-list-item-graphic-margin, 16px);\n        margin-inline-start: 0px;\n        direction: var(--direction);\n      }\n      .mdc-deprecated-list-item__meta {\n        flex-shrink: 0;\n        direction: var(--direction);\n        margin-inline-start: auto;\n        margin-inline-end: 0;\n      }\n      .mdc-deprecated-list-item__graphic {\n        margin-top: var(--check-list-item-graphic-margin-top);\n      }\n      :host([graphic=\"icon\"]) .mdc-deprecated-list-item__graphic {\n        margin-inline-start: 0;\n        margin-inline-end: var(--mdc-list-item-graphic-margin, 32px);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-check-list-item\": HaCheckListItem;\n  }\n}\n","import { mdiFilterVariantRemove } from \"@mdi/js\";\nimport { css, CSSResultGroup, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"@ha/common/dom/fire_event\";\nimport type { HomeAssistant } from \"@ha/types\";\nimport { haStyleScrollbar } from \"@ha/resources/styles\";\nimport { LCN, LcnAddress, LcnDeviceConfig } from \"types/lcn\";\nimport \"@ha/components/ha-domain-icon\";\nimport \"@ha/components/search-input-outlined\";\nimport \"@ha/components/ha-expansion-panel\";\nimport \"@ha/components/ha-icon-button\";\nimport \"@ha/components/ha-icon\";\nimport \"@ha/components/ha-check-list-item\";\nimport { addressToString, stringToAddress } from \"helpers/address_conversion\";\nimport { stringCompare } from \"@ha/common/string/compare\";\n\n@customElement(\"lcn-filter-address\")\nexport class HaFilterDomains extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public lcn!: LCN;\n\n  @property({ attribute: false }) public deviceConfigs!: LcnDeviceConfig[];\n\n  @property({ attribute: false }) public value?: string[];\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @property({ type: Boolean, reflect: true }) public expanded = false;\n\n  @state() private _shouldRender = false;\n\n  @state() private _filter?: string;\n\n  protected render() {\n    return html`\n      <ha-expansion-panel\n        leftChevron\n        .expanded=${this.expanded}\n        @expanded-will-change=${this._expandedWillChange}\n        @expanded-changed=${this._expandedChanged}\n      >\n        <div slot=\"header\" class=\"header\">\n          ${this.lcn.localize(\"devices\")}/${this.lcn.localize(\"addresses\")}\n          ${this.value?.length\n            ? html`<div class=\"badge\">${this.value?.length}</div>\n                <ha-icon-button\n                  .path=${mdiFilterVariantRemove}\n                  @click=${this._clearFilter}\n                ></ha-icon-button>`\n            : nothing}\n        </div>\n        ${this._shouldRender\n          ? html`<search-input-outlined\n                .hass=${this.hass}\n                .filter=${this._filter}\n                @value-changed=${this._handleSearchChange}\n              ></search-input-outlined>\n\n              <mwc-list class=\"ha-scrollbar\" multi @click=${this._handleItemClick}>\n                ${this._addresses(this.deviceConfigs, this._filter).map(\n                  (address_str: string) =>\n                    html`<ha-check-list-item\n                      .value=${address_str}\n                      .selected=${(this.value || []).includes(address_str)}\n                    >\n                      ${this._address_repr(address_str)}\n                    </ha-check-list-item>`,\n                )}\n              </mwc-list>`\n          : nothing}\n      </ha-expansion-panel>\n    `;\n  }\n\n  private _addresses = memoizeOne((deviceConfigs, filter) => {\n    const addresses = new Set<string>();\n    deviceConfigs.forEach((deviceConfig) => {\n      addresses.add(addressToString(deviceConfig.address));\n    });\n    return Array.from(addresses.values())\n      .map((address_str) => ({\n        address_str,\n        name: this._address_repr(address_str),\n      }))\n      .filter(\n        (entry) =>\n          !filter ||\n          entry.address_str.toLowerCase().includes(filter) ||\n          entry.name.toLowerCase().includes(filter),\n      )\n      .sort((a, b) => stringCompare(a.name, b.name, this.hass.locale.language))\n      .map((entry) => entry.address_str);\n  });\n\n  private _address_repr(address_str: string): string {\n    const address: LcnAddress = stringToAddress(address_str);\n    const device = address[2] ? this.lcn.localize(\"group\") : this.lcn.localize(\"module\");\n    const segment_id = address[0];\n    const address_id = address[1];\n    const result: string = `${device} (${segment_id}, ${address_id})`;\n    return result;\n  }\n\n  protected updated(changed) {\n    if (changed.has(\"expanded\") && this.expanded) {\n      setTimeout(() => {\n        if (!this.expanded) return;\n        this.renderRoot.querySelector(\"mwc-list\")!.style.height =\n          `${this.clientHeight - 49 - 32}px`; // 32px is the height of the search input\n      }, 300);\n    }\n  }\n\n  private _expandedWillChange(ev) {\n    this._shouldRender = ev.detail.expanded;\n  }\n\n  private _expandedChanged(ev) {\n    this.expanded = ev.detail.expanded;\n  }\n\n  private _handleItemClick(ev) {\n    const listItem = ev.target.closest(\"ha-check-list-item\");\n    const value = listItem?.value;\n    if (!value) {\n      return;\n    }\n    if (this.value?.includes(value)) {\n      this.value = this.value?.filter((val) => val !== value);\n    } else {\n      this.value = [...(this.value || []), value];\n    }\n\n    listItem.selected = this.value.includes(value);\n\n    fireEvent(this, \"data-table-filter-changed\", {\n      value: this.value,\n      items: undefined,\n    });\n  }\n\n  private _clearFilter(ev) {\n    ev.preventDefault();\n    this.value = undefined;\n    fireEvent(this, \"data-table-filter-changed\", {\n      value: undefined,\n      items: undefined,\n    });\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    this._filter = ev.detail.value.toLowerCase();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyleScrollbar,\n      css`\n        :host {\n          border-bottom: 1px solid var(--divider-color);\n        }\n        :host([expanded]) {\n          flex: 1;\n          height: 0;\n        }\n        ha-expansion-panel {\n          --ha-card-border-radius: 0;\n          --expansion-panel-content-padding: 0;\n        }\n        .header {\n          display: flex;\n          align-items: center;\n        }\n        .header ha-icon-button {\n          margin-inline-start: initial;\n          margin-inline-end: 8px;\n        }\n        .badge {\n          display: inline-block;\n          margin-left: 8px;\n          margin-inline-start: 8px;\n          margin-inline-end: initial;\n          min-width: 16px;\n          box-sizing: border-box;\n          border-radius: 50%;\n          font-weight: 400;\n          font-size: 11px;\n          background-color: var(--primary-color);\n          line-height: 16px;\n          text-align: center;\n          padding: 0px 2px;\n          color: var(--text-primary-color);\n        }\n        search-input-outlined {\n          display: block;\n          padding: 0 8px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"lcn-filter-address\": HaFilterDomains;\n  }\n}\n","import { consume } from \"@lit-labs/context\";\nimport { deviceConfigsContext, entityConfigsContext } from \"components/context\";\nimport { fullEntitiesContext } from \"@ha/data/context\";\nimport { haStyle } from \"@ha/resources/styles\";\nimport { EntityRegistryEntry } from \"@ha/data/entity_registry\";\nimport { css, html, LitElement, CSSResultGroup, nothing, PropertyValues } from \"lit\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { customElement, property, state, queryAsync } from \"lit/decorators\";\nimport { mdiPlus, mdiDelete } from \"@mdi/js\";\nimport type { HomeAssistant, Route } from \"@ha/types\";\nimport { computeDomain } from \"@ha/common/entity/compute_domain\";\nimport \"@ha/layouts/hass-tabs-subpage-data-table\";\nimport type { HaTabsSubpageDataTable } from \"@ha/layouts/hass-tabs-subpage-data-table\";\nimport memoize from \"memoize-one\";\nimport { storage } from \"@ha/common/decorators/storage\";\nimport \"@ha/panels/config/ha-config-section\";\nimport \"@ha/components/ha-svg-icon\";\nimport \"@ha/components/ha-icon\";\nimport \"@ha/components/ha-icon-button\";\nimport \"@ha/components/ha-state-icon\";\nimport \"@ha/components/ha-domain-icon\";\nimport \"@ha/components/ha-fab\";\nimport { mainWindow } from \"@ha/common/dom/get_main_window\";\nimport {\n  LCN,\n  addEntity,\n  deleteEntity,\n  LcnDeviceConfig,\n  LcnEntityConfig,\n  LcnAddress,\n} from \"types/lcn\";\nimport { updateEntityConfigs } from \"components/events\";\nimport type { HASSDomEvent } from \"@ha/common/dom/fire_event\";\nimport type {\n  DataTableColumnContainer,\n  RowClickedEvent,\n  SelectionChangedEvent,\n  SortingChangedEvent,\n} from \"@ha/components/data-table/ha-data-table\";\nimport { fireEvent } from \"@ha/common/dom/fire_event\";\nimport { addressToString, stringToAddress } from \"helpers/address_conversion\";\nimport { lcnMainTabs } from \"lcn-router\";\nimport { DataTableFiltersItems, DataTableFiltersValues } from \"@ha/data/data_table_filters\";\nimport { renderBrandLogo } from \"helpers/brand_logo\";\nimport {\n  loadLCNCreateEntityDialog,\n  showLCNCreateEntityDialog,\n} from \"./dialogs/show-dialog-create-entity\";\nimport \"components/lcn-filter-address\";\n\nexport interface EntityRowData extends LcnEntityConfig {\n  unique_id: string;\n  address_str: string;\n  entityRegistryEntry: EntityRegistryEntry;\n}\n\nfunction createUniqueEntityId(entity: LcnEntityConfig, includeDomain: boolean = true): string {\n  let unique_id = `${addressToString(entity.address)}-${entity.resource}`;\n  if (includeDomain) {\n    unique_id = `${entity.domain}-` + unique_id;\n  }\n  return unique_id;\n}\n\nfunction parseUniqueEntityId(unique_id: string): {\n  address: LcnAddress;\n  domain: string;\n  resource: string;\n} {\n  const splitted = unique_id.split(\"-\");\n  const resource = splitted.pop()!;\n  const address_str = splitted.pop();\n  const domain = splitted.pop()!;\n  const address = stringToAddress(address_str!);\n  const result = { address: address, domain: domain, resource: resource };\n  return result;\n}\n\n@customElement(\"lcn-entities-page\")\nexport class LCNEntitiesPage extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public lcn!: LCN;\n\n  @property({ attribute: false }) public narrow!: boolean;\n\n  @property({ attribute: false }) public route!: Route;\n\n  @state() private _deviceConfig: LcnDeviceConfig | undefined;\n\n  @state()\n  @consume({ context: deviceConfigsContext, subscribe: true })\n  _deviceConfigs!: LcnDeviceConfig[];\n\n  @state()\n  @consume({ context: entityConfigsContext, subscribe: true })\n  _entityConfigs!: LcnEntityConfig[];\n\n  @state()\n  @consume({ context: fullEntitiesContext, subscribe: true })\n  _entityRegistryEntries!: EntityRegistryEntry[];\n\n  @storage({\n    storage: \"sessionStorage\",\n    key: \"entities-table-filters\",\n    state: true,\n    subscribe: false,\n  })\n  private _filters: DataTableFiltersValues = {};\n\n  @state() private _filteredItems: DataTableFiltersItems = {};\n\n  @state() private _selected: string[] = [];\n\n  @state() private _expandedFilter?: string;\n\n  @storage({\n    storage: \"sessionStorage\",\n    key: \"lcn-entities-table-search\",\n    state: true,\n    subscribe: false,\n  })\n  private _filter: string = history.state?.filter || \"\";\n\n  @state() private _searchParms = new URLSearchParams(mainWindow.location.search);\n\n  @storage({\n    storage: \"sessionStorage\",\n    key: \"lcn-entities-table-sort\",\n    state: false,\n    subscribe: false,\n  })\n  private _activeSorting?: SortingChangedEvent;\n\n  @storage({\n    key: \"lcn-entities-table-column-order\",\n    state: false,\n    subscribe: false,\n  })\n  private _activeColumnOrder?: string[];\n\n  @storage({\n    key: \"lcn-entities-table-hidden-columns\",\n    state: false,\n    subscribe: false,\n  })\n  private _activeHiddenColumns?: string[];\n\n  @queryAsync(\"hass-tabs-subpage-data-table\")\n  private _dataTable!: Promise<HaTabsSubpageDataTable>;\n\n  private get _extEntityConfigs(): EntityRowData[] {\n    const extEntityConfigs = memoize(\n      (\n        entityConfigs: LcnEntityConfig[] = this._entityConfigs,\n        entityRegistryEntries: EntityRegistryEntry[] = this._entityRegistryEntries,\n      ) =>\n        entityConfigs.map((entityConfig) => ({\n          ...entityConfig,\n          unique_id: createUniqueEntityId(entityConfig),\n          address_str: addressToString(entityConfig.address),\n          entityRegistryEntry: entityRegistryEntries.find(\n            (entry) =>\n              computeDomain(entry.entity_id) === entityConfig.domain &&\n              createUniqueEntityId(entityConfig, false) ===\n                entry.unique_id.split(\"-\").slice(1).join(\"-\"),\n          )!,\n        })),\n    );\n    return extEntityConfigs();\n  }\n\n  private _columns = memoize(\n    (): DataTableColumnContainer<EntityRowData> => ({\n      icon: {\n        title: \"\",\n        label: \"Icon\",\n        type: \"icon\",\n        showNarrow: true,\n        moveable: false,\n        template: (entry) =>\n          entry.entityRegistryEntry\n            ? entry.entityRegistryEntry.icon\n              ? html`<ha-icon .icon=${entry.entityRegistryEntry.icon}></ha-icon>`\n              : this.hass.states[entry.entityRegistryEntry.entity_id]\n                ? html`\n                    <ha-state-icon\n                      title=${ifDefined(\n                        this.hass.states[entry.entityRegistryEntry.entity_id].state,\n                      )}\n                      slot=\"item-icon\"\n                      .hass=${this.hass}\n                      .stateObj=${this.hass.states[entry.entityRegistryEntry.entity_id]}\n                    ></ha-state-icon>\n                  `\n                : html`<ha-domain-icon\n                    .domain=${computeDomain(entry.entityRegistryEntry.entity_id)}\n                  ></ha-domain-icon>`\n            : nothing,\n      },\n      name: {\n        main: true,\n        title: this.lcn.localize(\"name\"),\n        sortable: true,\n        filterable: true,\n        direction: \"asc\",\n        flex: 2,\n        template: (entry) =>\n          entry.entityRegistryEntry\n            ? entry.entityRegistryEntry.name || entry.entityRegistryEntry.original_name!\n            : entry.name,\n      },\n      address_str: {\n        title: this.lcn.localize(\"address\"),\n        sortable: true,\n        filterable: true,\n        direction: \"asc\",\n      },\n      domain: {\n        title: this.lcn.localize(\"domain\"),\n        sortable: true,\n        filterable: true,\n      },\n      resource: {\n        title: this.lcn.localize(\"resource\"),\n        sortable: true,\n        filterable: true,\n      },\n      delete: {\n        title: this.lcn.localize(\"delete\"),\n        showNarrow: true,\n        moveable: false,\n        type: \"icon-button\",\n        template: (entry) => {\n          const handler = (_ev) => this._deleteEntities([entry]);\n          return html`\n            <ha-icon-button\n              id=${\"delete-entity-\" + entry.unique_id.replace(\".\", \"-\")}\n              .label=${this.lcn.localize(\"dashboard-entities-table-delete\")}\n              .path=${mdiDelete}\n              @click=${handler}\n            ></ha-icon-button>\n            <simple-tooltip\n              animation-delay=\"0\"\n              offset=\"0\"\n              for=${\"delete-entity-\" + entry.unique_id.replace(\".\", \"-\")}\n            >\n              ${this.lcn.localize(\"dashboard-entities-table-delete\")}\n            </simple-tooltip>\n          `;\n        },\n      },\n    }),\n  );\n\n  private _filteredEntities = memoize(\n    (\n      filters: DataTableFiltersValues,\n      filteredItems: DataTableFiltersItems,\n      entities: EntityRowData[],\n    ) => {\n      let filteredEntityConfigs = entities;\n\n      Object.entries(filters).forEach(([key, filter]) => {\n        if (key === \"lcn-filter-address\" && Array.isArray(filter) && filter.length) {\n          filteredEntityConfigs = filteredEntityConfigs.filter((entityConfig) =>\n            filter.includes(entityConfig.address_str),\n          );\n        }\n      });\n\n      Object.values(filteredItems).forEach((items) => {\n        if (items) {\n          filteredEntityConfigs = filteredEntityConfigs.filter((entityConfig) =>\n            items.has(entityConfig.unique_id),\n          );\n        }\n      });\n\n      return filteredEntityConfigs;\n    },\n  );\n\n  private _filterExpanded(ev) {\n    if (ev.detail.expanded) {\n      this._expandedFilter = ev.target.localName;\n    } else if (this._expandedFilter === ev.target.localName) {\n      this._expandedFilter = undefined;\n    }\n  }\n\n  private _filterChanged(ev) {\n    const type = ev.target.localName;\n\n    this._filters = { ...this._filters, [type]: ev.detail.value };\n    this._filteredItems = { ...this._filteredItems, [type]: ev.detail.items };\n\n    this.updateFilteredDevice();\n  }\n\n  private updateFilteredDevice() {\n    let address: LcnAddress;\n    if (\n      \"lcn-filter-address\" in this._filters &&\n      this._filters[\"lcn-filter-address\"] &&\n      this._filters[\"lcn-filter-address\"][0]\n    ) {\n      address = stringToAddress(this._filters[\"lcn-filter-address\"][0]);\n    } else {\n      const filteredEntities = this._filteredEntities(\n        this._filters,\n        this._filteredItems,\n        this._extEntityConfigs,\n      );\n      if (filteredEntities.length === 0) {\n        this._deviceConfig = undefined;\n        return;\n      }\n      address = filteredEntities[0].address;\n    }\n    this._deviceConfig = this._deviceConfigs.find(\n      (deviceConfig) =>\n        deviceConfig.address[0] === address[0] &&\n        deviceConfig.address[1] === address[1] &&\n        deviceConfig.address[2] === address[2],\n    );\n  }\n\n  protected async firstUpdated(changedProperties: PropertyValues): Promise<void> {\n    super.firstUpdated(changedProperties);\n    loadLCNCreateEntityDialog();\n    updateEntityConfigs(this);\n    this._setFiltersFromUrl();\n  }\n\n  protected async updated(changedProperties: PropertyValues): Promise<void> {\n    super.updated(changedProperties);\n    this._dataTable.then(renderBrandLogo);\n  }\n\n  private _setFiltersFromUrl() {\n    const address_str = this._searchParms.get(\"address\");\n\n    if (!address_str && this._filters) {\n      this._filters = {};\n      return;\n    }\n\n    this._filter = history.state?.filter || \"\";\n\n    this._filters = {\n      \"lcn-filter-address\": address_str ? [address_str] : [],\n    };\n\n    this.updateFilteredDevice();\n  }\n\n  protected render() {\n    if (!(this.hass && this.lcn && this._deviceConfigs && this._entityConfigs)) {\n      return nothing;\n    }\n    const filteredEntities = this._filteredEntities(\n      this._filters,\n      this._filteredItems,\n      this._extEntityConfigs,\n    );\n\n    const hasFab = this._deviceConfigs.length > 0;\n    return html`\n      <hass-tabs-subpage-data-table\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        back-path=\"/lcn/devices\"\n        noDataText=${this._deviceConfigs.length === 0\n          ? this.lcn.localize(\"dashboard-entities-no-data-text-devices\")\n          : this.lcn.localize(\"dashboard-entities-no-data-text-entities\")}\n        .route=${this.route}\n        .tabs=${lcnMainTabs}\n        .localizeFunc=${this.lcn.localize}\n        .columns=${this._columns()}\n        .data=${filteredEntities}\n        hasFilters\n        .filters=${Object.values(this._filters).filter((filter) =>\n          Array.isArray(filter)\n            ? filter.length\n            : filter &&\n              Object.values(filter).some((val) => (Array.isArray(val) ? val.length : val)),\n        ).length}\n        selectable\n        .selected=${this._selected.length}\n        .initialSorting=${this._activeSorting}\n        .columnOrder=${this._activeColumnOrder}\n        .hiddenColumns=${this._activeHiddenColumns}\n        @columns-changed=${this._handleColumnsChanged}\n        @sorting-changed=${this._handleSortingChanged}\n        @selection-changed=${this._handleSelectionChanged}\n        clickable\n        @clear-filter=${this._clearFilter}\n        .filter=${this._filter}\n        @search-changed=${this._handleSearchChange}\n        @row-click=${this._openEditEntry}\n        id=\"unique_id\"\n        .hasfab=${hasFab}\n        class=${this.narrow ? \"narrow\" : \"\"}\n      >\n        <div class=\"header-btns\" slot=\"selection-bar\">\n          ${!this.narrow\n            ? html`\n                <mwc-button @click=${this._deleteSelected} class=\"warning\">\n                  ${this.lcn.localize(\"delete-selected\")}\n                </mwc-button>\n              `\n            : html`\n                <ha-icon-button\n                  class=\"warning\"\n                  id=\"remove-btn\"\n                  @click=${this._deleteSelected}\n                  .path=${mdiDelete}\n                  .label=${this.lcn.localize(\"delete-selected\")}\n                ></ha-icon-button>\n                <ha-help-tooltip .label=${this.lcn.localize(\"delete-selected\")} )}>\n                </ha-help-tooltip>\n              `}\n        </div>\n\n        <lcn-filter-address\n          .hass=${this.hass}\n          .lcn=${this.lcn}\n          .value=${this._filters[\"lcn-filter-address\"]}\n          .deviceConfigs=${this._deviceConfigs}\n          @data-table-filter-changed=${this._filterChanged}\n          slot=\"filter-pane\"\n          .expanded=${this._expandedFilter === \"lcn-filter-address\"}\n          .narrow=${this.narrow}\n          @expanded-changed=${this._filterExpanded}\n        ></lcn-filter-address>\n\n        ${hasFab\n          ? html`\n              <ha-fab\n                slot=\"fab\"\n                @click=${this._addEntity}\n                .label=${this.lcn.localize(\"dashboard-entities-add\")}\n                extended\n              >\n                <ha-svg-icon slot=\"icon\" path=${mdiPlus}></ha-svg-icon>\n              </ha-fab>\n            `\n          : nothing}\n      </hass-tabs-subpage-data-table>\n    `;\n  }\n\n  private getEntityConfigByUniqueId(unique_id: string): LcnEntityConfig {\n    const { address, domain, resource } = parseUniqueEntityId(unique_id);\n    const entityConfig = this._entityConfigs.find(\n      (el) =>\n        el.address[0] === address[0] &&\n        el.address[1] === address[1] &&\n        el.address[2] === address[2] &&\n        el.domain === domain &&\n        el.resource === resource,\n    );\n    return entityConfig!;\n  }\n\n  private async _openEditEntry(ev: CustomEvent): Promise<void> {\n    const unique_id = (ev.detail as RowClickedEvent).id;\n    const entityConfig = this.getEntityConfigByUniqueId(unique_id);\n    const entityRegistryEntry = this._entityRegistryEntries.find(\n      (entry) =>\n        computeDomain(entry.entity_id) === entityConfig.domain &&\n        createUniqueEntityId(entityConfig, false) === entry.unique_id.split(\"-\").slice(1).join(\"-\"),\n    )!;\n\n    fireEvent(mainWindow.document.querySelector(\"home-assistant\")!, \"hass-more-info\", {\n      entityId: entityRegistryEntry.entity_id,\n    });\n  }\n\n  private async _addEntity() {\n    showLCNCreateEntityDialog(this, {\n      lcn: this.lcn,\n      deviceConfig: <LcnDeviceConfig>this._deviceConfig,\n      createEntity: async (entityParams) => {\n        if (await addEntity(this.hass, this.lcn.config_entry, entityParams)) {\n          updateEntityConfigs(this);\n          return true;\n        }\n        return false;\n      },\n    });\n  }\n\n  private async _deleteSelected() {\n    const entities = this._selected.map((unique_id) => this.getEntityConfigByUniqueId(unique_id));\n    this._deleteEntities(entities);\n    this._clearSelection();\n  }\n\n  private async _deleteEntities(entities: LcnEntityConfig[]) {\n    if (entities.length === 0) return;\n    for await (const entity of entities) {\n      await deleteEntity(this.hass, this.lcn.config_entry, entity);\n    }\n    updateEntityConfigs(this);\n  }\n\n  private async _clearSelection() {\n    (await this._dataTable).clearSelection();\n  }\n\n  private _clearFilter() {\n    this._filters = {};\n    this._filteredItems = {};\n    this.updateFilteredDevice();\n  }\n\n  private _handleSortingChanged(ev: CustomEvent) {\n    this._activeSorting = ev.detail;\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    this._filter = ev.detail.value;\n    history.replaceState({ filter: this._filter }, \"\");\n  }\n\n  private _handleColumnsChanged(ev: CustomEvent) {\n    this._activeColumnOrder = ev.detail.columnOrder;\n    this._activeHiddenColumns = ev.detail.hiddenColumns;\n  }\n\n  private _handleSelectionChanged(ev: HASSDomEvent<SelectionChangedEvent>): void {\n    this._selected = ev.detail.value;\n  }\n\n  static get styles(): CSSResultGroup[] {\n    return [\n      haStyle,\n      css`\n        hass-tabs-subpage-data-table {\n          --data-table-row-height: 60px;\n        }\n        hass-tabs-subpage-data-table.narrow {\n          --data-table-row-height: 72px;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"lcn-entities-page\": LCNEntitiesPage;\n  }\n}\n"],"names":[],"sourceRoot":""}