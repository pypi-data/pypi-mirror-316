from __future__ import annotations
from flask import Flask, Response
from flask_openapi3 import OpenAPI
from pydantic import BaseModel, Field, ValidationError
from werkzeug.exceptions import HTTPException, BadRequest, InternalServerError
from typing import Union
import traceback


WITH_TRACEBACK : bool = False

def activate_traceback():
    global WITH_TRACEBACK
    WITH_TRACEBACK = True

    
def deactivate_traceback():
    global WITH_TRACEBACK
    WITH_TRACEBACK = False
    

def configure_app(app_builder: callable[Union[Flask,OpenAPI]], with_traceback: bool = False) -> Union[Flask,OpenAPI]:
    def handle(problem: ProblemDetailsError) -> Response:
        """
            Handle a ProblemDetailsError
            
            :param problem: The raised problem
            :type problem: ProblemDetailsError
        """
        return problem.to_http_response()
    def handle_validation_exception(error: ValidationError):
        """
            Handle a Validation Error
            
            :param error: The raised validation error
            :type error: ValidationError
        """
        bad_request_exception = BadRequest(f"Validation Failed! Error count: {error.error_count()}")
        return handle(from_exception(bad_request_exception, extras = error.errors()))
    def handle_exception(error: Exception):
        """
            Handle any error
            
            :param error: The raised error
            :type error: Exception
        """
        return handle(problem=from_exception(error))
    
    if with_traceback == True:
        activate_traceback()
    
    kwargs = {"validation_error_status" : 400, "validation_error_model" : ProblemDetails, "validation_error_callback": handle_validation_exception}
    app : Union[Flask, OpenAPI] = app_builder(kwargs)
    
    app.register_error_handler(ProblemDetailsError, handle)
    app.register_error_handler(Exception, handle_exception)
    
    return app

def from_exception(exception: Exception, extras: dict = {}) -> ProblemDetailsError:
    """
    ProblemDetails exception

    :param exception: The exception that caused the problem
    :type exception: Exception
    :param status: The HTTP status code generated by the origin server for this occurrence of the problem.
    :type status: int
    :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to
                    occurrence of the problem, except for purposes of localisation.
    :type title: str
    :param detail: An human readable explanation specific to this occurrence of the problem.
    :type detail: str
    
    :rtype ProblemDetailsError
    """
    
    status : int = InternalServerError.code
    title: str = InternalServerError.__name__
    detail : str = str(exception)
    type :str = exception.__class__.__name__
    
    if isinstance(exception, HTTPException):
        status = exception.code
        title = exception.__class__.__name__
        detail = exception.description
    
    return ProblemDetailsError(status=status, title= title, detail=detail, type = type, exception=exception, **extras)

class ProblemDetails(BaseModel):
    status: int = Field(..., description = "HTTP status code")
    title: str = Field(..., description = "A short, human-readable summary of the problem type")
    detail: str = Field(..., description = "An human readable explanation specific to this occurrence of the problem")
    type: str = Field(..., description = "An absolute URI that identifies the problem type")
    traceback : str = Field(None, description = "The stack trace of the problem")
    extras : dict = Field(None, description="An object with extra information")
    
class ProblemDetailsError(Exception):

    def __init__(self, status: int = None, title: str = None, detail: str = None, type: str = None, exception : Exception = None, **kwargs):
        """
        ProblemDetails exception

        :param status: The HTTP status code generated by the origin server for this occurrence of the problem.
        :type status: int
        :param title: A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to
                      occurrence of the problem, except for purposes of localisation.
        :type title: str
        :param detail: An human readable explanation specific to this occurrence of the problem.
        :type detail: str
        :param type: An absolute URI that identifies the problem type.  When dereferenced, it SHOULD provide
                     human-readable documentation for the problem type (e.g., using HTML).  When this member is not
                     present its value is assumed to be "about:blank".
        :type: type: str
        """
        self.problem = ProblemDetails(status=status, title=title, detail=detail, type=type, extras=kwargs)
        self.inner_exception : Exception = exception
     
        
    def to_dict(self, with_traceback: bool = None) -> dict:
        """
        Transforms the Problem exception into a dict

        :param with_traceback: if True, the last exception traceback will be included
        :type with_traceback: bool
        :return the problem in dict form
        :rtype dict
        """
        with_traceback : bool = WITH_TRACEBACK if with_traceback is None else with_traceback
        
        if with_traceback:
            self.problem.traceback = traceback.format_exc()
        return self.problem.model_dump()
    
    def to_json(self, with_traceback: bool = None) -> str:
        """
        Transforms the Problem exception into a dict

        :param with_traceback: if True, the last exception traceback will be included
        :type with_traceback: bool
        :return the problem in dict form
        :rtype str
        """
        with_traceback : bool = WITH_TRACEBACK if with_traceback is None else with_traceback
        
        if with_traceback:
            self.problem.traceback = traceback.format_exc()
        return self.problem.model_dump_json()

    def to_http_response(self, with_traceback: bool = None) -> Response:
        with_traceback : bool = WITH_TRACEBACK if with_traceback is None else with_traceback
        return Response(status=self.problem.status, response=self.to_json(), mimetype="application/json")