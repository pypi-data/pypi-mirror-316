/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/

/* binding */

/* harmony default export */

/* istanbul ignore else should not happen */

/* istanbul ignore if */

/* istanbul ignore if already caught in lexer */

/* istanbul ignore if should not happen */

/* istanbul ignore next */

/* istanbul ignore next should not happen */

/* reexport */

/**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */

/**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */

/**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */

/**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */

/**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */

/**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */

/**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */

/**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */

/**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */

/**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */

/**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */

/**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */

/**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */

/**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */

/**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */

/**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */

/**
     * Advance the parser by the `source` of one lexical token.
     */

/**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */

/**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */

/**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */

/**
     * Checks if the collection includes a value with the key `key`.
     */

/**
     * Checks if the document includes a value at `path`.
     */

/**
     * Checks if the document includes a value with the key `key`.
     */

/**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */

/**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */

/**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */

/**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */

/**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */

/**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */

/**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */

/**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */

/**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */

/**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */

/**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */

/**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */

/**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */

/**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */

/**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */

/**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */

/**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */

/**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */

/**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */

/**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */

/**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */

/**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */

/**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */

/**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */

/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */

/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */

/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */

/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */

/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */

/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */

/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */

/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */

/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */

/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */

/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */

/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */

/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */

/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */

/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */

/** @returns Array of lines split up as `[indent, content]` */

/** @returns `true` if `token` is a flow or block scalar; not an alias */

/** @returns `true` if last token is a newline */

/** A YAML representation of the document. */

/** A comment before this Document */

/** A comment immediately after this Document */

/** A plain JavaScript representation of this node. */

/** A pointer to `buffer`; the current position of the lexer. */

/** Adds a value to the document. */

/** Advance the composer by one CST token. */

/** Call at end of input to push out any remaining constructions */

/** Count of surrounding flow collection levels. */

/** Create a copy of this node.  */

/** Current indentation level */

/** Current input */

/** Current offset since the start of parsing */

/** Do not visit the children of the current item */

/** Do not visit the children of the current node */

/** Errors encountered during parsing. */

/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */

/** Find the item at `path` from `cst` as the root */

/** Get a printable representation of a lexer token */

/** Identify the type of a lexer token. May return `null` for unknown tokens. */

/** If true, next token is a scalar value */

/** If true, space and sequence indicators count as indentation */

/** Indentation level of the current line. */

/** Internal types handle bigint as number, because TS can't figure it out. */

/** Note: May modify input array */

/** On the same line with a block map key */

/** Parse an input string into a single YAML.Document */

/** Position of the next \n character. */

/** Remove the current item */

/** Remove the current node */

/** Start of doc-mode */

/** Stores the state of the lexer if reaching the end of incpomplete input */

/** Terminate visit traversal completely */

/** The byte order mark */

/** The doc-end marker `...`.  */

/** The source of the current token, set in parse() */

/** The type of the current token, set in parse() */

/** Top indicates the node that's currently being built */

/** Warnings encountered during parsing. */

/***/

// - '#' not preceded by a non-space char

// - '\n ', ': ' or ' \n' anywhere

// - empty string, '-' or '?'

// - end with ' ' or ':'

// - start with an indicator character (except [?:-]) or /[?-] /

// ../node_modules/yaml/browser/dist/compose/compose-collection.js

// ../node_modules/yaml/browser/dist/compose/compose-doc.js

// ../node_modules/yaml/browser/dist/compose/compose-node.js

// ../node_modules/yaml/browser/dist/compose/compose-scalar.js

// ../node_modules/yaml/browser/dist/compose/composer.js

// ../node_modules/yaml/browser/dist/compose/resolve-block-map.js

// ../node_modules/yaml/browser/dist/compose/resolve-block-scalar.js

// ../node_modules/yaml/browser/dist/compose/resolve-block-seq.js

// ../node_modules/yaml/browser/dist/compose/resolve-end.js

// ../node_modules/yaml/browser/dist/compose/resolve-flow-collection.js

// ../node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js

// ../node_modules/yaml/browser/dist/compose/resolve-props.js

// ../node_modules/yaml/browser/dist/compose/util-contains-newline.js

// ../node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js

// ../node_modules/yaml/browser/dist/compose/util-flow-indent-check.js

// ../node_modules/yaml/browser/dist/compose/util-map-includes.js

// ../node_modules/yaml/browser/dist/doc/Document.js

// ../node_modules/yaml/browser/dist/doc/anchors.js

// ../node_modules/yaml/browser/dist/doc/applyReviver.js

// ../node_modules/yaml/browser/dist/doc/directives.js

// ../node_modules/yaml/browser/dist/errors.js

// ../node_modules/yaml/browser/dist/nodes/Alias.js

// ../node_modules/yaml/browser/dist/nodes/Collection.js

// ../node_modules/yaml/browser/dist/nodes/Node.js

// ../node_modules/yaml/browser/dist/nodes/Pair.js

// ../node_modules/yaml/browser/dist/nodes/Scalar.js

// ../node_modules/yaml/browser/dist/nodes/YAMLMap.js

// ../node_modules/yaml/browser/dist/nodes/YAMLSeq.js

// ../node_modules/yaml/browser/dist/nodes/addPairToJSMap.js

// ../node_modules/yaml/browser/dist/nodes/identity.js

// ../node_modules/yaml/browser/dist/nodes/toJS.js

// ../node_modules/yaml/browser/dist/parse/cst-scalar.js

// ../node_modules/yaml/browser/dist/parse/cst-stringify.js

// ../node_modules/yaml/browser/dist/parse/cst-visit.js

// ../node_modules/yaml/browser/dist/parse/cst.js

// ../node_modules/yaml/browser/dist/parse/lexer.js

// ../node_modules/yaml/browser/dist/parse/line-counter.js

// ../node_modules/yaml/browser/dist/parse/parser.js

// ../node_modules/yaml/browser/dist/public-api.js

// ../node_modules/yaml/browser/dist/schema/Schema.js

// ../node_modules/yaml/browser/dist/schema/common/map.js

// ../node_modules/yaml/browser/dist/schema/common/seq.js

// ../node_modules/yaml/browser/dist/schema/core/float.js

// ../node_modules/yaml/browser/dist/schema/json/schema.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/set.js

// ../node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js

// ../node_modules/yaml/browser/dist/stringify/stringify.js

// ../node_modules/yaml/browser/dist/stringify/stringifyCollection.js

// ../node_modules/yaml/browser/dist/stringify/stringifyComment.js

// ../node_modules/yaml/browser/dist/stringify/stringifyDocument.js

// ../node_modules/yaml/browser/dist/stringify/stringifyNumber.js

// ../node_modules/yaml/browser/dist/stringify/stringifyPair.js

// ../node_modules/yaml/browser/dist/stringify/stringifyString.js

// ../node_modules/yaml/browser/index.js

// 1. Block can't end in whitespace unless the last line is non-empty.

// 2. Strings consisting of only whitespace are best rendered explicitly.

// @ts-expect-error If Contents is set, let's trust the user

// @ts-expect-error Presumed impossible if Strict extends false

// @ts-expect-error Type checking misses meaning of isSrcToken

// @ts-expect-error We can't really know that this matches Contents.

// @ts-expect-error type guard is wrong here

// Account for newline escape, but don't break preceding escape

// Also checks for lines starting with %, as parsing the output as YAML 1.1 will

// At the doc level, tabs at line start may be parsed

// Bail out if lineWidth & minContentWidth are shorter than an escape string

// Block scalars use their parent rather than header indent

// Buffer inherits from Uint8Array

// Could here handle preceding comments differently

// Detect duplicate references to the same object & use Alias nodes for all

// Drop the line if last char not more indented

// ESM COMPAT FLAG

// EXPORTS

// Ensure that the known tag is available for stringifying,

// For empty nodes, assign newline-separated not indented empty tokens to following node

// For scalars, keep the old node & its comments and anchors

// If indentSeq === false, consider '- ' as part of indentation where possible

// If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part

// If the value associated with a merge key is a single mapping node, each of

// If we got a tagName matching the class, or the tag name is '!',

// Ignore all indent for top-level flow collections

// In a flow collection, only the parser handles indent.

// Include previous line in context if pointing at line start

// Keys in mapping nodes earlier in the sequence override keys specified in

// Leading | or > is added later

// Math.floor((low + high) / 2)

// Must be defined after `next()`

// NAMESPACE OBJECT: ../node_modules/yaml/browser/dist/index.js

// NAMESPACE OBJECT: ../node_modules/yaml/browser/dist/parse/cst.js

// Not actually at next item

// Not using `instanceof Schema` to allow for duck typing

// On IE 11, atob() can't handle newlines

// Only looking for newlines within the quotes

// Regexp won't match if start is trimmed

// Resolve anchors for Node.prototype.toJS()

// TODO: Should drop this special case for bare << handling

// Technically, an empty scalar is immediately after the last non-empty

// The negative lookbehind avoids a polynomial search,

// This may be wrong after doc-end, but in that case it doesn't matter

// To catch that during parsing, we include them in the block scalar value.

// Top-level block scalars with a preceding doc marker ought to use the

// Trailing insufficiently indented tabs are invalid.

// Trim to max 80 chars, keeping col position near the middle

// Type guard is intentionally a little wrong so as to be more useful,

// Unicode line separator

// Unicode next line

// Unicode non-breaking space

// Unicode paragraph separator

// Used by createMap()

// Verify that output will be parsed as a string, as e.g. plain numbers and

// Where allowed & type not set explicitly, prefer block style for multiline strings

// Without the `as symbol` casts, TS declares these in the `visit`

// `doc` is always set by compose.end(true) at the very latest

// `export * as default from ...` fails on Webpack v4

// `unique symbol` must be `const`.

// after first. The `ref` wrapper allows for circular references to resolve.

// all other values are errors

// already exists in it. If the value associated with the merge key is a

// and others in v1.1.

// as it does not cover untypable empty non-string iterables (e.g. []).

// as leading white space rather than indentation.

// assumed to be 00:00:00Z (start of day, UTC).

// backspace

// before jumping into the custom tag logic.

// bell character

// block-scalar source includes trailing newline

// booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),

// but does not get used by default.

// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind

// carriage return

// checked by containsNewline()

// checked earlier by binary.identify()

// determine chomping from whitespace at value end

// determine indent indicator from whitespace at value start

// determine the end of content & start of chomping

// double-quote

// else fallthrough

// empty line

// error

// escape character

// eslint-disable-next-line @typescript-eslint/no-array-delete

// eslint-disable-next-line @typescript-eslint/no-unsafe-call

// eslint-disable-next-line @typescript-eslint/no-unsafe-return

// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing

// fallthrough

// find the indentation level to trim from start

// flag for the preceding node's status

// folding will eat first newline

// form feed

// horizontal tab

// https://github.com/eemeli/yaml/issues/228

// https://tc39.es/ecma262/#sec-serializejsonproperty

// include trailing more-indented empty lines in content

// it.sep is true-ish if pair already has key or : separator

// item is a key+value pair

// item is a value in a seq

// its key/value pairs is inserted into the current mapping, unless the key

// json & jsonArg are only used from toJSON()

// keep

// key properties

// key value

// key with no value

// later mapping nodes. -- http://yaml.org/type/merge.html

// leading whitespace is kept intact

// line feed

// local tag

// may be -1 if this.pos === 0

// may be omitted altogether, resulting in a date format. In such a case, the time part is

// minutes

// more-indented content within a folded block

// namespace using `var`, but then complains about that because

// needs to be called before value stringifier to allow for circular anchor refs

// node, but it's more useful to place it after any whitespace.

// non-specific tag

// not allowed:

// null character

// of these nodes is merged in turn according to its order in the sequence.

// possible comment

// presume that's starting a new document.

// root is at -1

// same line for their header.

// seconds, including ms

// sequence, then this sequence is expected to contain mapping nodes and each

// shortcut for empty contents

// shortcut: check if it's a generic YAMLMap or YAMLSeq

// skip escaped CRLF newlines, but still trim the following line

// skip escaped newlines, but still trim the following line

// space after newline needs to be escaped to not be folded

// space before newline needs to be escaped to not be folded

// space surrounded by non-space can be replaced with newline + indent

// then use the tagName from the node class used to create it.

// this is an error

// this is an error caused by an unexpected unindent

// this is an error outside flow collections

// top-level block scalars need to be indented if followed by a comment

// trim trailing whitespace

// value properties

// value value

// vertical tab

// white-space collected at end may stretch past lineWidth

// → key & sep are empty, start does not include ? or :

//console.log({ dc: doc.comment, prelude, comment })
