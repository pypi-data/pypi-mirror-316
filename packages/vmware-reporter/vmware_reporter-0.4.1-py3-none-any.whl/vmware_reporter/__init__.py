"""
Top-level API of vmware-reporter library.
"""
from __future__ import annotations

import atexit
import json
import logging
import os
import re
import urllib3
import requests
from collections.abc import Callable, Iterator
from configparser import _UNSET
from contextlib import nullcontext
from datetime import date
from io import IOBase
from pathlib import Path
from types import (BuiltinFunctionType, BuiltinMethodType, FunctionType,
                   MethodType)
from typing import Any, Iterable, Literal, TypeVar, overload
from uuid import UUID

from pyVim.connect import Disconnect, SmartConnect
from pyVmomi import vim, vmodl
from pyVmomi.VmomiSupport import _managedDefMap
from zut import (ExtendedJSONEncoder, Filters, SimpleError,
                 tabular_loader, configure_smb_credentials, get_variable, get_secret_variable, get_bool_variable, get_list_variable)
from zut.excel import ExcelWorkbook, is_excel_path, split_excel_path

from .settings import OUT_DIR

__prog__ = 'vmware-reporter'

try:
    # Version generated by setuptools_scm during build
    from ._version import __version__, __version_tuple__
except ImportError:
    __version__ = None
    __version_tuple__ = None

_logger = logging.getLogger(__name__)

T_Obj = TypeVar('T_Obj', bound=vim.ManagedEntity)


class VCenterClient:
    """
    Main entry point of the library to retrieve VMWare managed objects and interact with them. 
    """
    _instances: dict[str,VCenterClient] = {}

    @classmethod
    def for_scope(cls, scope: str = None):
        if vcenter := cls._instances.get(scope):
            return vcenter
        else:
            return VCenterClient(scope)


    def __init__(self, scope: str = None, *, host: str = None, user: str = None, password: str = None, no_ssl_verify: bool = None, out_dir: str|Path = None):
        """
        Create a new vCenter client.

        If `host`, `user`, `password` or `no_ssl_verify` options are not provided, they are read from environment variables (VMWARE_*).

        :param scope: An optional name to distinguish between several vCenters.
        :param host: Host name of the vCenter.
        :param user: Name of the vCenter user having access to the API.
        :param password: Password of the vCenter user having access to the API.
        """        
        if not scope:
            scopes = VCenterClient.get_available_scopes()
            if len(scopes) > 1:
                raise SimpleError(f"VCenter scope must be provided. Available: {', '.join(scopes) if scopes else 'none'}.")
            elif len(scopes) == 1:
                scope = scopes[0]

        self.scope = scope

        if self.scope in self._instances:
            raise ValueError(f"VCenter already instanciated for scope {self.scope}")
        else:
            if not self._instances:
                configure_smb_credentials(once=True)                    
                atexit.register(self._atexit)
            self._instances[self.scope] = self
        
        scope_suffix = f'_{self.scope}' if self.scope else ''
        self.host = host if host is not None else get_variable(f'VMWARE{scope_suffix}_HOST')
        self.user = user if user is not None else get_variable(f'VMWARE{scope_suffix}_USER')
        self.password = password if password is not None else get_secret_variable(f'VMWARE{scope_suffix}_PASSWORD')
        self.no_ssl_verify = no_ssl_verify if no_ssl_verify is not None else get_bool_variable(f'VMWARE{scope_suffix}_NO_SSL_VERIFY')

        if out_dir is None:
            out_dir = OUT_DIR
        self.data_dir = Path(str(out_dir).format(scope=scope if scope else ''))
        
        self._logger = logging.getLogger(f'{self.__class__.__module__}.{self.__class__.__qualname__}' + (f'.{self.scope}' if self.scope else ''))

        self._service_instance: vim.ServiceInstance = None
        self._service_content: vim.ServiceInstanceContent = None
        self._rest_session = requests.Session()

        # Cached objects
        self._cookie: dict = None
        self._datacenter: vim.Datacenter = None
        self._objs_by_ref: dict[str,vim.ManagedEntity] = {}
        self._portgroups_by_key: dict[str,vim.dvs.DistributedVirtualPortgroup] = None
        self._switchs_by_uuid: dict[str,vim.dvs.DistributedVirtualPortgroup] = None        
        self._perf_intervals_by_name: dict[str,vim.HistoricalInterval] = None
        self._categories: dict[UUID,Category] = None
        self._tags: dict[UUID,Tag] = None


    def __str__(self):
        return type(self).__name__ + (f':{self.scope}' if self.scope else '')
    

    #region Enter/connect and exit/close

    def __enter__(self):
        self.connect()
        return self


    def __exit__(self, exc_type = None, exc_value = None, exc_traceback = None):
        self.close()


    def connect(self):
        self._logger.debug("Connect to %s vcenter (host: %s, user: %s)", self.scope if self.scope else '', self.host, self.user)
        self._service_instance = SmartConnect(host=self.host, user=self.user, pwd=self.password, disableSslCertValidation=self.no_ssl_verify)


    def close(self):
        if self._service_instance is not None:
            self._logger.debug("Disconnect from %s vcenter (%s, user: %s)", self.scope if self.scope else '', self.host, self.user)
            Disconnect(self._service_instance)
            self._service_instance = None
        
        self._rest_disconnect()
    

    @classmethod
    def _atexit(cls):
        for instance in cls._instances.values():
            instance.close()


    @property
    def service_instance(self) -> vim.ServiceInstance:
        if self._service_instance is None:
            self.connect()
        return self._service_instance


    @property
    def service_content(self) -> vim.ServiceInstanceContent:
        if self._service_content is None:
            self._service_content = self.service_instance.RetrieveContent()
        return self._service_content
    
    #endregion


    #region Retrieve managed objects

    @property
    def datacenter(self):
        if self._datacenter is None:
            datacenters = self.get_objs(vim.Datacenter)
            if not datacenters:
                raise ValueError(f"Datacenter not found")
            if len(datacenters) > 1:
                raise ValueError(f"Several datacenter found")
            self._datacenter = datacenters[0]
        return self._datacenter
    

    def get_obj_by_ref(self, ref: str, default = _UNSET):
        if obj := self._objs_by_ref.get(ref):
            return obj
        else:
            m = re.match(r'^([^\-]+)\-[a-z]?\d+$', ref)
            if not m:
                raise ValueError(f"Invalid ref format: {ref}")
            obj_type = OBJ_TYPES_BY_REFPREFIX.get(m[1])
            if not obj_type:
                raise ValueError(f"Unknown ref prefix: {m[1]}")
            
            try:
                obj = self.get_obj(obj_type, ref, key='ref')
            except KeyError:
                if default is _UNSET:
                    raise
                else:
                    return default

            # added in cache ('_objs_by_ref') in method 'get_obj()' -> 'iter_objs()'
            return obj


    def get_obj(self, type: type[T_Obj], search: list[str|re.Pattern]|str|re.Pattern|UUID, *, normalize: bool = False, key: Literal['name', 'ref', 'uuid', 'bios_uuid'] = 'name') -> T_Obj:
        """
        Find a single VMWare managed object.

        Raise KeyError if not found or several found.
        """
        if key in ['uuid', 'bios_uuid']:
            if not isinstance(search, (UUID,str)):
                raise TypeError(f"specs must be UUID or str for key {key}, got {type(search).__name__}")
            
            if isinstance(search, UUID):
                uuid = search
            else:
                uuid = UUID(search)

            obj = None
            
            if key == 'bios_uuid':
                # NOTE: uuid is "BIOS UUID". Seems to match the end of `sudo cat /sys/class/dmi/id/product_uuid`.
                if type == vim.VirtualMachine:
                    obj = self._find_by_uuid(uuid, for_vm=True, instance_uuid=False)
                else:
                    raise ValueError(f"key '{key}' can be used only for virtual machines")
                
            else:
                if type == vim.VirtualMachine:
                    obj = self._find_by_uuid(uuid, for_vm=True, instance_uuid=True)
                elif type == vim.HostSystem:
                    obj = self._find_by_uuid(uuid, for_vm=False, instance_uuid=False)
                else:
                    raise ValueError(f"key '{key}' can be used only for virtual machines or host systems")

            if obj:
                self._objs_by_ref[get_obj_ref(obj)] = obj
                return obj
            else:
                raise KeyError(f"Not found: {search} (type: {type.__name__})")

        else:
            iterator = self.iter_objs(types=type, search=search, normalize=normalize, key=key)
            try:
                found = next(iterator)
            except StopIteration:
                raise KeyError(f"Not found: {search} (type: {type.__name__})")
            
            try:
                next(iterator)
                raise KeyError(f"Several found: {search} (type: {type.__name__})")
            except StopIteration:
                pass
            return found
            

    def _find_by_uuid(self, uuid: UUID|str, for_vm: bool, instance_uuid: bool):
        if isinstance(uuid, UUID):
            uuid = str(uuid)
        
        for datacenter in self.iter_objs(vim.Datacenter):
            obj = self.service_content.searchIndex.FindByUuid(datacenter, uuid, vmSearch=for_vm, instanceUuid=instance_uuid)
            if obj:
                return obj


    @overload
    def get_objs(self, types: type[T_Obj], search: list[str|Path|re.Pattern]|str|Path|re.Pattern = None, *, normalize: bool = None, key: Literal['name', 'ref'] = 'name', first: bool = False, sort_key: str|list[str]|Callable = None) -> list[T_Obj]:
        ...

    def get_objs(self, types: list[type|str]|type|str = None, search: list[str|Path|re.Pattern]|str|Path|re.Pattern = None, *, normalize: bool = None, key: Literal['name', 'ref'] = 'name', first: bool = False, sort_key: str|list[str]|Callable = None):        
        """
        List VMWare managed objects matching the given search.
        """
        objs = []

        for obj in self.iter_objs(types, search, normalize=normalize, key=key, first=first):
            objs.append(obj)

        if sort_key:
            if isinstance(sort_key, str):
                sort_key = [sort_key]

            if isinstance(sort_key, list):
                sort_func = lambda obj: [getattr(obj, attr) for attr in sort_key]
            else:
                sort_func = sort_key

            objs.sort(key=sort_func)

        return objs


    @overload
    def iter_objs(self, types: type[T_Obj], search: list[str|Path|re.Pattern]|str|Path|re.Pattern = None, *, normalize: bool = None, key: Literal['name', 'ref'] = 'name', first: bool = False) -> Iterator[T_Obj]:
        ...

    def iter_objs(self, types: list[type|str]|type|str = None, search: list[str|Path|re.Pattern]|str|Path|re.Pattern = None, *, normalize: bool = None, key: Literal['name', 'ref'] = 'name', first: bool = False):
        """
        Iterate over VMWare managed objects matching the given search.
        """
        # Expand search from CSV or Excel files if search ends with '.csv' or '.xlsx'
        search = _expand_search_from_files(search, key=key)

        # Prepare value filter
        filters = Filters(search, normalize=normalize)

        # Prepare types
        if not types:
            types = []
        elif isinstance(types, (str,type)):
            types = [types]
        
        types = [get_obj_type(_type) for _type in types]

        # Search using a container view
        view = None
        try:
            view = self.service_content.viewManager.CreateContainerView(self.service_content.rootFolder, types, recursive=True)

            obj_types = set()

            for obj in view.view:
                self._objs_by_ref[get_obj_ref(obj)] = obj
                obj_type = type(obj)
                if first and obj_type in obj_types:
                    continue

                if self._obj_matches(obj, key, filters):
                    if first:
                        obj_types.add(obj_type)
                    yield obj
        finally:
            if view:
                view.Destroy()


    def _obj_matches(self, obj: vim.ManagedEntity, key: Literal['name', 'ref'], filters: Filters):
        if not filters:
            return True
        
        if key == 'name':
            try:
                value = obj.name
            except vim.fault.NoPermission:
                return False
            
        elif key == 'ref':
            value = get_obj_ref(obj)
            
        else:
            raise ValueError(f"key not supported: {key}")
        
        return filters.matches(value)

    #endregion


    #region Instance helpers

    @property
    def cookie(self) -> dict:
        if self._cookie is None:    
            # Get the cookie built from the current session
            client_cookie = self.service_instance._stub.cookie

            # Break apart the cookie into it's component parts
            cookie_name = client_cookie.split("=", 1)[0]
            cookie_value = client_cookie.split("=", 1)[1].split(";", 1)[0]
            cookie_path = client_cookie.split("=", 1)[1].split(";", 1)[1].split(
                ";", 1)[0].lstrip()
            cookie_text = " " + cookie_value + "; $" + cookie_path

            # Make a cookie
            self._cookie = dict()
            self._cookie[cookie_name] = cookie_text
        return self._cookie


    def wait_for_task(self, tasks: vim.Task|list[vim.Task]|dict[vim.Task,str], *, success_callback=None, error_callback=None):
        """
        Given a service instance and tasks, return after all the tasks are complete.
        - `tasks`: a task, a list of tasks, or a dict associating task to log prefixes.
        """
        task_list: list[vim.Task] = []
        log_prefixes: dict[vim.Task,str] = {}
        if isinstance(tasks, dict):
            log_prefixes = tasks
            for task in tasks.keys():
                if not isinstance(task, vim.Task):
                    raise TypeError(f"Invalid dict key: {task} (type {type(task).__name__}, expected vim.Task)")
                task_list.append(task)
        elif isinstance(tasks, list):
            for task in tasks:
                if not isinstance(task, vim.Task):
                    raise TypeError(f"Invalid list element: {task} (type {type(task).__name__}, expected vim.Task)")
                task_list.append(task)
        elif isinstance(tasks, vim.Task):
            task_list.append(tasks)
        else:
            raise TypeError(f"Invalid argument: {task} (type {type(task).__name__}, expected vim.Task)")
        
        # Create filter
        obj_specs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task) for task in task_list]   
        property_spec = vmodl.query.PropertyCollector.PropertySpec(type=vim.Task, pathSet=[], all=True)
        filter_spec = vmodl.query.PropertyCollector.FilterSpec(objectSet=obj_specs, propSet=[property_spec])
        pc = self.service_instance.content.propertyCollector
        pc_filter = pc.CreateFilter(filter_spec, True)

        task_failures = 0
        try:
            remaining_task_strs = [str(task) for task in task_list]
            version = None
            state = None
            # Loop looking for updates till the state moves to a completed state.
            # (tasks are removed from task_list one by one when they reach a completed)
            while remaining_task_strs:
                update = pc.WaitForUpdates(version)
                for filter_set in update.filterSet:
                    for obj_set in filter_set.objectSet:
                        task: vim.Task = obj_set.obj
                        for change in obj_set.changeSet:
                            if change.name == 'info':
                                state = change.val.state
                            elif change.name == 'info.state':
                                state = change.val
                            else:
                                continue

                            if not str(task) in remaining_task_strs:
                                continue

                            if state == vim.TaskInfo.State.success:
                                remaining_task_strs.remove(str(task))
                                if log_prefix := log_prefixes.get(task):
                                    self._logger.info(f"{log_prefix}: SUCCESS")
                                if success_callback:
                                    success_callback(task)
                            elif state == vim.TaskInfo.State.error:
                                if len(task_list) > 1:
                                    remaining_task_strs.remove(str(task))
                                    log_prefix = log_prefixes.get(task)
                                    self._logger.error(f"{f'{log_prefix}: ' if log_prefix else ''}{task.info.error}", exc_info=task.info.error)                                        
                                    if error_callback:
                                        error_callback(task, task.info.error)
                                    task_failures += 1
                                else:
                                    raise task.info.error
                # Move to next version
                version = update.version
        finally:
            if pc_filter:
                pc_filter.Destroy()

        if task_failures > 0:
            raise SimpleError(f"{task_failures} task{'s' if task_failures > 1 else ''} failed (see previous logs)")

    #endregion


    #region Class helpers

    _available_scopes: list[str] = None
    
    @classmethod
    def get_available_scopes(cls):
        if cls._available_scopes is None:
            cls._available_scopes = get_list_variable('VMWARE_SCOPES', [])

        return cls._available_scopes
    
    #endregion


    #region Retrieve specific cached objects
    
    def get_portgroup_by_key(self, key: str) -> vim.dvs.DistributedVirtualPortgroup:
        if key is None:
            return None
        
        if self._portgroups_by_key is None:
            self._portgroups_by_key = {}
            for obj in self.iter_objs(vim.dvs.DistributedVirtualPortgroup):
                self._portgroups_by_key[obj.key] = obj

        return self._portgroups_by_key.get(key)
    
    def get_switch_by_uuid(self, uuid: str) -> vim.DistributedVirtualSwitch:
        if uuid is None:
            return None
        
        if self._switchs_by_uuid is None:
            self._switchs_by_uuid = {}
            for obj in self.iter_objs(vim.DistributedVirtualSwitch):
                self._switchs_by_uuid[obj.uuid] = obj

        return self._switchs_by_uuid.get(uuid)
    
    @property
    def perf_intervals_by_name(self):
        if self._perf_intervals_by_name is None:
            pm = self.service_content.perfManager
            self._perf_intervals_by_name = {interval.name: interval for interval in pm.historicalInterval}
        return self._perf_intervals_by_name
    
    #endregion


    #region REST API client
    # See: https://gist.github.com/em2er/74cdabdd0fd337f382939df3e5f6a68e
    # See: https://vdc-download.vmware.com/vmwb-repository/dcr-public/1cd28284-3b72-4885-9e31-d1c6d9e26686/71ef7304-a6c9-43b3-a3cd-868b2c236c81/doc/index.html

    def _rest_disconnect(self):
        if 'vmware-api-session-id' in self._rest_session.headers:
            self.rest_request('/rest/com/vmware/cis/session', method='DELETE')
            self._rest_session.headers.pop('vmware-api-session-id')

    def rest_request(self, path: str, *, method = 'GET', **options):
        if not 'vmware-api-session-id' in self._rest_session.headers and not 'auth' in options:
            session_id = self.rest_request('/rest/com/vmware/cis/session', method='POST', auth=(self.user, self.password))
            self._rest_session.headers.update({'vmware-api-session-id': session_id})

        self._logger.debug("%s %s", method, path)
        url = f"https://{self.host}{path}"

        with urllib3.warnings.catch_warnings() if self.no_ssl_verify else nullcontext():
            if self.no_ssl_verify:
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            response = self._rest_session.request(method, url, verify=not self.no_ssl_verify, **options)

        response.raise_for_status()
        if response.headers.get('content-type') == 'application/json':
            dict_response = response.json()
            self._logger.debug("JSON response: %s", dict_response)
            return dict_response['value']
        else:
            if self._logger.isEnabledFor(logging.DEBUG):
                text_response = response.text
                self._logger.debug("TEXT response: %s", text_response)
            return None
    
    @property
    def categories(self):
        if self._categories is None:
            self._categories = {}
            for category_id in self.rest_request('/rest/com/vmware/cis/tagging/category'):
                structure = self.rest_request(f'/rest/com/vmware/cis/tagging/category/id:{category_id}')
                category = Category(structure)
                self._categories[category.uuid] = category
        return self._categories

    def get_categories(self) -> Iterable[Category]:
        return self.categories.values()

    def get_category_by_key(self, key: str|UUID):
        if isinstance(key, str):
            key = Category.parse_id(key)
        return self.categories[key]

    @property
    def tags(self):
        if self._tags is None:
            self._tags = {}
            for tag_id in self.rest_request('/rest/com/vmware/cis/tagging/tag'):
                data = self.rest_request(f'/rest/com/vmware/cis/tagging/tag/id:{tag_id}')
                tag = Tag(data, self.categories)
                self._tags[tag.uuid] = tag
        return self._tags

    def get_tags(self) -> Iterable[Tag]:
        return self.tags.values()

    def get_tag_by_key(self, key: str|UUID):
        if isinstance(key, str):
            key = Tag.parse_id(key)
        return self.tags[key]
    
    def get_obj_tags(self, obj: vim.ManagedObject):
        tag_ids = self.rest_request(f'/rest/com/vmware/cis/tagging/tag-association?~action=list-attached-tags', method='POST', json={
            "object_id": {
                "id": get_obj_ref(obj),
                "type": get_obj_typename(obj),
            }
        })
        return [self.get_tag_by_key(tag_id) for tag_id in tag_ids]

    #endregion



class Category:
    def __init__(self, structure):
        self.uuid = self.parse_id(structure['id'])
        self.name: str = structure['name']
        self.description: str = structure['description']
        self.cardinality: str = structure['cardinality']
        self.associable_types: list[str] = structure['associable_types']

    @classmethod
    def parse_id(cls, id: str):                    
        if m := re.match(r'^urn:vmomi:InventoryServiceCategory:([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}):GLOBAL$', id):
            return UUID(m[1])
        else:
            raise ValueError(f"Invalid category id: {id}")
        
    @property
    def id(self):
        return f"urn:vmomi:InventoryServiceCategory:{self.uuid}:GLOBAL"
    
    def __repr__(self):
        return self.name


class Tag:
    def __init__(self, structure, categories: dict[UUID,Category]):
        self.uuid = self.parse_id(structure['id'])
        self.name: str = structure['name']
        self.description: str = structure['description']
        self.category = categories[Category.parse_id(structure['category_id'])]

    @classmethod
    def parse_id(cls, id: str):                    
        if m := re.match(r'^urn:vmomi:InventoryServiceTag:([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}):GLOBAL$', id):
            return UUID(m[1])
        else:
            raise ValueError(f"Invalid tag id: {id}")
        
    @property
    def id(self):
        return f"urn:vmomi:InventoryServiceTag:{self.uuid}:GLOBAL"
    
    def __repr__(self):
        return self.name


def _expand_search_from_files(search: list[str|Path|re.Pattern]|str|Path|re.Pattern|None, *, key: Literal['name', 'ref'] = 'name') -> list[str|re.Pattern]|None:
    """
    Expand search from CSV or Excel files if search ends with '.csv' or '.xlsx'.
    """
    if search is None:
        return None
    elif isinstance(search, (str,Path,re.Pattern)):
        search = [search]
    
    def expand_from_xlsx_file(path: Path, table_name: str = None):
        workbook = ExcelWorkbook(path)
        table = workbook.get_table(table_name)
        if not key in table.column_names:
            raise ValueError(f"Column \"{key}\" not found in {path}")
        for row in table:
            if row[key]:
                if row.get('status') == 'IGNORE':
                    _logger.info(f"Ignore {key}")
                else:
                    yield row[key]

    def expand_from_csv_file(path: Path):
        for row in tabular_loader(path):
            if not key in row:
                raise ValueError(f"Column \"{key}\" not found in {path}")
            if row[key]:
                yield row[key]
    
    result = []
    for elem in search:
        if isinstance(elem, Path):
            if elem.suffix.lower() == '.xlsx':
                for file_elem in expand_from_xlsx_file(elem):
                    result.append(file_elem)
            elif elem.suffix.lower() == '.csv':
                for file_elem in expand_from_csv_file(elem):
                    result.append(file_elem)
            else:
                raise ValueError(f"Invalid search path extension: {elem}")
        elif isinstance(elem, str):
            if is_excel_path(elem, accept_table_suffix=True):
                path, table_name = split_excel_path(elem)
                for file_elem in expand_from_xlsx_file(path, table_name):
                    result.append(file_elem)
            elif elem.lower().endswith('.csv'):
                for file_elem in expand_from_csv_file(Path(elem)):
                    result.append(file_elem)
            else:
                result.append(elem)
        else:
            result.append(elem)

    return result


OBJ_TYPES_BY_REFPREFIX = {
    'datacenter':    vim.Datacenter,
    'group':         vim.Folder,
    'dvportgroup':   vim.dvs.DistributedVirtualPortgroup,
    'dvs':           vim.dvs.VmwareDistributedVirtualSwitch,
    'network':       vim.Network,
    'datastore':     vim.Datastore,
    'domain':        vim.ComputeResource,
    'resgroup':      vim.ResourcePool,
    'host':          vim.HostSystem,
    'vm':            vim.VirtualMachine,
}


OBJ_TYPES = {
    **OBJ_TYPES_BY_REFPREFIX,
    # aliases
    'cluster':       vim.ClusterComputeResource,  # ref_prefix is 'domain', followed by '-c'
    'folder':        vim.Folder,
    'pool':          vim.ResourcePool,
}

_key: str
for _key in _managedDefMap.keys():
    if not _key.startswith('vim.'):
        continue

    _attr = _key[len('vim.'):]
    _type = getattr(vim, _attr)
    if not issubclass(_type, vim.ManagedEntity):
        continue

    lower = _attr.lower()
    if lower in OBJ_TYPES:
        continue
    OBJ_TYPES[lower] = _type


_obj_names: dict[vim.ManagedObject, str] = {}

def get_obj_name(obj: vim.ManagedObject, use_cache=False) -> str:
    if obj is None:
        return None

    if use_cache:
        name = _obj_names.get(obj)
        if name is not None:
            return name
    
    try:
        if isinstance(obj, vim.ResourcePool) and obj.name == 'Resources' and obj.parent:
            name = f"{obj.parent.name}/{obj.name}"
        else:
            name = obj.name
    except Exception as err:
        _logger.exception(f"Cannot get name of {get_obj_ref(obj)}")
        name = f'!{type(err.__name__)}({get_obj_ref(obj)})'

    _obj_names[obj] = name
    return name


def get_obj_ref(obj: vim.ManagedObject) -> str:
    """
    Get the value of the Managed Object Reference (MOR) of the given object.

    See: https://vdc-repo.vmware.com/vmwb-repository/dcr-public/1ef6c336-7bef-477d-b9bb-caa1767d7e30/82521f49-9d9a-42b7-b19b-9e6cd9b30db1/mo-types-landing.html
    """
    if obj is None:
        return None
    
    text = str(obj)
    m = re.match(r"^'(.*)\:(.*)'$", text)
    if not m:
        raise ValueError(f'Invalid object identifier: {text}')
    
    expected_type = type(obj).__name__
    if m.group(1) != expected_type:
        raise ValueError(f'Invalid type for object identifier: {text}, expected: {expected_type}')
    return m.group(2)


def get_obj_path(obj: vim.ManagedEntity, full: bool = False) -> str:
    """ Return the path of the given managed entity. """
    if obj is None:
        return None
    
    if isinstance(obj, vim.Datacenter):
        return obj.name
    if not full:
        if obj.parent:
            if isinstance(obj.parent, vim.Datacenter):
                return None            
            super_parent = obj.parent.parent
            if isinstance(super_parent, vim.Datacenter):
                return obj.name
                
    if not obj.parent:
        return obj.name
    else:        
        return get_obj_path(obj.parent, full=full) + "/" + obj.name


def get_obj_type(value: str|type|vim.ManagedEntity) -> type[vim.ManagedEntity]:
    if not value:
        return None
    
    elif isinstance(value, type):
        if not issubclass(value, vim.ManagedEntity):
            raise TypeError(f"Type {value} is not a subclass of vim.ManagedEntity")
        
        return value
    
    elif isinstance(value, vim.ManagedEntity):
        return type(value)
    
    elif not isinstance(value, str):
        raise TypeError(f"Invalid type for {value}")
    
    else:
        lower = value.lower()

        # Search in types
        if lower in OBJ_TYPES:
            return OBJ_TYPES[lower]

        raise KeyError(f"Managed object type not found for {value}")


def get_obj_typename(obj_or_type: type[vim.ManagedObject]|vim.ManagedObject) -> str:
    if not obj_or_type:
        return None
    
    if not isinstance(obj_or_type, type):
        obj_or_type = type(obj_or_type)
    
    return obj_or_type.__name__.split('.')[-1]


def get_obj_refprefix(obj_or_type: type[vim.ManagedEntity]|vim.ManagedEntity):
    if not obj_or_type:
        return None
    
    if not isinstance(obj_or_type, type):
        obj_or_type = type(obj_or_type)

    for refprefix, _type in OBJ_TYPES_BY_REFPREFIX.items():
        if issubclass(obj_or_type, _type):
            return refprefix
    raise ValueError(f"Ref prefix not found for type: {obj_or_type.__name__}")


def identify_obj(obj: vim.ManagedObject) -> dict:
    if obj is None:
        return None

    if not isinstance(obj, vim.ManagedObject):
        raise ValueError(f'invalid type: {type(obj)}')

    data = {
        "_type": type(obj).__name__, # managed object type
        "ref": get_obj_ref(obj),
    }

    try:
        if name := getattr(obj, 'name', None):
            data["name"] = name            
    except vim.fault.NoPermission:
        data["name"] = '!error:no_permission'

    if 'name' in data and data["name"] == "Resources" and isinstance(obj, vim.ResourcePool) and hasattr(obj, 'parent') and isinstance(obj.parent, vim.ClusterComputeResource):
        # root resource pool of a cluster (named 'Resources'): let's prepend cluster name
        data["name"] = obj.parent.name + "/" + data["name"]

    return data
    

def dictify_value(data: list|str):
    """
    Return a dict if data is a list of OptionValue, StringValue or SystemIdentificationInfo objects, or if it is a string like guestOS.detailed.data.
    Otherwise leave as is.
    """
    def allinstance(enumerable_instance, element_type):
        any = False
        for element in enumerable_instance:
            any = True
            if not isinstance(element, element_type):
                return False
        return any
        
    if isinstance(data, list):
        if allinstance(data, vim.option.OptionValue) or allinstance(data, vim.CustomFieldsManager.StringValue): #example for vm: config.extraConfig, summary.config.customValue
            result = {}
            for ov in data:
                key = ov.key
                value = ov.value
                if key == "guestOS.detailed.data":
                    value = dictify_value(value)
                result[key] = value
            return result

        elif allinstance(data, vim.host.SystemIdentificationInfo): #example for host: summary.hardware.otherIdentifyingInfo
            result = {}
            for ov in data:
                key = ov.identifierType.key
                value = ov.identifierValue
                result[key] = value
            return result

        else:
            return data
    
    if isinstance(data, str):
        if matches := re.findall(r"([a-zA-Z0-9]+)='([^']+)'", data): # example: guestOS.detailed.data
            result = {}
            for m in matches:
                key = m[0]
                value = m[1]
                if key == 'bitness' and re.match(r'^\d+$', value):
                    value = int(value)
                result[key] = value
            return result

        else:
            return data       
        
    else:
        return data


def dictify_obj(obj: vim.ManagedEntity, *, object_types=False, exclude_keys=[], max_depth=None) -> dict:
    """
    Export all available information about the given VMWare managed object to a dictionnary.
    """    
    for key in ['dynamicProperty', 'recentTask']:
        if not key in exclude_keys:
            exclude_keys.append(key)
    exclude_keys_containing = ['capability', 'alarm']
    keypath = []

    def keypath_str():
        s = ''
        for key in keypath:
            s += ('.' if s and not isinstance(key, int) else '') + (f"[{key}]" if isinstance(key, int) else key)
        return s

    def forward(key: str):
        keypath.append(key)

    def backward():
        del keypath[-1]

    def handle_object(obj: object):
        if method := getattr(obj.__class__, 'to_dict', None):
            value = method(obj)
            if value and object_types:
                    return { '_type': type(obj).__name__, **value }
            return value

        result = { '_type': type(obj).__name__ } if object_types else {}
        any = False
        for key in dir(obj):
            ignore = False
            if key.startswith('_') or key in exclude_keys:
                ignore = True
            else:
                for containing in exclude_keys_containing:
                    if containing in key.lower():
                        ignore = True
                        break

            if ignore:
                continue

            forward(key)
            
            try:
                value = getattr(obj, key)
            except: # problem getting the data (e.g. invalid/not-supported accessor)
                _key = keypath_str()
                if _key not in ['configManagerEnabled', 'environmentBrowser']:
                    _logger.error('Cannot read attribute: %s', _key)
                value = "!error:cannot_read"
            
            value = handle_any(value)

            if value is not None:
                result[key] = value
                any = True

            backward()

        if any:
            return result

    def handle_dict(data: dict):
        result = {}
        any = False
        for key in data:
            forward(key)
            value = handle_any(data[key])
            if value is not None:
                result[key] = value
                any = True
            backward()

        if any:
            return result

    def handle_list(data: list):
        result = dictify_value(data)
        if isinstance(result, dict):
            return result

        # general case
        result = []
        any = False
        for i, value in enumerate(data):
            forward(i)
            extracted = handle_any(value)
            if extracted is not None:
                result.append(extracted)
                any = True
            backward()

        if any:
            return result

    def handle_any(data):
        if data is None or isinstance(data, (type, FunctionType, MethodType, BuiltinMethodType, BuiltinFunctionType)):
            return None
        
        elif isinstance(data, (str, int, float, complex)):
            return data

        elif isinstance(data, date):
            if data.year == 1970 and data.month == 1 and data.day == 1:
                return None
            return data

        elif isinstance(data, vim.ManagedObject):
            if not keypath: # depth == 0
                result = identify_obj(data)
                for key, value in handle_object(data).items():
                    result[key] = value
                return result
            else:
                return identify_obj(data)

        elif max_depth and len(keypath) >= max_depth:
            _logger.error('Reached max depth: %s', type(data).__name__)
            return f"!error:max_depth({type(data).__name__})"

        elif isinstance(data, dict):
            return handle_dict(data)

        elif isinstance(data, list):
            return handle_list(data)
            
        else:
            return handle_object(data)

    return handle_any(obj)


def export_obj(obj: vim.ManagedObject, obj_out: os.PathLike|IOBase, *, title: str = None):
    if not title:
        title = getattr(obj, 'name', None)
        if not title:
            title = type(obj).__name__

    if isinstance(obj_out, IOBase):
        out_name = getattr(obj_out, 'name', '<io>')
    else:
        out_name = str(obj_out)

    data = dictify_obj(obj)

    _logger.info(f"Export {title} to {out_name}")
    
    if not isinstance(obj_out, IOBase):
        if dir := os.path.dirname(obj_out):
            os.makedirs(dir, exist_ok=True)

    with nullcontext(obj_out) if isinstance(obj_out, IOBase) else open(obj_out, 'w', encoding='utf-8') as fp:
        json.dump(data, fp=fp, indent=4, cls=ExtendedJSONEncoder, ensure_ascii=False)


# For docs
__all__ = (
    '__prog__', '__version__', '__version_tuple__',
    'VCenterClient', 'Category', 'Tag',
    'OBJ_TYPES_BY_REFPREFIX', 'OBJ_TYPES',
    'get_obj_name', 'get_obj_ref', 'get_obj_path', 'get_obj_type', 'get_obj_typename', 'get_obj_refprefix', 'identify_obj', 'dictify_value', 'dictify_obj', 'export_obj',
)
