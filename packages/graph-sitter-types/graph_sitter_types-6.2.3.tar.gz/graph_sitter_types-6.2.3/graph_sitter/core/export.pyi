"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod
from typing import Generic, Self, TYPE_CHECKING, TypeVar
from tree_sitter import Node as TSNode
from codegen.utils.codemod.codemod_writer_decorators import apidoc, noapidoc
from graph_sitter.codebase.codebase_graph import CodebaseGraph
from graph_sitter.core.interfaces.exportable import Exportable
from graph_sitter.core.node_id_factory import NodeId
from graph_sitter.extensions.autocommit import commiter
from graph_sitter.core.statements.export_statement import ExportStatement

if TYPE_CHECKING:
    ...
Parent = TypeVar("Parent", bound="ExportStatement")
@apidoc
class Export(Exportable[Parent], Generic[Parent]):
    """Represents a single symbol being exported."""
    export_statement: ExportStatement
    def __init__(self, ts_node: TSNode, file_node_id: NodeId, G: CodebaseGraph, parent: Parent) -> None:
        ...
    
    @noapidoc
    @abstractmethod
    def parse(self, G: CodebaseGraph) -> None:
        """Add self to the graph and SYMBOL_USAGE edges from export to exported symbol."""
        ...
    
    @property
    @abstractmethod
    def exported_symbol(self) -> Exportable | None:
        """Returns the symbol, file, or import being exported from this export object.

        Gets the underlying object that is being exported, which could be a symbol, file, or import.
        This is the inverse of Import.imported_symbol.

        Returns:
            Exportable | None: The symbol, file, or import being exported, or None if the exported item cannot be resolved.
        """
        ...
    
    @property
    @abstractmethod
    def resolved_symbol(self) -> Exportable | None:
        """Returns the resolved symbol for an export.

        Gets the final symbol, file, or external module that this export resolves to by following through indirect imports and exports. For example, if file A
        exports symbol X which is imported from file B, which in turn imports X from file C, this method will return the original symbol X from file C.

        Args:
            None

        Returns:
            Exportable | None: The final resolved symbol, which can be a Symbol, File, or External module. Returns None if the symbol cannot be resolved.
        """
        ...
    
    @abstractmethod
    def is_named_export(self) -> bool:
        """Returns whether the export is named or a default export.

        Determines if the current export is a named export (e.g., 'export { foo }') or a default export (e.g., 'export default foo').

        Returns:
            bool: True if the export is named, False if it is a default export.
        """
        ...
    
    @abstractmethod
    def is_module_export(self) -> bool:
        """Determines if this export exports symbols in the file as a module.

        This method checks if the export statement represents a module-level export, such as wildcard exports or default object exports.
        Module-level exports export multiple symbols from a file as a single module unit.

        Returns:
            bool: True if the export is a module-level export, False otherwise.
        """
        ...
    
    def is_aliased(self) -> bool:
        """Determines if this Export object is aliased.

        Checks if the exported symbol has a different name than the name it is exported as.
        For example, `export { foo as bar }` would return True.

        Returns:
            bool: True if the exported symbol has a different name than the name it is exported as,
                False otherwise.
        """
        ...
    
    @noapidoc
    @commiter
    def compute_export_dependencies(self) -> None:
        ...
    
    @property
    @noapidoc
    def parent_symbol(self) -> Self:
        """Returns the parent symbol of the symbol."""
        ...
    


